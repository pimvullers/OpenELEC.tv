From 02ead960e8818cc580e7a94218860d1a49abc759 Mon Sep 17 00:00:00 2001
From: kolasa <kkolasa@winsoft.pl>
Date: Sat, 18 May 2013 21:27:43 +0200
Subject: [PATCH] Full switch to proc_create for kernel >= 3.10 Fix error
 return code in start_kthread()

---
 .../core/rtw_debug.c                               | 548 ++++++++++++++++++++-
 .../include/rtw_debug.h                            |  80 ++-
 .../os_dep/linux/os_intfs.c                        | 314 ++++++++++--
 .../os_dep/osdep_service.c                         |   3 +-
 4 files changed, 875 insertions(+), 70 deletions(-)

diff --git a/core/rtw_debug.c b/core/rtw_debug.c
index 018fe48..d4f6e7d 100644
--- a/core/rtw_debug.c
+++ b/core/rtw_debug.c
@@ -79,12 +79,12 @@ int proc_get_drv_version(char *page, char **start,
 #else
 int proc_get_drv_version(struct seq_file *m, void* data)
 {
-	struct net_device *dev = data;
-	
-	return seq_printf(m, "%s\n", DRIVERVERSION); 
+	seq_printf(m, "%s\n", DRIVERVERSION);
+	return 0;
 }
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) 
 int proc_get_write_reg(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -92,7 +92,14 @@ int proc_get_write_reg(char *page, char **start,
 	*eof = 1;
 	return 0;
 }
+#else
+int proc_get_write_reg(struct seq_file *m, void* data)
+{
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) 
 int proc_set_write_reg(struct file *file, const char *buffer,
 		unsigned long count, void *data)
 {
@@ -137,10 +144,59 @@ int proc_set_write_reg(struct file *file, const char *buffer,
 	return count;
 	
 }
+#else
+int proc_set_write_reg_open(struct seq_file *m, void* data)
+{
+	return 0;
+}
+
+ssize_t proc_set_write_reg(struct file *file, const char *buffer, size_t count, loff_t *pos)
+{
+	struct net_device *dev = (struct net_device *)pos;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 addr, val, len;
+
+	if (count < 3)
+	{
+		DBG_8192C("argument size is less than 3\n");
+		return -EFAULT;
+	}	
+	len = min(count, sizeof(tmp)-1);
+	if (buffer && !copy_from_user(tmp, buffer, len)) {
+		tmp[len] = '\0';
+		
+		if(sscanf(tmp, "%x %x %x", &addr, &val, &len)!=3) {
+			DBG_8192C("invalid write_reg parameter!\n");
+			return -EFAULT;
+		}
+
+		switch(len)
+		{
+			case 1:
+				rtw_write8(padapter, addr, (u8)val);				
+				break;
+			case 2:
+				rtw_write16(padapter, addr, (u16)val);				
+				break;
+			case 4:
+				rtw_write32(padapter, addr, val);				
+				break;
+			default:
+				DBG_8192C("error write length=%d", len);
+				break;
+		}			
+		
+	}
+	
+	return count;
+}
+#endif
 
 static u32 proc_get_read_addr=0xeeeeeeee;
 static u32 proc_get_read_len=0x4;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) 
 int proc_get_read_reg(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -208,7 +264,77 @@ int proc_set_read_reg(struct file *file, const char *buffer,
 	return count;
 
 }
+#else
+int proc_get_read_reg(struct seq_file *m, void* data)
+{	
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+
+	if(proc_get_read_addr==0xeeeeeeee)
+	{
+		return 0;
+	}
+
+	switch(proc_get_read_len)
+	{
+		case 1:			
+			seq_printf(m, "rtw_read8(0x%x)=0x%x\n", proc_get_read_addr, rtw_read8(padapter, proc_get_read_addr));
+			break;
+		case 2:
+			seq_printf(m, "rtw_read16(0x%x)=0x%x\n", proc_get_read_addr, rtw_read16(padapter, proc_get_read_addr));
+			break;
+		case 4:
+			seq_printf(m, "rtw_read32(0x%x)=0x%x\n", proc_get_read_addr, rtw_read32(padapter, proc_get_read_addr));
+			break;
+		default:
+			seq_printf(m, "error read length=%d\n", proc_get_read_len);
+			break;
+	}
+	return 0;
+}
+
+ssize_t proc_set_read_reg(struct file *file, const char *buf,
+		size_t count, loff_t *pos)
+{
+	struct net_device *dev = (struct net_device *)pos;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	
+	char *cmd, *buffer;
+	
+	u32 addr, len, num;
+
+	if (count < 2)
+	{
+		DBG_8192C("argument size is less than 2\n");
+		return -EFAULT;
+	}	
+	cmd = kmalloc(count+1, GFP_KERNEL);
+	if(!cmd)
+	    return -ENOMEM;
+	if(!copy_from_user(cmd, buf, count)) {
+
+		cmd[count]='\0';
+		buffer = cmd;
+		
+		num = sscanf(buffer, "%x %x", &addr, &len);
+
+		if (num !=  2) {
+			DBG_8192C("invalid read_reg parameter!\n");
+			return count;
+		}
+
+		proc_get_read_addr = addr;
+		proc_get_read_len = len;
+	}else{
+	    kfree(cmd);
+	    return -EFAULT;
+	}
+	kfree(cmd);
+	return count;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_fwstate(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -224,7 +350,18 @@ int proc_get_fwstate(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_fwstate(struct seq_file *m, void* data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	seq_printf(m, "fwstate=0x%x\n",get_fwstate(pmlmepriv));
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_sec_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -242,7 +379,20 @@ int proc_get_sec_info(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_sec_info(struct seq_file *m, void* data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct security_priv *psecuritypriv = &padapter->securitypriv;
+	seq_printf(m, "auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n", 
+						psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+						psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_mlmext_state(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -259,7 +409,19 @@ int proc_get_mlmext_state(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_mlmext_state(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	seq_printf(m, "pmlmeinfo->state=0x%x\n", pmlmeinfo->state);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_qos_option(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -276,7 +438,18 @@ int proc_get_qos_option(char *page, char **start,
 	return len;
 
 }
+#else
+int proc_get_qos_option(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	seq_printf(m, "qos_option=%d\n", pmlmepriv->qospriv.qos_option);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_ht_option(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -292,7 +465,18 @@ int proc_get_ht_option(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_ht_option(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	seq_printf(m, "ht_option=%d\n", pmlmepriv->htpriv.ht_option);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_rf_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -310,7 +494,19 @@ int proc_get_rf_info(char *page, char **start,
 	return len;
 
 }
+#else
+int proc_get_rf_info(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);	
+	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;	
+	seq_printf(m, "cur_ch=%d, cur_bw=%d, cur_ch_offet=%d\n",
+			pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
+	return 0;
+}
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_ap_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -359,7 +555,53 @@ int proc_get_ap_info(char *page, char **start,
 	return len;
 
 }
+#else
+int proc_get_ap_info(struct seq_file *m, void *data)
+{
+	struct sta_info *psta;
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	struct wlan_network *cur_network = &(pmlmepriv->cur_network);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	int len = 0;
 
+	psta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
+	if(psta)
+	{
+		int i;
+		struct recv_reorder_ctrl *preorder_ctrl;
+					
+		seq_printf(m, "SSID=%s\n", cur_network->network.Ssid.Ssid);		
+		seq_printf(m, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
+		seq_printf(m, "cur_channel=%d, cur_bwmode=%d, cur_ch_offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);		
+		seq_printf(m, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+		seq_printf(m, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+		seq_printf(m, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+		seq_printf(m, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+		seq_printf(m, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);	
+		seq_printf(m, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+					
+		for(i=0;i<16;i++)
+		{							
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			if(preorder_ctrl->enable)
+			{
+				seq_printf(m, "tid=%d, indicate_seq=%d\n", i, preorder_ctrl->indicate_seq);
+			}
+		}	
+		
+	}
+	else
+	{
+		seq_printf(m, "can't get sta's macaddr, cur_network's macaddr:" MAC_FMT "\n", MAC_ARG(cur_network->network.MacAddress));
+	}
+	return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_adapter_state(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -375,7 +617,18 @@ int proc_get_adapter_state(char *page, char **start,
 	return len;
 
 }
-	
+#else
+int proc_get_adapter_state(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	seq_printf(m, "bSurpriseRemoved=%d, bDriverStopped=%d\n", 
+			padapter->bSurpriseRemoved, padapter->bDriverStopped);
+	return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_trx_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -396,8 +649,23 @@ int proc_get_trx_info(char *page, char **start,
 	return len;
 
 }
-	
-		
+#else
+int proc_get_trx_info(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct xmit_priv *pxmitpriv = &padapter->xmitpriv;
+	struct recv_priv  *precvpriv = &padapter->recvpriv;
+	seq_printf(m, "free_xmitbuf_cnt=%d, free_xmitframe_cnt=%d, free_ext_xmitbuf_cnt=%d, free_recvframe_cnt=%d\n", 
+		pxmitpriv->free_xmitbuf_cnt, pxmitpriv->free_xmitframe_cnt,pxmitpriv->free_xmit_extbuf_cnt, precvpriv->free_recvframe_cnt);
+#ifdef CONFIG_USB_HCI
+	seq_printf(m, "rx_urb_pending_cn=%d\n", precvpriv->rx_pending_cnt);
+#endif
+	return 0;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_rx_signal(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -426,7 +694,7 @@ int proc_get_rx_signal(char *page, char **start,
 }
 
 int proc_set_rx_signal(struct file *file, const char *buffer,
-		unsigned long count, void *data)
+		unsigned long count, void *data)
 {
 	struct net_device *dev = (struct net_device *)data;
 	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
@@ -461,7 +729,62 @@ int proc_set_rx_signal(struct file *file, const char *buffer,
 	return count;
 	
 }
+#else
+int proc_get_rx_signal(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
+	seq_printf(m,
+		"rssi:%d\n"
+		"rxpwdb:%d\n"
+		"signal_strength:%u\n"
+		"signal_qual:%u\n"
+		"noise:%u\n", 
+		padapter->recvpriv.rssi,
+		padapter->recvpriv.rxpwdb,
+		padapter->recvpriv.signal_strength,
+		padapter->recvpriv.signal_qual,
+		padapter->recvpriv.noise
+		);
+	return 0;
+}
+
+ssize_t proc_set_rx_signal(struct file *file, const char *buffer, size_t count, loff_t *pos)
+{
+	struct net_device *dev = (struct net_device *)pos;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 is_signal_dbg, signal_strength;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {
+
+		int num = sscanf(tmp, "%u %u", &is_signal_dbg, &signal_strength);
+
+		is_signal_dbg = is_signal_dbg==0?0:1;
+		
+		if(is_signal_dbg && num!=2)
+			return count;
+			
+		signal_strength = signal_strength>100?100:signal_strength;
+		signal_strength = signal_strength<0?0:signal_strength;
+
+		padapter->recvpriv.is_signal_dbg = is_signal_dbg;
+		padapter->recvpriv.signal_strength_dbg=signal_strength;
 
+		if(is_signal_dbg)
+			DBG_871X("set %s %u\n", "DBG_SIGNAL_STRENGTH", signal_strength);
+		else
+			DBG_871X("set %s\n", "HW_SIGNAL_STRENGTH");
+	}
+	return count;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_ampdu_enable(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -508,7 +831,46 @@ int proc_set_ampdu_enable(struct file *file, const char *buffer,
 	return count;
 	
 }
+#else
+int proc_get_ampdu_enable(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+	if(pregpriv)
+		seq_printf(m,
+			"%d\n",
+			pregpriv->ampdu_enable
+			);
+	return 0;
+}
 
+ssize_t proc_set_ampdu_enable(struct file *file, const char *buffer, size_t count, loff_t *pos)
+{
+	struct net_device *dev = (struct net_device *)pos;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct registry_priv	*pregpriv = &padapter->registrypriv;
+	char tmp[32];
+	u32 mode;
+
+	if (count < 1)
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+
+		int num = sscanf(tmp, "%d ", &mode);
+
+		if( pregpriv && mode >= 0 && mode < 3 )
+		{
+			pregpriv->ampdu_enable= mode;
+			printk("ampdu_enable=%d\n", mode);
+		}
+	}
+	return count;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_rssi_disp(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -556,10 +918,52 @@ int proc_set_rssi_disp(struct file *file, const char *buffer,
 	return count;
 	
 }	
+#else
+int proc_get_rssi_disp(struct seq_file *m, void *data)
+{
+	return 0;
+}
 
+ssize_t proc_set_rssi_disp(struct file *file, const char *buffer, size_t count, loff_t *pos)
+{
+	struct net_device *dev = (struct net_device *)pos;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	char tmp[32];
+	u32 enable=0;
+
+	if (count < 1)
+	{
+		DBG_8192C("argument size is less than 1\n");
+		return -EFAULT;
+	}	
+
+	if (buffer && !copy_from_user(tmp, buffer, sizeof(tmp))) {		
+
+		int num = sscanf(tmp, "%x", &enable);
+
+		if (num !=  1) {
+			DBG_8192C("invalid set_rssi_disp parameter!\n");
+			return count;
+		}
 		
+		if(enable)
+		{			
+			DBG_8192C("Turn On Rx RSSI Display Function\n");
+			padapter->bRxRSSIDisplay = enable ;			
+		}
+		else
+		{
+			DBG_8192C("Turn Off Rx RSSI Display Function\n");
+			padapter->bRxRSSIDisplay = 0 ;
+		}
+	}
+	return count;
+}
+#endif
+
 #ifdef CONFIG_AP_MODE
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_all_sta_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -629,14 +1033,74 @@ int proc_get_all_sta_info(char *page, char **start,
 	return len;
 
 }
-	
-#endif		
+#else
+int proc_get_all_sta_info(struct seq_file *m, void *data)
+{
+	_irqL irqL;
+	struct sta_info *psta;
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct sta_priv *pstapriv = &padapter->stapriv;
+	int i, j;
+	_list	*plist, *phead;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	seq_printf(m, "sta_dz_bitmap=0x%x, tim_bitmap=0x%x\n", pstapriv->sta_dz_bitmap, pstapriv->tim_bitmap);
+					
+	_enter_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+
+	for(i=0; i< NUM_STA; i++)
+	{
+		phead = &(pstapriv->sta_hash[i]);
+		plist = get_next(phead);
+		
+		while ((rtw_end_of_queue_search(phead, plist)) == _FALSE)
+		{
+			psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
+
+			plist = get_next(plist);
+
+			//if(extra_arg == psta->aid)
+			{
+				seq_printf(m, "sta's macaddr:" MAC_FMT "\n", MAC_ARG(psta->hwaddr));
+				seq_printf(m, "rtsen=%d, cts2slef=%d\n", psta->rtsen, psta->cts2self);
+				seq_printf(m, "qos_en=%d, ht_en=%d, init_rate=%d\n", psta->qos_option, psta->htpriv.ht_option, psta->init_rate);	
+				seq_printf(m, "state=0x%x, aid=%d, macid=%d, raid=%d\n", psta->state, psta->aid, psta->mac_id, psta->raid);	
+				seq_printf(m, "bwmode=%d, ch_offset=%d, sgi=%d\n", psta->htpriv.bwmode, psta->htpriv.ch_offset, psta->htpriv.sgi);						
+				seq_printf(m, "ampdu_enable = %d\n", psta->htpriv.ampdu_enable);									
+				seq_printf(m, "agg_enable_bitmap=%x, candidate_tid_bitmap=%x\n", psta->htpriv.agg_enable_bitmap, psta->htpriv.candidate_tid_bitmap);
+				seq_printf(m, "sleepq_len=%d\n", psta->sleepq_len);
+				seq_printf(m, "capability=0x%x\n", psta->capability);
+				seq_printf(m, "flags=0x%x\n", psta->flags);
+				seq_printf(m, "wpa_psk=0x%x\n", psta->wpa_psk);
+				seq_printf(m, "wpa2_group_cipher=0x%x\n", psta->wpa2_group_cipher);
+				seq_printf(m, "wpa2_pairwise_cipher=0x%x\n", psta->wpa2_pairwise_cipher);
+				seq_printf(m, "qos_info=0x%x\n", psta->qos_info);
+				seq_printf(m, "dot118021XPrivacy=0x%x\n", psta->dot118021XPrivacy);
+								
+				for(j=0;j<16;j++)
+				{							
+					preorder_ctrl = &psta->recvreorder_ctrl[j];
+					if(preorder_ctrl->enable)
+					{
+						seq_printf(m, "tid=%d, indicate_seq=%d\n", j, preorder_ctrl->indicate_seq);
+					}
+				}
+			}
+		}
+	}
+	_exit_critical_bh(&pstapriv->sta_hash_lock, &irqL);
+	return 0;
+}
+#endif
+
+#endif
 
 #ifdef DBG_MEMORY_LEAK
 #include <asm/atomic.h>
 extern atomic_t _malloc_cnt;;
 extern atomic_t _malloc_size;;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_malloc_cnt(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -650,9 +1114,20 @@ int proc_get_malloc_cnt(char *page, char **start,
 	*eof = 1;
 	return len;
 }
+#else
+int proc_get_malloc_cnt(struct seq_file *m, void *data)
+{
+	seq_printf(m, "_malloc_cnt=%d\n", atomic_read(&_malloc_cnt));
+	seq_printf(m, "_malloc_size=%d\n", atomic_read(&_malloc_size));
+	return 0;
+}
+#endif
+
 #endif /* DBG_MEMORY_LEAK */
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 int proc_get_best_channel(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data)
@@ -712,6 +1187,61 @@ int proc_get_best_channel(char *page, char **start,
 	return len;
 
 }
+#else
+int proc_get_best_channel(struct seq_file *m, void *data)
+{
+	struct net_device *dev = m->private;
+	_adapter *padapter = (_adapter *)rtw_netdev_priv(dev);
+	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
+	u32 i, best_channel_24G = 1, best_channel_5G = 36, index_24G = 0, index_5G = 0;
+
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		if ( pmlmeext->channel_set[i].ChannelNum == 1)
+			index_24G = i;
+		if ( pmlmeext->channel_set[i].ChannelNum == 36)
+			index_5G = i;
+	}	
+	
+	for (i=0; pmlmeext->channel_set[i].ChannelNum !=0; i++) {
+		// 2.4G
+		if ( pmlmeext->channel_set[i].ChannelNum == 6 ) {
+			if ( pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_24G].rx_count ) {
+				index_24G = i;
+				best_channel_24G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		// 5G
+		if ( pmlmeext->channel_set[i].ChannelNum >= 36
+			&& pmlmeext->channel_set[i].ChannelNum < 140 ) {
+			 // Find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 36) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+
+		if ( pmlmeext->channel_set[i].ChannelNum >= 149
+			&& pmlmeext->channel_set[i].ChannelNum < 165) {
+			 // find primary channel
+			if ( (( pmlmeext->channel_set[i].ChannelNum - 149) % 8 == 0)
+				&& (pmlmeext->channel_set[i].rx_count < pmlmeext->channel_set[index_5G].rx_count) ) {
+				index_5G = i;
+				best_channel_5G = pmlmeext->channel_set[i].ChannelNum;
+			}
+		}
+#if 1 // debug
+		seq_printf(m, "The rx cnt of channel %3d = %d\n", 
+				pmlmeext->channel_set[i].ChannelNum, pmlmeext->channel_set[i].rx_count);
+#endif
+	}
+	seq_printf(m, "best_channel_5G = %d\n", best_channel_5G);
+	seq_printf(m, "best_channel_24G = %d\n", best_channel_24G);
+	return 0;
+}
+#endif
+
 #endif /* CONFIG_FIND_BEST_CHANNEL */
 	
 #endif
diff --git a/include/rtw_debug.h b/include/rtw_debug.h
index 5b3e5cc..624add6 100644
--- a/include/rtw_debug.h
+++ b/include/rtw_debug.h
@@ -24,7 +24,6 @@
 #include <osdep_service.h>
 #include <drv_types.h>
 
-
 #define _drv_emerg_			1
 #define _drv_alert_			2
 #define _drv_crit_			3
@@ -35,7 +34,6 @@
 #define _drv_dump_			8
 #define	_drv_debug_		9
 
-
 #define 	_module_rtl871x_xmit_c_ 		BIT(0)
 #define 	_module_xmit_osdep_c_ 		BIT(1)
 #define 	_module_rtl871x_recv_c_ 		BIT(2)
@@ -179,7 +177,6 @@
 
 #endif /* CONFIG_DEBUG_RTL871X */
 
-
 #if	defined (_dbgdump) && defined (_MODULE_DEFINE_)
 
 		#undef RT_TRACE
@@ -193,7 +190,6 @@
 
 #endif
 
-
 #if	defined (_dbgdump)
 
 		#undef  _func_enter_
@@ -231,7 +227,6 @@
 			}
 #endif
 
-
 #ifdef CONFIG_DEBUG_RTL819X
 	#ifdef PLATFORM_WINDOWS
 
@@ -281,23 +276,19 @@
 	#define ERR_8192C _dbgdump
 #endif
 
-
-
 #ifdef CONFIG_PROC_DEBUG
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	int proc_get_drv_version(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
-#else
-	int proc_get_drv_version(struct seq_file *m, void *data);
-#endif
+
 	int proc_get_write_reg(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
 
- 	int proc_set_write_reg(struct file *file, const char *buffer,
-		unsigned long count, void *data);
+	int proc_set_write_reg(struct file *file, const char *buffer,
+			  unsigned long count, void *data);
 
 	int proc_get_read_reg(char *page, char **start,
 			  off_t offset, int count,
@@ -306,7 +297,6 @@
 	int proc_set_read_reg(struct file *file, const char *buffer,
 		unsigned long count, void *data);
 
-
 	int proc_get_fwstate(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
@@ -342,28 +332,75 @@
 	int proc_get_trx_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
+#else
+	int proc_get_drv_version(struct seq_file *m, void *data);
+
+	int proc_get_write_reg(struct seq_file *m, void *data);
+
+ 	ssize_t proc_set_write_reg(struct file *file, const char *buffer,
+			 size_t count, loff_t *pos);
+
+	int proc_get_read_reg(struct seq_file *m, void *data);
+
+	ssize_t proc_set_read_reg(struct file *file, const char *buffer,
+			 size_t count, loff_t *pos);
+
+	int proc_get_fwstate(struct seq_file *m, void *data);
 
+	int proc_get_sec_info(struct seq_file *m, void *data);
+
+	int proc_get_mlmext_state(struct seq_file *m, void *data);
+
+	int proc_get_qos_option(struct seq_file *m, void *data);
+
+	int proc_get_ht_option(struct seq_file *m, void *data);
+
+	int proc_get_rf_info(struct seq_file *m, void *data);
+
+	int proc_get_ap_info(struct seq_file *m, void *data);
+
+	int proc_get_adapter_state(struct seq_file *m, void *data);
+
+	int proc_get_trx_info(struct seq_file *m, void *data);
+#endif
 
 #ifdef CONFIG_AP_MODE
 
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	int proc_get_all_sta_info(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
+# else
+	int proc_get_all_sta_info(struct seq_file *m, void *data);
+# endif
 
 #endif
 
 #ifdef DBG_MEMORY_LEAK
+
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	int proc_get_malloc_cnt(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
+# else
+	int proc_get_malloc_cnt(struct seq_file *m, void *data);
+# endif
+
 #endif
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
+
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	int proc_get_best_channel(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
+# else
+	int proc_get_best_channel(struct seq_file *m, void *data);
+# endif
+
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	int proc_get_rx_signal(char *page, char **start,
 			  off_t offset, int count,
 			  int *eof, void *data);
@@ -384,7 +421,22 @@
 
 	int proc_set_rssi_disp(struct file *file, const char *buffer,
 		unsigned long count, void *data);
-	
+#else
+	int proc_get_rx_signal(struct seq_file *m, void *data);
+
+	ssize_t proc_set_rx_signal(struct file *file, const char *buffer,
+				size_t count, loff_t *pos);
+
+	int proc_get_ampdu_enable(struct seq_file *m, void *data);
+			  
+	ssize_t proc_set_ampdu_enable(struct file *file, const char *buffer,
+				size_t count, loff_t *pos);
+
+	int proc_get_rssi_disp(struct seq_file *m, void *data);
+
+	ssize_t proc_set_rssi_disp(struct file *file, const char *buffer,
+				size_t count, loff_t *pos);
+#endif
 
 #endif //CONFIG_PROC_DEBUG
 
diff --git a/os_dep/linux/os_intfs.c b/os_dep/linux/os_intfs.c
index 0e61bf9..05f0b59 100644
--- a/os_dep/linux/os_intfs.c
+++ b/os_dep/linux/os_intfs.c
@@ -255,16 +255,244 @@
 static struct proc_dir_entry *rtw_proc = NULL;
 static int	rtw_proc_cnt = 0;
 
+/*
+ * seq_file wrappers for procfile show routines, kernel >= 3.10
+ */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
-static int drv_version_proc_open(struct inode *inode, struct file *file){
-        return single_open(file, proc_get_drv_version, NULL);
+
+static int proc_get_drv_version_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_drv_version, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_drv_version_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_drv_version_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_write_reg_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_write_reg, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_write_reg_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_write_reg_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.write = proc_set_write_reg,
+	.release = seq_release,
+};
+
+static int proc_get_read_reg_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_read_reg, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_read_reg_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_read_reg_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.write = proc_set_read_reg,
+	.release = seq_release,
+};
+
+static int proc_get_rssi_disp_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_rssi_disp, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_rssi_disp_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_rssi_disp_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.write = proc_set_rssi_disp,
+	.release = seq_release,
+};
+
+static int proc_get_ampdu_enable_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_ampdu_enable, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_ampdu_enable_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_ampdu_enable_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.write = proc_set_ampdu_enable,
+	.release = seq_release,
+};
+
+static int proc_get_rx_signal_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_rx_signal, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_rx_signal_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_rx_signal_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.write = proc_set_rx_signal,
+	.release = seq_release,
+};
+
+static int proc_get_fwstate_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_fwstate, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_fwstate_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_fwstate_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_mlmext_state_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_mlmext_state, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_mlmext_state_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_mlmext_state_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_qos_option_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_qos_option, PDE_DATA(inode));
 }
 
-static const struct file_operations drv_version_fops = {
-        .open = drv_version_proc_open,
+static const struct file_operations proc_get_qos_option_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_qos_option_open,
         .read = seq_read,
         .llseek = seq_lseek,
+	.release = single_release,
 };
+
+static int proc_get_ht_option_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_ht_option, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_ht_option_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_ht_option_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_rf_info_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_rf_info, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_rf_info_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_rf_info_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_ap_info_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_ap_info, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_ap_info_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_ap_info_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_adapter_state_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_adapter_state, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_adapter_state_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_adapter_state_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_trx_info_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_trx_info, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_trx_info_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_trx_info_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+static int proc_get_sec_info_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_sec_info, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_sec_info_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_sec_info_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+# ifdef CONFIG_AP_MODE
+
+static int proc_get_all_sta_info_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_all_sta_info, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_all_sta_info_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_all_sta_info_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+# endif
+
+# ifdef DBG_MEMORY_LEAK
+
+static int proc_get_malloc_cnt_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_malloc_cnt, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_malloc_cnt_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_malloc_cnt_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+# endif
+
+# ifdef CONFIG_FIND_BEST_CHANNEL
+
+static int proc_get_best_channel_open(struct inode *inode, struct file *file){
+        return single_open(file, proc_get_best_channel, PDE_DATA(inode));
+}
+
+static const struct file_operations proc_get_best_channel_fops = {
+        .owner = THIS_MODULE,
+	.open = proc_get_best_channel_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+	.release = single_release,
+};
+
+# endif
+
 #endif
 
 void rtw_proc_init_one(struct net_device *dev)
@@ -287,11 +515,11 @@ void rtw_proc_init_one(struct net_device *dev)
 #if(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24))
 		rtw_proc=create_proc_entry(rtw_proc_name, S_IFDIR, proc_net);
 #else
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 		rtw_proc=create_proc_entry(rtw_proc_name, S_IFDIR, init_net.proc_net);
-#else
+# else
 		rtw_proc=proc_mkdir(rtw_proc_name, init_net.proc_net);
-#endif
+# endif
 #endif
 		if (rtw_proc == NULL) {
 			DBG_8192C(KERN_ERR "Unable to create rtw_proc directory\n");
@@ -301,7 +529,7 @@ void rtw_proc_init_one(struct net_device *dev)
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 		entry = create_proc_read_entry("ver_info", S_IFREG | S_IRUGO, rtw_proc, proc_get_drv_version, dev);				   
 #else
-		entry = proc_create_data("ver_info", S_IFREG | S_IRUGO, rtw_proc, &drv_version_fops, dev);				   
+		entry = proc_create_data("ver_info", S_IFREG | S_IRUGO, rtw_proc, &proc_get_drv_version_fops, dev);				   
 #endif
 		if (!entry) {
 			DBG_871X("Unable to create_proc_read_entry!\n"); 
@@ -309,8 +537,6 @@ void rtw_proc_init_one(struct net_device *dev)
 		}
 	}
 
-	
-
 	if(padapter->dir_dev == NULL)
 	{
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
@@ -352,7 +578,7 @@ void rtw_proc_init_one(struct net_device *dev)
 				   dir_dev, proc_get_write_reg, dev);				   
 #else
 	entry = proc_create_data("write_reg", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_write_reg, dev);				   
+				   dir_dev, &proc_get_write_reg_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
@@ -365,7 +591,7 @@ void rtw_proc_init_one(struct net_device *dev)
 				   dir_dev, proc_get_read_reg, dev);				   
 #else
 	entry = proc_create_data("read_reg", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_read_reg, dev);				   
+				   dir_dev, &proc_get_read_reg_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
@@ -378,104 +604,95 @@ void rtw_proc_init_one(struct net_device *dev)
 				   dir_dev, proc_get_fwstate, dev);				   
 #else
 	entry = proc_create_data("fwstate", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_fwstate, dev);				   
+				   dir_dev, &proc_get_fwstate_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("sec_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_sec_info, dev);				   
 #else
 	entry = proc_create_data("sec_info", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_sec_info, dev);				   
+				   dir_dev, &proc_get_sec_info_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("mlmext_state", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_mlmext_state, dev);				   
 #else
 	entry = proc_create_data("mlmext_state", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_mlmext_state, dev);				   
+				   dir_dev, &proc_get_mlmext_state_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("qos_option", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_qos_option, dev);				   
 #else
 	entry = proc_create_data("qos_option", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_qos_option, dev);				   
+				   dir_dev, &proc_get_qos_option_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("ht_option", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_ht_option, dev);				   
 #else
 	entry = proc_create_data("ht_option", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_ht_option, dev);				   
+				   dir_dev, &proc_get_ht_option_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("rf_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_rf_info, dev);				   
 #else
 	entry = proc_create_data("rf_info", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_rf_info, dev);				   
+				   dir_dev, &proc_get_rf_info_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-	
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("ap_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_ap_info, dev);				   
 #else
 	entry = proc_create_data("ap_info", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_ap_info, dev);				   
+				   dir_dev, &proc_get_ap_info_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("adapter_state", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_adapter_state, dev);				   
 #else
 	entry = proc_create_data("adapter_state", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_adapter_state, dev);				   
+				   dir_dev, &proc_get_adapter_state_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("trx_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_trx_info, dev);				   
 #else
 	entry = proc_create_data("trx_info", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_trx_info, dev);				   
+				   dir_dev, &proc_get_trx_info_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
@@ -484,45 +701,50 @@ void rtw_proc_init_one(struct net_device *dev)
 
 #ifdef CONFIG_AP_MODE
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("all_sta_info", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_all_sta_info, dev);				   
-#else
+# else
 	entry = proc_create_data("all_sta_info", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_all_sta_info, dev);				   
-#endif
+				   dir_dev, &proc_get_all_sta_info_fops, dev);				   
+# endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+
 #endif
 
 #ifdef DBG_MEMORY_LEAK
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("_malloc_cnt", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_malloc_cnt, dev);				   
-#else
+# else
 	entry = proc_create_data("_malloc_cnt", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_malloc_cnt, dev);				   
-#endif
+				   dir_dev, &proc_get_malloc_cnt_fops, dev);				   
+# endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+
 #endif
 
 #ifdef CONFIG_FIND_BEST_CHANNEL
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+
+# if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
 	entry = create_proc_read_entry("best_channel", S_IFREG | S_IRUGO,
 				   dir_dev, proc_get_best_channel, dev);				   
-#else
+# else
 	entry = proc_create_data("best_channel", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_best_channel, dev);				   
-#endif
+				   dir_dev, &proc_get_best_channel_fops, dev);				   
+# endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 		return;
 	}
+
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
@@ -530,7 +752,7 @@ void rtw_proc_init_one(struct net_device *dev)
 				   dir_dev, proc_get_rx_signal, dev);				   
 #else
 	entry = proc_create_data("rx_signal", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_rx_signal, dev);				   
+				   dir_dev, &proc_get_rx_signal_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
@@ -543,7 +765,7 @@ void rtw_proc_init_one(struct net_device *dev)
 				   dir_dev, proc_get_ampdu_enable, dev);				   
 #else
 	entry = proc_create_data("ampdu_enable", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_ampdu_enable, dev);				   
+				   dir_dev, &proc_get_ampdu_enable_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
@@ -557,7 +779,7 @@ void rtw_proc_init_one(struct net_device *dev)
 				   dir_dev, proc_get_rssi_disp, dev);				   
 #else
 	entry = proc_create_data("rssi_disp", S_IFREG | S_IRUGO,
-				   dir_dev, proc_get_rssi_disp, dev);				   
+				   dir_dev, &proc_get_rssi_disp_fops, dev);				   
 #endif
 	if (!entry) {
 		DBG_871X("Unable to create_proc_read_entry!\n"); 
 
-- 
1.8.1.6

