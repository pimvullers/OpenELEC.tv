From 4e76bac89d9272bc4a4d75d23082ebeb3eea0fa2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 24 May 2014 15:02:08 +0200
Subject: [PATCH 01/37] AE: accept planar formats and timestamps at input

---
 .../AudioEngine/Engines/ActiveAE/ActiveAE.cpp      | 34 +++++++++---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h |  5 +-
 .../Engines/ActiveAE/ActiveAEBuffer.cpp            | 27 ++++++++--
 .../AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h  |  6 ++-
 .../AudioEngine/Engines/ActiveAE/ActiveAESink.cpp  | 17 ++++--
 .../AudioEngine/Engines/ActiveAE/ActiveAESink.h    |  1 +
 .../Engines/ActiveAE/ActiveAEStream.cpp            | 60 ++++++++++------------
 .../AudioEngine/Engines/ActiveAE/ActiveAEStream.h  |  3 +-
 xbmc/cores/AudioEngine/Interfaces/AEStream.h       | 18 +++++--
 9 files changed, 116 insertions(+), 55 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index fa8bc55..acca48a 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -42,13 +42,15 @@ void CEngineStats::Reset(unsigned int sampleRate)
   m_sinkSampleRate = sampleRate;
   m_bufferedSamples = 0;
   m_suspended = false;
+  m_playingPTS = 0;
 }
 
-void CEngineStats::UpdateSinkDelay(double delay, int samples)
+void CEngineStats::UpdateSinkDelay(double delay, int samples, int64_t pts)
 {
   CSingleLock lock(m_lock);
   m_sinkUpdate = XbmcThreads::SystemClockMillis();
   m_sinkDelay = delay;
+  m_playingPTS = pts;
   if (samples > m_bufferedSamples)
   {
     CLog::Log(LOGERROR, "CEngineStats::UpdateSinkDelay - inconsistency in buffer time");
@@ -120,6 +122,21 @@ float CEngineStats::GetCacheTotal(CActiveAEStream *stream)
   return MAX_CACHE_LEVEL + m_sinkCacheTotal;
 }
 
+int64_t CEngineStats::GetPlayingPTS()
+{
+  CSingleLock lock(m_lock);
+  unsigned int now = XbmcThreads::SystemClockMillis();
+  if (m_playingPTS == 0)
+    return 0;
+
+  int64_t pts = m_playingPTS + (now-m_sinkUpdate);
+
+  if (pts < 0)
+    return 0;
+
+  return pts;
+}
+
 float CEngineStats::GetWaterLevel()
 {
   CSingleLock lock(m_lock);
@@ -1071,7 +1088,7 @@ void CActiveAE::Configure(AEAudioFormat *desiredFmt)
     else
     {
       outputFormat = m_sinkFormat;
-      outputFormat.m_dataFormat = AE_FMT_FLOAT;
+      outputFormat.m_dataFormat = AE_IS_PLANAR(outputFormat.m_dataFormat) ? AE_FMT_FLOATP : AE_FMT_FLOAT;
       outputFormat.m_frameSize = outputFormat.m_channelLayout.Count() *
                                  (CAEUtil::DataFormatToBits(outputFormat.m_dataFormat) >> 3);
 
@@ -1415,7 +1432,7 @@ void CActiveAE::ApplySettingsToFormat(AEAudioFormat &format, AudioSettings &sett
   }
   else
   {
-    format.m_dataFormat = AE_FMT_FLOAT;
+    format.m_dataFormat = AE_IS_PLANAR(format.m_dataFormat) ? AE_FMT_FLOATP : AE_FMT_FLOAT;
     // consider user channel layout for those cases
     // 1. input stream is multichannel
     // 2. stereo upmix is selected
@@ -1909,13 +1926,13 @@ bool CActiveAE::RunStages()
             }
             else
               CLog::Log(LOGWARNING,"ActiveAE::%s - viz ran out of free buffers", __FUNCTION__);
-            unsigned int now = XbmcThreads::SystemClockMillis();
-            unsigned int timestamp = now + m_stats.GetDelay() * 1000;
+            double now = (double)XbmcThreads::SystemClockMillis();
+            double timestamp = now + m_stats.GetDelay() * 1000;
             busy |= m_vizBuffers->ResampleBuffers(timestamp);
             while(!m_vizBuffers->m_outputSamples.empty())
             {
               CSampleBuffer *buf = m_vizBuffers->m_outputSamples.front();
-              if ((now - buf->timestamp) & 0x80000000)
+              if ((now - buf->timestamp) < 0)
                 break;
               else
               {
@@ -1942,6 +1959,11 @@ bool CActiveAE::RunStages()
           m_encoder->Encode(out->pkt->data[0], out->pkt->planes*out->pkt->linesize,
                             buf->pkt->data[0], buf->pkt->planes*buf->pkt->linesize);
           buf->pkt->nb_samples = buf->pkt->max_nb_samples;
+
+          // set pts of last sample
+          buf->pkt_start_offset = buf->pkt->nb_samples;
+          buf->timestamp = out->timestamp;
+
           out->Return();
           out = buf;
         }
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
index 700098b..467f18e 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
@@ -160,13 +160,14 @@ class CEngineStats
 {
 public:
   void Reset(unsigned int sampleRate);
-  void UpdateSinkDelay(double delay, int samples);
+  void UpdateSinkDelay(double delay, int samples, int64_t pts);
   void AddSamples(int samples, std::list<CActiveAEStream*> &streams);
   float GetDelay();
   float GetDelay(CActiveAEStream *stream);
   float GetCacheTime(CActiveAEStream *stream);
   float GetCacheTotal(CActiveAEStream *stream);
   float GetWaterLevel();
+  int64_t GetPlayingPTS();
   void SetSuspended(bool state);
   void SetSinkCacheTotal(float time) { m_sinkCacheTotal = time; }
   void SetSinkLatency(float time) { m_sinkLatency = time; }
@@ -174,6 +175,7 @@ class CEngineStats
   CCriticalSection *GetLock() { return &m_lock; }
 protected:
   float m_sinkDelay;
+  int64_t m_playingPTS;
   float m_sinkCacheTotal;
   float m_sinkLatency;
   int m_bufferedSamples;
@@ -243,6 +245,7 @@ class CActiveAE : public IAE, private CThread
   uint8_t **AllocSoundSample(SampleConfig &config, int &samples, int &bytes_per_sample, int &planes, int &linesize);
   void FreeSoundSample(uint8_t **data);
   float GetDelay(CActiveAEStream *stream) { return m_stats.GetDelay(stream); }
+  int64_t GetPlayingPTS() { return m_stats.GetPlayingPTS(); }
   float GetCacheTime(CActiveAEStream *stream) { return m_stats.GetCacheTime(stream); }
   float GetCacheTotal(CActiveAEStream *stream) { return m_stats.GetCacheTotal(stream); }
   void FlushStream(CActiveAEStream *stream);
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
index a10753e..56045e2 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
@@ -44,6 +44,7 @@ CSoundPacket::~CSoundPacket()
 CSampleBuffer::CSampleBuffer() : pkt(NULL), pool(NULL)
 {
   refCount = 0;
+  timestamp = 0.0;
 }
 
 CSampleBuffer::~CSampleBuffer()
@@ -218,7 +219,7 @@ void CActiveAEBufferPoolResample::ChangeResampler()
   m_changeResampler = false;
 }
 
-bool CActiveAEBufferPoolResample::ResampleBuffers(unsigned int timestamp)
+bool CActiveAEBufferPoolResample::ResampleBuffers(double timestamp)
 {
   bool busy = false;
   CSampleBuffer *in;
@@ -234,7 +235,8 @@ bool CActiveAEBufferPoolResample::ResampleBuffers(unsigned int timestamp)
     {
       in = m_inputSamples.front();
       m_inputSamples.pop_front();
-      in->timestamp = timestamp;
+      if (timestamp)
+        in->timestamp = timestamp;
       m_outputSamples.push_back(in);
       busy = true;
     }
@@ -290,6 +292,25 @@ bool CActiveAEBufferPoolResample::ResampleBuffers(unsigned int timestamp)
       busy = true;
       m_empty = (out_samples == 0);
 
+      if (in)
+      {
+        if (!timestamp)
+          m_lastSamplePts = in->timestamp;
+        else
+        {
+          m_lastSamplePts = timestamp;
+          in->pkt_start_offset = 0;
+        }
+
+        // pts of last sample we added to the buffer
+        m_lastSamplePts += (in->pkt->nb_samples-in->pkt_start_offset)/m_format.m_sampleRate * 1000;
+      }
+
+      // calculate pts for last sample in m_procSample
+      int bufferedSamples = m_resampler->GetBufferedSamples();
+      m_procSample->pkt_start_offset = m_procSample->pkt->nb_samples;
+      m_procSample->timestamp = m_lastSamplePts - bufferedSamples/m_format.m_sampleRate*1000;
+
       if ((m_drain || m_changeResampler) && m_empty)
       {
         if (m_fillPackets && m_procSample->pkt->nb_samples != 0)
@@ -304,7 +325,6 @@ bool CActiveAEBufferPoolResample::ResampleBuffers(unsigned int timestamp)
             memset(m_procSample->pkt->data[i]+start, 0, m_procSample->pkt->linesize-start);
           }
         }
-        m_procSample->timestamp = timestamp;
 
         // check if draining is finished
         if (m_drain && m_procSample->pkt->nb_samples == 0)
@@ -322,7 +342,6 @@ bool CActiveAEBufferPoolResample::ResampleBuffers(unsigned int timestamp)
       // some methods like encode require completely filled packets
       else if (!m_fillPackets || (m_procSample->pkt->nb_samples == m_procSample->pkt->max_nb_samples))
       {
-        m_procSample->timestamp = timestamp;
         m_outputSamples.push_back(m_procSample);
         m_procSample = NULL;
       }
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h
index a854470..008ebdd 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h
@@ -70,7 +70,8 @@ class CSampleBuffer
   void Return();
   CSoundPacket *pkt;
   CActiveAEBufferPool *pool;
-  unsigned int timestamp;
+  int64_t timestamp;
+  int pkt_start_offset;
   int refCount;
 };
 
@@ -96,7 +97,7 @@ class CActiveAEBufferPoolResample : public CActiveAEBufferPool
   virtual ~CActiveAEBufferPoolResample();
   virtual bool Create(unsigned int totaltime, bool remap, bool upmix, bool normalize = true);
   void ChangeResampler();
-  bool ResampleBuffers(unsigned int timestamp = 0);
+  bool ResampleBuffers(double timestamp = 0);
   float GetDelay();
   void Flush();
   AEAudioFormat m_inputFormat;
@@ -113,6 +114,7 @@ class CActiveAEBufferPoolResample : public CActiveAEBufferPool
   AEQuality m_resampleQuality;
   bool m_stereoUpmix;
   bool m_normalize;
+  int64_t m_lastSamplePts;
 };
 
 }
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index c773ced..5d4c6bd 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -190,6 +190,7 @@ void CActiveAESink::StateMachine(int signal, Protocol *port, Message *msg)
             reply.hasVolume = m_sink->HasVolume();
             m_state = S_TOP_CONFIGURED_IDLE;
             m_extTimeout = 10000;
+            m_sinkLatency = (int64_t)(reply.latency * 1000);
             msg->Reply(CSinkControlProtocol::ACC, &reply, sizeof(SinkReply));
           }
           else
@@ -821,7 +822,7 @@ unsigned int CActiveAESink::OutputSamples(CSampleBuffer* samples)
       {
         m_extError = true;
         CLog::Log(LOGERROR, "CActiveAESink::OutputSamples - failed");
-        m_stats->UpdateSinkDelay(0, frames);
+        m_stats->UpdateSinkDelay(0, frames, 0.0);
         return 0;
       }
       else
@@ -831,12 +832,22 @@ unsigned int CActiveAESink::OutputSamples(CSampleBuffer* samples)
     {
       m_extError = true;
       CLog::Log(LOGERROR, "CActiveAESink::OutputSamples - sink returned error");
-      m_stats->UpdateSinkDelay(0, samples->pool ? maxFrames : 0);
+      m_stats->UpdateSinkDelay(0, samples->pool ? maxFrames : 0, 0.0);
       return 0;
     }
     frames -= written;
     sinkDelay = m_sink->GetDelay();
-    m_stats->UpdateSinkDelay(sinkDelay, samples->pool ? written : 0);
+
+    int64_t pts = 0;
+    if (samples->timestamp)
+    {
+      int pastSamples = samples->pkt->nb_samples - samples->pkt_start_offset;
+      pts = samples->timestamp - sinkDelay*1000 + pastSamples/m_sinkFormat.m_sampleRate*1000;
+      pts -= m_sinkLatency;
+      if (pts < 0)
+        pts = 0;
+    }
+    m_stats->UpdateSinkDelay(sinkDelay, samples->pool ? written : 0, pts);
   }
   return sinkDelay*1000;
 }
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
index a04cd6a..0650a70 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
@@ -142,6 +142,7 @@ class CActiveAESink : private CThread
   AEAudioFormat m_sinkFormat, m_requestedFormat;
   CEngineStats *m_stats;
   float m_volume;
+  int m_sinkLatency;
 };
 
 }
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
index eb3845f..88e4787 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
@@ -192,59 +192,47 @@ unsigned int CActiveAEStream::GetSpace()
   return m_streamFreeBuffers * m_streamSpace;
 }
 
-unsigned int CActiveAEStream::AddData(void *data, unsigned int size)
+unsigned int CActiveAEStream::AddData(uint8_t* const *data, unsigned int offset, unsigned int frames, double pts)
 {
   Message *msg;
-  unsigned int copied = 0;
-  unsigned int bytesToCopy = size;
-  uint8_t *buf = (uint8_t*)data;
+  int copied = 0;
+  int sourceFrames = frames;
+  uint8_t* const *buf = data;
 
-  while(copied < size)
+  while(copied < frames)
   {
-    buf = ((uint8_t*)data) + copied;
-    bytesToCopy = size - copied;
+    sourceFrames = frames - copied;
 
     if (m_currentBuffer)
     {
-      // fill leftover buffer and copy it first
-      if (m_leftoverBytes && bytesToCopy >= (m_format.m_frameSize - m_leftoverBytes))
-      {
-        int fillbytes = m_format.m_frameSize - m_leftoverBytes;
-        memcpy(m_leftoverBuffer+m_leftoverBytes, buf, fillbytes);
-        copied += fillbytes;
-        // leftover buffer will be copied on next cycle
-        buf = m_leftoverBuffer;
-        bytesToCopy = m_format.m_frameSize;
-        m_leftoverBytes = 0;
-      }
-
       int start = m_currentBuffer->pkt->nb_samples *
                   m_currentBuffer->pkt->bytes_per_sample *
                   m_currentBuffer->pkt->config.channels /
                   m_currentBuffer->pkt->planes;
 
-      int freeSamples = m_currentBuffer->pkt->max_nb_samples - m_currentBuffer->pkt->nb_samples;
-      int availableSamples = bytesToCopy / m_format.m_frameSize;
+      int freeSpace = m_currentBuffer->pkt->max_nb_samples - m_currentBuffer->pkt->nb_samples;
+      int minFrames = std::min(freeSpace, sourceFrames);
+      int planes = m_currentBuffer->pkt->planes;
+      int bufOffset = (offset + copied)*m_format.m_frameSize/planes;
 
-      // if we don't have a full frame, copy to leftover buffer
-      if (!availableSamples && bytesToCopy)
+      if (!copied)
       {
-        memcpy(m_leftoverBuffer+m_leftoverBytes, buf, bytesToCopy);
-        m_leftoverBytes = bytesToCopy;
-        copied += bytesToCopy;
+        m_currentBuffer->timestamp = pts;
+        m_currentBuffer->pkt_start_offset = m_currentBuffer->pkt->nb_samples;
       }
 
-      int samples = std::min(freeSamples, availableSamples);
-      int bytes = samples * m_format.m_frameSize;
+      for (int i=0; i<planes; i++)
+      {
+        memcpy(m_currentBuffer->pkt->data[i]+start, buf[i]+bufOffset, minFrames*m_format.m_frameSize/planes);
+      }
+      copied += minFrames;
 
-      memcpy(m_currentBuffer->pkt->data[0] + start, buf, bytes);
       {
         CSingleLock lock(*m_statsLock);
-        m_currentBuffer->pkt->nb_samples += samples;
-        m_bufferedTime += (double)samples / m_currentBuffer->pkt->config.sample_rate;
+        m_currentBuffer->pkt->nb_samples += minFrames;
+        m_bufferedTime += (double)minFrames / m_currentBuffer->pkt->config.sample_rate;
       }
-      if (buf != m_leftoverBuffer)
-        copied += bytes;
+
       if (m_currentBuffer->pkt->nb_samples == m_currentBuffer->pkt->max_nb_samples)
       {
         MsgStreamSample msgData;
@@ -261,6 +249,7 @@ unsigned int CActiveAEStream::AddData(void *data, unsigned int size)
       if (msg->signal == CActiveAEDataProtocol::STREAMBUFFER)
       {
         m_currentBuffer = *((CSampleBuffer**)msg->data);
+        m_currentBuffer->timestamp = 0;
         msg->Release();
         DecFreeBuffers();
         continue;
@@ -283,6 +272,11 @@ double CActiveAEStream::GetDelay()
   return AE.GetDelay(this);
 }
 
+int64_t CActiveAEStream::GetPlayingPTS()
+{
+  return AE.GetPlayingPTS();
+}
+
 bool CActiveAEStream::IsBuffering()
 {
   CSingleLock lock(m_streamLock);
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
index 77d718b..927c4d8 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
@@ -42,8 +42,9 @@ class CActiveAEStream : public IAEStream
 
 public:
   virtual unsigned int GetSpace();
-  virtual unsigned int AddData(void *data, unsigned int size);
+  virtual unsigned int AddData(uint8_t* const *data, unsigned int offset, unsigned int frames, double pts);
   virtual double GetDelay();
+  virtual int64_t GetPlayingPTS();
   virtual bool IsBuffering();
   virtual double GetCacheTime();
   virtual double GetCacheTotal();
diff --git a/xbmc/cores/AudioEngine/Interfaces/AEStream.h b/xbmc/cores/AudioEngine/Interfaces/AEStream.h
index ed5e64a..bf9b1d1 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AEStream.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AEStream.h
@@ -50,12 +50,14 @@ class IAEStream
   virtual unsigned int GetSpace() = 0;
 
   /**
-   * Add interleaved PCM data to the stream
-   * @param data The interleaved PCM data
-   * @param size The size in bytes of data, if this is > GetSpace() only up to GetSpace() bytes will be consumed
-   * @return The number of bytes consumed
+   * Add planar or interleaved PCM data to the stream
+   * @param data array of pointers to the planes
+   * @param offset to frame in frames
+   * @param frames number of frames
+   * @param pts timestamp
+   * @return The number of frames consumed
    */
-  virtual unsigned int AddData(void *data, unsigned int size) = 0;
+  virtual unsigned int AddData(uint8_t* const *data, unsigned int offset, unsigned int frames, double pts) = 0;
 
   /**
    * Returns the time in seconds that it will take
@@ -65,6 +67,12 @@ class IAEStream
   virtual double GetDelay() = 0;
 
   /**
+   * Returns playing PTS
+   * @return millis
+   */
+  virtual int64_t GetPlayingPTS() = 0;
+
+  /**
    * Returns if the stream is buffering
    * @return True if the stream is buffering
    */
-- 
1.9.3


From 62292f00b18a1bff62ef924e9cab7f49fb7c9abb Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 24 May 2014 15:03:37 +0200
Subject: [PATCH 02/37] dvdplayer audio: simplify interface to AE, feed
 timestamps

---
 xbmc/cores/dvdplayer/DVDAudio.cpp                  | 146 ++++-----------------
 xbmc/cores/dvdplayer/DVDAudio.h                    |   7 +-
 .../dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h      |  21 +--
 .../DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp        | 132 +++----------------
 .../DVDCodecs/Audio/DVDAudioCodecFFmpeg.h          |   6 +-
 xbmc/cores/dvdplayer/DVDPlayerAudio.cpp            |  23 ++--
 xbmc/cores/dvdplayer/DVDPlayerAudio.h              |   1 -
 7 files changed, 72 insertions(+), 264 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDAudio.cpp b/xbmc/cores/dvdplayer/DVDAudio.cpp
index 5166b9e..9594912 100644
--- a/xbmc/cores/dvdplayer/DVDAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDAudio.cpp
@@ -91,33 +91,12 @@ double CPTSOutputQueue::Current(double timestamp)
   return m_current.pts + min(m_current.duration, (timestamp - m_current.timestamp));
 }
 
-/** \brief Reallocs the memory block pointed to by src by the size len.
-*   \param[in] src Pointer to a memory block.
-*   \param[in] len New size of the memory block.
-*   \exception realloc failed
-*   \return A pointer to the reallocated memory block. 
-*/
-static void* realloc_or_free(void* src, int len) throw(exception)
-{
-  void* new_pBuffer = realloc(src, len);
-  if (new_pBuffer)
-    return new_pBuffer;
-  else
-  {
-    CLog::Log(LOGERROR, "DVDAUDIO - %s : could not realloc the buffer",  __FUNCTION__);
-    free(src);
-    throw exception();
-  }
-}
-
 CDVDAudio::CDVDAudio(volatile bool &bStop)
   : m_bStop(bStop)
 {
   m_pAudioStream = NULL;
   m_pAudioCallback = NULL;
-  m_iBufferSize = 0;
-  m_dwPacketSize = 0;
-  m_pBuffer = NULL;
+  m_frameSize = 0;
   m_bPassthrough = false;
   m_iBitsPerSample = 0;
   m_iBitrate = 0;
@@ -130,8 +109,6 @@ CDVDAudio::~CDVDAudio()
   CSingleLock lock (m_critSection);
   if (m_pAudioStream)
     CAEFactory::FreeStream(m_pAudioStream);
-
-  free(m_pBuffer);
 }
 
 bool CDVDAudio::Create(const DVDAudioFrame &audioframe, AVCodecID codec, bool needresampler)
@@ -162,14 +139,13 @@ bool CDVDAudio::Create(const DVDAudioFrame &audioframe, AVCodecID codec, bool ne
   m_iBitsPerSample = audioframe.bits_per_sample;
   m_bPassthrough   = audioframe.passthrough;
   m_channelLayout  = audioframe.channel_layout;
-  m_dwPacketSize   = m_pAudioStream->GetFrameSize();
+  m_frameSize      = m_pAudioStream->GetFrameSize();
 
   if(m_channelLayout.Count() && m_iBitrate && m_iBitsPerSample)
     m_SecondsPerByte = 1.0 / (m_channelLayout.Count() * m_iBitrate * (m_iBitsPerSample>>3));
   else
     m_SecondsPerByte = 0.0;
 
-  m_iBufferSize = 0;
   SetDynamicRangeCompression((long)(CMediaSettings::Get().GetCurrentVideoSettings().m_VolumeAmplification * 100));
 
   if (m_pAudioCallback)
@@ -185,36 +161,37 @@ void CDVDAudio::Destroy()
   if (m_pAudioStream)
     CAEFactory::FreeStream(m_pAudioStream);
 
-  free(m_pBuffer);
-  m_pBuffer = NULL;
-  m_dwPacketSize = 0;
+  m_frameSize = 0;
   m_pAudioStream = NULL;
-  m_iBufferSize = 0;
   m_iBitrate = 0;
   m_iBitsPerSample = 0;
   m_bPassthrough = false;
   m_bPaused = true;
-  m_time.Flush();
 }
 
-unsigned int CDVDAudio::AddPacketsRenderer(unsigned char* data, unsigned int len, CSingleLock &lock)
+unsigned int CDVDAudio::AddPacketsRenderer(uint8_t* const *data, unsigned int frames, double pts, CSingleLock &lock)
 {
   if(!m_pAudioStream)
     return 0;
 
   //Calculate a timeout when this definitely should be done
   double timeout;
-  timeout  = DVD_SEC_TO_TIME(m_pAudioStream->GetDelay() + len * m_SecondsPerByte);
+  timeout  = DVD_SEC_TO_TIME(m_pAudioStream->GetDelay() + frames*m_frameSize * m_SecondsPerByte);
   timeout += DVD_SEC_TO_TIME(1.0);
   timeout += CDVDClock::GetAbsoluteClock();
 
-  unsigned int  total = len;
+  unsigned int total = frames;
+  unsigned int offset = 0;
   do
   {
-    unsigned int copied = m_pAudioStream->AddData(data, len);
-    data += copied;
-    len -= copied;
-    if (len < m_dwPacketSize)
+    int64_t iPts = 0;
+    if (pts != DVD_NOPTS_VALUE && !offset)
+      iPts = (int64_t)DVD_TIME_TO_MSEC(pts);
+
+    unsigned int copied = m_pAudioStream->AddData(data, offset, frames, iPts);
+    offset += copied;
+    frames -= copied;
+    if (frames <= 0)
       break;
 
     if (copied == 0 && timeout < CDVDClock::GetAbsoluteClock())
@@ -228,64 +205,16 @@ unsigned int CDVDAudio::AddPacketsRenderer(unsigned char* data, unsigned int len
     lock.Enter();
   } while (!m_bStop);
 
-  return total - len;
+  return total - frames;
 }
 
 unsigned int CDVDAudio::AddPackets(const DVDAudioFrame &audioframe)
 {
   CSingleLock lock (m_critSection);
 
-  unsigned char* data = audioframe.data;
-  unsigned int len = audioframe.size;
-
-  unsigned int total = len;
-  unsigned int copied;
-
-  if (m_iBufferSize > 0) // See if there are carryover bytes from the last call. need to add them 1st.
-  {
-    copied = std::min(m_dwPacketSize - m_iBufferSize % m_dwPacketSize, len); // Smaller of either the data provided or the leftover data
-    if(copied)
-    {
-      m_pBuffer = (uint8_t*)realloc_or_free(m_pBuffer, m_iBufferSize + copied);
-      memcpy(m_pBuffer + m_iBufferSize, data, copied); // Tack the caller's data onto the end of the buffer
-      data += copied; // Move forward in caller's data
-      len -= copied; // Decrease amount of data available from caller
-      m_iBufferSize += copied; // Increase amount of data available in buffer
-    }
-
-    if(m_iBufferSize < m_dwPacketSize) // If we don't have enough data to give to the renderer, wait until next time
-      return copied;
-
-    if(AddPacketsRenderer(m_pBuffer, m_iBufferSize, lock) != m_iBufferSize)
-    {
-      m_iBufferSize = 0;
-      CLog::Log(LOGERROR, "%s - failed to add leftover bytes to render", __FUNCTION__);
-      return copied;
-    }
-
-    m_iBufferSize = 0;
-    if (!len)
-      return copied; // We used up all the caller's data
-  }
-
-  copied = AddPacketsRenderer(data, len, lock);
-  data += copied;
-  len -= copied;
+  unsigned int copied = AddPacketsRenderer(audioframe.data, audioframe.nb_frames, audioframe.pts, lock);
 
-  // if we have more data left, save it for the next call to this funtion
-  if (len > 0 && !m_bStop)
-  {
-    m_pBuffer     = (uint8_t*)realloc_or_free(m_pBuffer, len);
-    m_iBufferSize = len;
-    memcpy(m_pBuffer, data, len);
-  }
-
-  double time_added = DVD_SEC_TO_TIME(m_SecondsPerByte * (data - audioframe.data));
-  double delay      = GetDelay();
-  double timestamp  = CDVDClock::GetAbsoluteClock();
-  m_time.Add(audioframe.pts, delay - time_added, audioframe.duration, timestamp);
-
-  return total;
+  return copied;
 }
 
 void CDVDAudio::Finish()
@@ -293,21 +222,6 @@ void CDVDAudio::Finish()
   CSingleLock lock (m_critSection);
   if (!m_pAudioStream)
     return;
-
-  unsigned int silence = m_dwPacketSize - m_iBufferSize % m_dwPacketSize;
-
-  if(silence > 0 && m_iBufferSize > 0)
-  {
-    CLog::Log(LOGDEBUG, "CDVDAudio::Drain - adding %d bytes of silence, buffer size: %d, chunk size: %d", silence, m_iBufferSize, m_dwPacketSize);
-    m_pBuffer = (uint8_t*)realloc_or_free(m_pBuffer, m_iBufferSize + silence);
-    memset(m_pBuffer+m_iBufferSize, 0, silence);
-    m_iBufferSize += silence;
-  }
-
-  if(AddPacketsRenderer(m_pBuffer, m_iBufferSize, lock) != m_iBufferSize)
-    CLog::Log(LOGERROR, "CDVDAudio::Drain - failed to play the final %d bytes", m_iBufferSize);
-
-  m_iBufferSize = 0;
 }
 
 void CDVDAudio::Drain()
@@ -360,7 +274,6 @@ void CDVDAudio::Pause()
 {
   CSingleLock lock (m_critSection);
   if (m_pAudioStream) m_pAudioStream->Pause();
-  m_time.Flush();
 }
 
 void CDVDAudio::Resume()
@@ -377,8 +290,6 @@ double CDVDAudio::GetDelay()
   if(m_pAudioStream)
     delay = m_pAudioStream->GetDelay();
 
-  delay += m_SecondsPerByte * m_iBufferSize;
-
   return delay * DVD_TIME_BASE;
 }
 
@@ -390,8 +301,6 @@ void CDVDAudio::Flush()
   {
     m_pAudioStream->Flush();
   }
-  m_iBufferSize = 0;
-  m_time.Flush();
 }
 
 bool CDVDAudio::IsValidFormat(const DVDAudioFrame &audioframe)
@@ -428,8 +337,6 @@ double CDVDAudio::GetCacheTime()
   if(m_pAudioStream)
     delay = m_pAudioStream->GetCacheTime();
 
-  delay += m_SecondsPerByte * m_iBufferSize;
-
   return delay;
 }
 
@@ -441,16 +348,15 @@ double CDVDAudio::GetCacheTotal()
   return m_pAudioStream->GetCacheTotal();
 }
 
-void CDVDAudio::SetPlayingPts(double pts)
+double CDVDAudio::GetPlayingPts()
 {
   CSingleLock lock (m_critSection);
-  m_time.Flush();
-  double delay     = GetDelay();
-  double timestamp = CDVDClock::GetAbsoluteClock();
-  m_time.Add(pts, delay, 0, timestamp);
-}
+  if(!m_pAudioStream)
+    return DVD_NOPTS_VALUE;
 
-double CDVDAudio::GetPlayingPts()
-{
-  return m_time.Current(CDVDClock::GetAbsoluteClock());
+  double pts = m_pAudioStream->GetPlayingPTS();
+  if (!pts)
+    return DVD_NOPTS_VALUE;
+
+  return DVD_MSEC_TO_TIME(pts);
 }
diff --git a/xbmc/cores/dvdplayer/DVDAudio.h b/xbmc/cores/dvdplayer/DVDAudio.h
index 4e22383..8c13719 100644
--- a/xbmc/cores/dvdplayer/DVDAudio.h
+++ b/xbmc/cores/dvdplayer/DVDAudio.h
@@ -86,11 +86,8 @@ class CDVDAudio
 
   IAEStream *m_pAudioStream;
 protected:
-  CPTSOutputQueue m_time;
-  unsigned int AddPacketsRenderer(unsigned char* data, unsigned int len, CSingleLock &lock);
-  uint8_t*     m_pBuffer; // should be [m_dwPacketSize]
-  unsigned int m_iBufferSize;
-  unsigned int m_dwPacketSize;
+  unsigned int AddPacketsRenderer(uint8_t* const *data, unsigned int frames, double pts, CSingleLock &lock);
+  unsigned int m_frameSize;
   CCriticalSection m_critSection;
 
   int m_iBitrate;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
index 7ebf84a..a935db7 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
@@ -43,10 +43,12 @@ class CDVDCodecOptions;
 
 typedef struct stDVDAudioFrame
 {
-  uint8_t*          data;
+  uint8_t*          data[16];
   double            pts;
   double            duration;
-  unsigned int      size;
+  unsigned int      nb_frames;
+  unsigned int      framesize;
+  unsigned int      planes;
 
   int               channel_count;
   int               encoded_channel_count;
@@ -92,22 +94,25 @@ class CDVDAudioCodec
    */
   virtual void GetData(DVDAudioFrame &frame)
   {
-    frame.size                  = GetData(&frame.data);
-    if(frame.size == 0u)
+    frame.nb_frames = 0;
+    frame.data_format           = GetDataFormat();
+    frame.channel_count         = GetChannels();
+    frame.framesize             = (CAEUtil::DataFormatToBits(frame.data_format) >> 3) * frame.channel_count;
+    if(frame.framesize == 0)
       return;
+    frame.nb_frames             = GetData(frame.data)/frame.framesize;
     frame.channel_layout        = GetChannelMap();
     frame.channel_count         = GetChannels();
+    frame.planes                = AE_IS_PLANAR(frame.data_format) ? frame.channel_count : 1;
     frame.encoded_channel_count = GetEncodedChannels();
-    frame.data_format           = GetDataFormat();
     frame.bits_per_sample       = CAEUtil::DataFormatToBits(frame.data_format);
     frame.sample_rate           = GetSampleRate();
     frame.encoded_sample_rate   = GetEncodedSampleRate();
     frame.passthrough           = NeedPassthrough();
     frame.pts                   = DVD_NOPTS_VALUE;
     // compute duration.
-    int n = (frame.channel_count * frame.bits_per_sample * frame.sample_rate)>>3;
-    if (n)
-      frame.duration = ((double)frame.size * DVD_TIME_BASE) / n;
+    if (frame.sample_rate)
+      frame.duration = ((double)frame.nb_frames * DVD_TIME_BASE) / frame.sample_rate;
     else
       frame.duration = 0.0;
   }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
index 6749c2e..5ba1e1b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
@@ -32,14 +32,8 @@
 
 CDVDAudioCodecFFmpeg::CDVDAudioCodecFFmpeg() : CDVDAudioCodec()
 {
-  m_iBufferSize1 = 0;
-  m_iBufferSize2 = 0;
-  m_iBufferTotalSize2 = 0;
-  m_pBuffer2     = NULL;
-
   m_iBuffered = 0;
   m_pCodecContext = NULL;
-  m_pConvert = NULL;
   m_bOpenedCodec = false;
 
   m_channels = 0;
@@ -47,6 +41,7 @@ CDVDAudioCodecFFmpeg::CDVDAudioCodecFFmpeg() : CDVDAudioCodec()
   
   m_pFrame1 = NULL;
   m_iSampleFormat = AV_SAMPLE_FMT_NONE;
+  m_gotFrame = 0;
 }
 
 CDVDAudioCodecFFmpeg::~CDVDAudioCodecFFmpeg()
@@ -113,12 +108,6 @@ void CDVDAudioCodecFFmpeg::Dispose()
   if (m_pFrame1) av_free(m_pFrame1);
   m_pFrame1 = NULL;
 
-  if (m_pConvert)
-    swr_free(&m_pConvert);
-
-  if (m_pBuffer2)
-    av_freep(&m_pBuffer2);
-
   if (m_pCodecContext)
   {
     if (m_bOpenedCodec) avcodec_close(m_pCodecContext);
@@ -127,33 +116,26 @@ void CDVDAudioCodecFFmpeg::Dispose()
     m_pCodecContext = NULL;
   }
 
-  m_iBufferSize1 = 0;
-  m_iBufferSize2 = 0;
-  m_iBufferTotalSize2 = 0;
   m_iBuffered = 0;
 }
 
 int CDVDAudioCodecFFmpeg::Decode(uint8_t* pData, int iSize)
 {
-  int iBytesUsed, got_frame;
+  int iBytesUsed;
   if (!m_pCodecContext) return -1;
 
-  m_iBufferSize2 = 0;
-
   AVPacket avpkt;
   av_init_packet(&avpkt);
   avpkt.data = pData;
   avpkt.size = iSize;
   iBytesUsed = avcodec_decode_audio4( m_pCodecContext
                                                  , m_pFrame1
-                                                 , &got_frame
+                                                 , &m_gotFrame
                                                  , &avpkt);
-  if (iBytesUsed < 0 || !got_frame)
+  if (iBytesUsed < 0 || !m_gotFrame)
   {
-    m_iBufferSize1 = 0;
     return iBytesUsed;
   }
-  m_iBufferSize1 = m_pFrame1->nb_samples * m_pCodecContext->channels * av_get_bytes_per_sample(m_pCodecContext->sample_fmt);
 
   /* some codecs will attempt to consume more data than what we gave */
   if (iBytesUsed > iSize)
@@ -162,104 +144,23 @@ int CDVDAudioCodecFFmpeg::Decode(uint8_t* pData, int iSize)
     iBytesUsed = iSize;
   }
 
-  if(m_iBufferSize1 == 0 && iBytesUsed >= 0)
+  if(iBytesUsed >= 0)
     m_iBuffered += iBytesUsed;
   else
     m_iBuffered = 0;
   
-  bool convert = false;
-  switch(m_pCodecContext->sample_fmt)
-  {
-    case AV_SAMPLE_FMT_U8:
-    case AV_SAMPLE_FMT_S16:
-    case AV_SAMPLE_FMT_S32:
-    case AV_SAMPLE_FMT_FLT:
-    case AV_SAMPLE_FMT_DBL:
-      break;
-    case AV_SAMPLE_FMT_NONE:
-      CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::Decode - invalid data format");
-      return -1;
-    default:
-      convert = true;
-  }
-  if(convert)
-    ConvertToFloat();
-
   return iBytesUsed;
 }
 
-void CDVDAudioCodecFFmpeg::ConvertToFloat()
-{
-  if(m_pCodecContext->sample_fmt != AV_SAMPLE_FMT_FLT && m_iBufferSize1 > 0)
-  {
-    if(m_pConvert && (m_pCodecContext->sample_fmt != m_iSampleFormat || m_channels != m_pCodecContext->channels))
-      swr_free(&m_pConvert);
-
-    if(!m_pConvert)
-    {
-      m_iSampleFormat = m_pCodecContext->sample_fmt;
-      m_pConvert = swr_alloc_set_opts(NULL,
-                      av_get_default_channel_layout(m_pCodecContext->channels), AV_SAMPLE_FMT_FLT, m_pCodecContext->sample_rate,
-                      av_get_default_channel_layout(m_pCodecContext->channels), m_pCodecContext->sample_fmt, m_pCodecContext->sample_rate,
-                      0, NULL);
-
-      if(!m_pConvert || swr_init(m_pConvert) < 0)
-      {
-          CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::Decode - Unable to convert %d to AV_SAMPLE_FMT_FLT", m_pCodecContext->sample_fmt);
-          m_iBufferSize1 = 0;
-          m_iBufferSize2 = 0;
-          return;
-      }
-    }
-
-    int needed_buf_size = av_samples_get_buffer_size(NULL, m_pCodecContext->channels, m_pFrame1->nb_samples, AV_SAMPLE_FMT_FLT, 0);
-    if(m_iBufferTotalSize2 < needed_buf_size)
-    {
-        m_pBuffer2 = (uint8_t*)av_realloc(m_pBuffer2, needed_buf_size);
-        if(!m_pBuffer2)
-        {
-            CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::Decode - Unable to allocate a %i bytes buffer for resampling", needed_buf_size);
-            m_iBufferSize1 = 0;
-            m_iBufferSize2 = 0;
-            m_iBufferTotalSize2 = 0;
-            return;
-        }
-        m_iBufferTotalSize2 = needed_buf_size;
-    }
-
-    int outsamples;
-    outsamples = swr_convert(m_pConvert, &m_pBuffer2, m_iBufferTotalSize2, (const uint8_t**)m_pFrame1->extended_data, m_pFrame1->nb_samples);
-
-    if(outsamples < 0)
-    {
-      CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::Decode - Unable to convert %d to AV_SAMPLE_FMT_FLT", (int)m_pCodecContext->sample_fmt);
-      m_iBufferSize1 = 0;
-      m_iBufferSize2 = 0;
-      return;
-    }
-
-    if(outsamples < m_pFrame1->nb_samples)
-    {
-      CLog::Log(LOGWARNING, "CDVDAudioCodecFFmpeg::Decode - Resampler produced less samples than what it was given");
-    }
-
-    m_iBufferSize1 = 0;
-    m_iBufferSize2 = m_pFrame1->nb_samples * m_pCodecContext->channels * av_get_bytes_per_sample(AV_SAMPLE_FMT_FLT);
-  }
-}
-
 int CDVDAudioCodecFFmpeg::GetData(uint8_t** dst)
 {
-  if(m_iBufferSize1)
-  {
-    *dst = m_pFrame1->data[0];
-    return m_iBufferSize1;
-  }
-
-  if(m_iBufferSize2)
+  if(m_gotFrame)
   {
-    *dst = m_pBuffer2;
-    return m_iBufferSize2;
+    int planes = av_sample_fmt_is_planar(m_pCodecContext->sample_fmt) ? m_pFrame1->channels : 1;
+    for (int i=0; i<planes; i++)
+      dst[i] = m_pFrame1->extended_data[i];
+    m_gotFrame = 0;
+    return m_pFrame1->nb_samples * m_pFrame1->channels * av_get_bytes_per_sample(m_pCodecContext->sample_fmt);
   }
 
   return 0;
@@ -268,9 +169,8 @@ int CDVDAudioCodecFFmpeg::GetData(uint8_t** dst)
 void CDVDAudioCodecFFmpeg::Reset()
 {
   if (m_pCodecContext) avcodec_flush_buffers(m_pCodecContext);
-  m_iBufferSize1 = 0;
-  m_iBufferSize2 = 0;
   m_iBuffered = 0;
+  m_gotFrame = 0;
 }
 
 int CDVDAudioCodecFFmpeg::GetChannels()
@@ -290,15 +190,19 @@ enum AEDataFormat CDVDAudioCodecFFmpeg::GetDataFormat()
   switch(m_pCodecContext->sample_fmt)
   {
     case AV_SAMPLE_FMT_U8 : return AE_FMT_U8;
+    case AV_SAMPLE_FMT_U8P : return AE_FMT_U8P;
     case AV_SAMPLE_FMT_S16: return AE_FMT_S16NE;
+    case AV_SAMPLE_FMT_S16P: return AE_FMT_S16NEP;
     case AV_SAMPLE_FMT_S32: return AE_FMT_S32NE;
+    case AV_SAMPLE_FMT_S32P: return AE_FMT_S32NEP;
     case AV_SAMPLE_FMT_FLT: return AE_FMT_FLOAT;
+    case AV_SAMPLE_FMT_FLTP: return AE_FMT_FLOATP;
     case AV_SAMPLE_FMT_DBL: return AE_FMT_DOUBLE;
+    case AV_SAMPLE_FMT_DBLP: return AE_FMT_DOUBLEP;
     case AV_SAMPLE_FMT_NONE:
+    default:
       CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::GetDataFormat - invalid data format");
       return AE_FMT_INVALID;
-    default:
-      return AE_FMT_FLOAT;
   }
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
index 3946e01..9d00c3f 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
@@ -49,15 +49,11 @@ class CDVDAudioCodecFFmpeg : public CDVDAudioCodec
 
 protected:
   AVCodecContext*     m_pCodecContext;
-  SwrContext*         m_pConvert;
   enum AVSampleFormat m_iSampleFormat;  
   CAEChannelInfo      m_channelLayout;
 
   AVFrame* m_pFrame1;
-  int      m_iBufferSize1;
-  uint8_t*    m_pBuffer2;
-  int      m_iBufferSize2;
-  int      m_iBufferTotalSize2;
+  int m_gotFrame;
 
   bool m_bOpenedCodec;
   int m_iBuffered;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
index be8214a..174660d 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
@@ -246,7 +246,7 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe)
   int result = 0;
 
   // make sure the sent frame is clean
-  memset(&audioframe, 0, sizeof(DVDAudioFrame));
+  audioframe.nb_frames = 0;
 
   while (!m_bStop)
   {
@@ -280,7 +280,7 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe)
       // get decoded data and the size of it
       m_pAudioCodec->GetData(audioframe);
 
-      if (audioframe.size == 0)
+      if (audioframe.nb_frames == 0)
         continue;
 
       if (audioframe.pts == DVD_NOPTS_VALUE)
@@ -358,7 +358,6 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe)
         m_audioClock = pMsgGeneralResync->m_timestamp;
 
       m_ptsInput.Flush();
-      m_dvdAudio.SetPlayingPts(m_audioClock);
       if (pMsgGeneralResync->m_clock)
         m_pClock->Discontinuity(m_dvdAudio.GetPlayingPts());
     }
@@ -527,7 +526,7 @@ void CDVDPlayerAudio::Process()
       break;
     }
 
-    if( audioframe.size == 0 )
+    if( audioframe.nb_frames == 0 )
       continue;
 
     packetadded = true;
@@ -551,14 +550,13 @@ void CDVDPlayerAudio::Process()
 
     // Zero out the frame data if we are supposed to silence the audio
     if (m_silence)
-      memset(audioframe.data, 0, audioframe.size);
-
-    if(result & DECODE_FLAG_DROP)
     {
-      // keep output times in sync
-     m_dvdAudio.SetPlayingPts(m_audioClock);
+      int size = audioframe.nb_frames * audioframe.channel_count / audioframe.planes;
+      for (int i=0; i<audioframe.planes; i++)
+        memset(audioframe.data[i], 0, size);
     }
-    else
+
+    if(!(result & DECODE_FLAG_DROP))
     {
       SetSyncType(audioframe.passthrough);
 
@@ -622,7 +620,10 @@ void CDVDPlayerAudio::HandleSyncError(double duration)
 {
   double absolute;
   double clock = m_pClock->GetClock(absolute);
-  double error = m_dvdAudio.GetPlayingPts() - clock;
+  double pts = m_dvdAudio.GetPlayingPts();
+  if (pts == DVD_NOPTS_VALUE)
+    return;
+  double error = pts - clock;
   EMasterClock master = m_pClock->GetMaster();
 
   if( (fabs(error) > DVD_MSEC_TO_TIME(100) || m_syncclock)
diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.h b/xbmc/cores/dvdplayer/DVDPlayerAudio.h
index 4b48514..1731d6b 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.h
@@ -139,7 +139,6 @@ class CDVDPlayerAudio : public CThread
   // holds stream information for current playing stream
   CDVDStreamInfo m_streaminfo;
 
-  CPTSOutputQueue m_ptsOutput;
   CPTSInputQueue  m_ptsInput;
 
   double GetCurrentPts()                            { return m_dvdAudio.GetPlayingPts(); }
-- 
1.9.3


From 621790ac8f01fd73fc3ac40994c0d4c4a7b4a31c Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 24 May 2014 15:04:32 +0200
Subject: [PATCH 03/37] paplayer: adapt to interface change of AE, feed entire
 frames into AE

---
 xbmc/cores/paplayer/DVDPlayerCodec.cpp | 97 ++++++++++++++++++++++++++++++----
 xbmc/cores/paplayer/DVDPlayerCodec.h   | 17 +++++-
 xbmc/cores/paplayer/PAPlayer.cpp       |  9 ++--
 3 files changed, 107 insertions(+), 16 deletions(-)

diff --git a/xbmc/cores/paplayer/DVDPlayerCodec.cpp b/xbmc/cores/paplayer/DVDPlayerCodec.cpp
index 5a13093..3a35a49 100644
--- a/xbmc/cores/paplayer/DVDPlayerCodec.cpp
+++ b/xbmc/cores/paplayer/DVDPlayerCodec.cpp
@@ -20,6 +20,7 @@
 
 #include "DVDPlayerCodec.h"
 #include "cores/AudioEngine/Utils/AEUtil.h"
+#include "cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h"
 
 #include "cores/dvdplayer/DVDInputStreams/DVDFactoryInputStream.h"
 #include "cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.h"
@@ -42,10 +43,12 @@ DVDPlayerCodec::DVDPlayerCodec()
   m_nAudioStream = -1;
   m_audioPos = 0;
   m_pPacket = NULL;
-  m_decoded = NULL;
   m_nDecodedLen = 0;
   m_strFileName = "";
   m_bInited = false;
+  m_pResampler = NULL;
+  m_needConvert = false;
+  m_srcFrameSize = 0;
 }
 
 DVDPlayerCodec::~DVDPlayerCodec()
@@ -71,7 +74,6 @@ bool DVDPlayerCodec::Init(const CStdString &strFile, unsigned int filecache)
     DeInit();
   }
 
-  m_decoded = NULL;
   m_nDecodedLen = 0;
 
   CStdString strFileToOpen = strFile;
@@ -224,6 +226,32 @@ bool DVDPlayerCodec::Init(const CStdString &strFile, unsigned int filecache)
   }
   m_pDemuxer->GetStreamCodecName(m_nAudioStream,m_CodecName);
 
+  m_needConvert = false;
+  if (NeedConvert(m_DataFormat))
+  {
+    m_needConvert = true;
+    m_pResampler = new ActiveAE::CActiveAEResample();
+    m_pResampler->Init(ActiveAE::CActiveAEResample::GetAVChannelLayout(m_ChannelInfo),
+                       m_ChannelInfo.Count(),
+                       m_SampleRate,
+                       ActiveAE::CActiveAEResample::GetAVSampleFormat(AE_FMT_FLOAT),
+                       CAEUtil::DataFormatToUsedBits(AE_FMT_FLOAT),
+                       ActiveAE::CActiveAEResample::GetAVChannelLayout(m_ChannelInfo),
+                       m_ChannelInfo.Count(),
+                       m_SampleRate,
+                       ActiveAE::CActiveAEResample::GetAVSampleFormat(m_DataFormat),
+                       CAEUtil::DataFormatToUsedBits(m_DataFormat),
+                       false,
+                       false,
+                       NULL,
+                       AE_QUALITY_UNKNOWN);
+    m_planes = AE_IS_PLANAR(m_DataFormat) ? m_ChannelInfo.Count() : 1;
+    m_srcFormat = m_DataFormat;
+    m_srcFrameSize = (CAEUtil::DataFormatToBits(m_DataFormat)>>3) * m_ChannelInfo.Count();
+    m_DataFormat = AE_FMT_FLOAT;
+    m_BitsPerSample = CAEUtil::DataFormatToBits(m_DataFormat);
+  }
+
   m_strFileName = strFile;
   m_bInited = true;
 
@@ -254,6 +282,9 @@ void DVDPlayerCodec::DeInit()
     m_pAudioCodec = NULL;
   }
 
+  delete m_pResampler;
+  m_pResampler = NULL;
+
   // cleanup format information
   m_TotalTime = 0;
   m_SampleRate = 0;
@@ -264,7 +295,6 @@ void DVDPlayerCodec::DeInit()
   m_Bitrate = 0;
 
   m_audioPos = 0;
-  m_decoded = NULL;
   m_nDecodedLen = 0;
 
   m_strFileName = "";
@@ -287,7 +317,6 @@ int64_t DVDPlayerCodec::Seek(int64_t iSeekTime)
   bool ret = m_pDemuxer->SeekTime((int)iSeekTime, seekback);
   m_pAudioCodec->Reset();
 
-  m_decoded = NULL;
   m_nDecodedLen = 0;
 
   if (!ret)
@@ -298,17 +327,29 @@ int64_t DVDPlayerCodec::Seek(int64_t iSeekTime)
 
 int DVDPlayerCodec::ReadPCM(BYTE *pBuffer, int size, int *actualsize)
 {
-  if (m_decoded && m_nDecodedLen > 0)
+  if (m_nDecodedLen > 0)
   {
     int nLen = (size<m_nDecodedLen)?size:m_nDecodedLen;
     *actualsize = nLen;
-    memcpy(pBuffer, m_decoded, *actualsize);
+    if (m_needConvert)
+    {
+      int samples = *actualsize / (m_BitsPerSample>>3);
+      int frames = samples / m_Channels;
+      m_pResampler->Resample(&pBuffer, frames, m_audioPlanes, frames, 1.0);
+      for (int i=0; i<m_planes; i++)
+      {
+        m_audioPlanes[i] += frames*m_srcFrameSize/m_planes;
+      }
+    }
+    else
+    {
+      memcpy(pBuffer, m_audioPlanes[0], *actualsize);
+      m_audioPlanes[0] += (*actualsize);
+    }
     m_nDecodedLen -= nLen;
-    m_decoded += (*actualsize);
     return READ_SUCCESS;
   }
 
-  m_decoded = NULL;
   m_nDecodedLen = 0;
 
   // dvdplayer returns a read error on a single invalid packet, while
@@ -354,14 +395,30 @@ int DVDPlayerCodec::ReadPCM(BYTE *pBuffer, int size, int *actualsize)
 
   m_audioPos += decodeLen;
 
-  m_nDecodedLen = m_pAudioCodec->GetData(&m_decoded);
+  // scale decoded bytes to destination format
+  m_nDecodedLen = m_pAudioCodec->GetData(m_audioPlanes);
+  if (m_needConvert)
+    m_nDecodedLen *= (m_BitsPerSample>>3) / (m_srcFrameSize / m_Channels);
 
   *actualsize = (m_nDecodedLen <= size) ? m_nDecodedLen : size;
   if (*actualsize > 0)
   {
-    memcpy(pBuffer, m_decoded, *actualsize);
+    if (m_needConvert)
+    {
+      int samples = *actualsize / (m_BitsPerSample>>3);
+      int frames = samples / m_Channels;
+      m_pResampler->Resample(&pBuffer, frames, m_audioPlanes, frames, 1.0);
+      for (int i=0; i<m_planes; i++)
+      {
+        m_audioPlanes[i] += frames*m_srcFrameSize/m_planes;
+      }
+    }
+    else
+    {
+      memcpy(pBuffer, m_audioPlanes[0], *actualsize);
+      m_audioPlanes[0] += *actualsize;
+    }
     m_nDecodedLen -= *actualsize;
-    m_decoded += (*actualsize);
   }
 
   return READ_SUCCESS;
@@ -376,3 +433,21 @@ bool DVDPlayerCodec::CanSeek()
 {
   return m_bCanSeek;
 }
+
+bool DVDPlayerCodec::NeedConvert(AEDataFormat fmt)
+{
+  if (AE_IS_RAW(fmt))
+    return false;
+
+  switch(fmt)
+  {
+    case AE_FMT_U8:
+    case AE_FMT_S16NE:
+    case AE_FMT_S32NE:
+    case AE_FMT_FLOAT:
+    case AE_FMT_DOUBLE:
+      return false;
+    default:
+      return true;
+  }
+}
diff --git a/xbmc/cores/paplayer/DVDPlayerCodec.h b/xbmc/cores/paplayer/DVDPlayerCodec.h
index 5919925..8b594f8 100644
--- a/xbmc/cores/paplayer/DVDPlayerCodec.h
+++ b/xbmc/cores/paplayer/DVDPlayerCodec.h
@@ -27,6 +27,11 @@
 #include "cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h"
 #include "cores/dvdplayer/DVDInputStreams/DVDInputStream.h"
 
+namespace ActiveAE
+{
+  class CActiveAEResample;
+};
+
 class DVDPlayerCodec : public ICodec
 {
 public:
@@ -43,6 +48,8 @@ class DVDPlayerCodec : public ICodec
 
   void SetContentType(const CStdString &strContent);
 
+  bool NeedConvert(AEDataFormat fmt);
+
 private:
   CDVDDemux* m_pDemuxer;
   CDVDInputStream* m_pInputStream;
@@ -55,15 +62,21 @@ class DVDPlayerCodec : public ICodec
   int m_nAudioStream;
 
   int m_audioPos;
-  DemuxPacket* m_pPacket ;
+  DemuxPacket* m_pPacket;
 
-  BYTE *m_decoded;
   int  m_nDecodedLen;
 
   CAEChannelInfo m_ChannelInfo;
 
   bool m_bInited;
   bool m_bCanSeek;
+
+  ActiveAE::CActiveAEResample *m_pResampler;
+  uint8_t *m_audioPlanes[8];
+  int m_planes;
+  bool m_needConvert;
+  AEDataFormat m_srcFormat;
+  int m_srcFrameSize;
 };
 
 #endif
diff --git a/xbmc/cores/paplayer/PAPlayer.cpp b/xbmc/cores/paplayer/PAPlayer.cpp
index e9cde86..df7bc56 100644
--- a/xbmc/cores/paplayer/PAPlayer.cpp
+++ b/xbmc/cores/paplayer/PAPlayer.cpp
@@ -828,15 +828,18 @@ bool PAPlayer::QueueData(StreamInfo *si)
   if (!samples)
     return true;
 
-  void* data = si->m_decoder.GetData(samples);
+  // we want complete frames
+  samples -= samples % si->m_channelInfo.Count();
+
+  uint8_t* data = (uint8_t*)si->m_decoder.GetData(samples);
   if (!data)
   {
     CLog::Log(LOGERROR, "PAPlayer::QueueData - Failed to get data from the decoder");
     return false;
   }
 
-  unsigned int added = si->m_stream->AddData(data, samples * si->m_bytesPerSample);
-  si->m_framesSent += added / si->m_bytesPerFrame;
+  unsigned int added = si->m_stream->AddData(&data, 0, samples/si->m_channelInfo.Count(), 0);
+  si->m_framesSent += added;
 
   const ICodec* codec = si->m_decoder.GetCodec();
   m_playerGUIData.m_cacheLevel = codec ? codec->GetCacheLevel() : 0; //update for GUI
-- 
1.9.3


From 6006782066965a566ebbcf67f31e8c80b6aa6502 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 24 May 2014 15:29:27 +0200
Subject: [PATCH 04/37] dvdplayer: drop obsolete pcm audio codecs

---
 .../DVDCodecs/Audio/DVDAudioCodecLPcm.cpp          | 100 -------
 .../dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h  |  46 ---
 .../dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp | 331 ---------------------
 .../dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h   |  60 ----
 xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in   |   2 -
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp |  51 +---
 6 files changed, 1 insertion(+), 589 deletions(-)
 delete mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp
 delete mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h
 delete mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp
 delete mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp
deleted file mode 100644
index ad33392..0000000
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.cpp
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "DVDAudioCodecLPcm.h"
-#include "DVDStreamInfo.h"
-
-CDVDAudioCodecLPcm::CDVDAudioCodecLPcm() : CDVDAudioCodecPcm()
-{
-  m_codecID = AV_CODEC_ID_NONE;
-  m_bufferSize = 0;
-  m_buffer = NULL;
-}
-
-CDVDAudioCodecLPcm::~CDVDAudioCodecLPcm()
-{
-  delete m_buffer;
-}
-
-bool CDVDAudioCodecLPcm::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
-{
-  m_codecID = hints.codec;
-
-  CDVDStreamInfo hints2(hints, true);
-  hints2.codec = AV_CODEC_ID_NONE;
-#if 0
-  if (hints.codecID = AV_CODEC_ID_LPCM_S24BE) hints2.codec = AV_CODEC_ID_PCM_S24BE;
-#endif
-  if (hints2.codec != AV_CODEC_ID_NONE)
-    return CDVDAudioCodecPcm::Open(hints2, options);
-
-  return false;
-}
-
-int CDVDAudioCodecLPcm::Decode(uint8_t* pData, int iSize)
-{
-  uint8_t* d = m_buffer;
-  uint8_t* s = pData;
-
-  if (iSize > m_bufferSize)
-  {
-    delete m_buffer;
-    d = m_buffer = new uint8_t[iSize];
-    if(!m_buffer)
-      return -1;
-    m_bufferSize = iSize;
-  }
-
-  if (iSize >= 12)
-  {
-    int iDecoded = 0;
-#if 0
-    if (m_codecID == AV_CODEC_ID_LPCM_S24BE)
-#endif
-    {
-      for (iDecoded = 0; iDecoded <= (iSize - 12); iDecoded += 12)
-      {
-        // first sample
-        d[0] = s[0];
-        d[1] = s[1];
-        d[2] = s[8];
-        // second sample
-        d[3] = s[2];
-        d[4] = s[3];
-        d[5] = s[9];
-        // third sample
-        d[6] = s[4];
-        d[7] = s[5];
-        d[8] = s[10];
-        // fourth sample
-        d[9] = s[6];
-        d[10] = s[7];
-        d[11] = s[11];
-
-        s += 12;
-        d += 12;
-      }
-    }
-
-    return CDVDAudioCodecPcm::Decode(m_buffer, iDecoded);
-  }
-
-  return iSize;
-}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h
deleted file mode 100644
index b459026..0000000
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecLPcm.h
+++ /dev/null
@@ -1,46 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "DVDAudioCodec.h"
-#include "DVDCodecs/DVDCodecs.h"
-#include "DVDAudioCodecPcm.h"
-
-class CDVDAudioCodecLPcm : public CDVDAudioCodecPcm
-{
-public:
-  CDVDAudioCodecLPcm();
-  virtual ~CDVDAudioCodecLPcm();
-  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
-  virtual int Decode(uint8_t* pData, int iSize);
-  virtual const char* GetName()  { return "lpcm"; }
-
-protected:
-
-  int m_bufferSize;
-  uint8_t *m_buffer;
-
-  AVCodecID m_codecID;
-
-private:
-  CDVDAudioCodecLPcm(const CDVDAudioCodecLPcm&);
-  CDVDAudioCodecLPcm const& operator=(CDVDAudioCodecLPcm const&);
-};
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp
deleted file mode 100644
index 14ea4af..0000000
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.cpp
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "DVDAudioCodecPcm.h"
-#include "DVDStreamInfo.h"
-#include "DVDCodecs/DVDCodecs.h"
-
-/* from g711.c by SUN microsystems (unrestricted use) */
-#define	SIGN_BIT	(0x80)		/* Sign bit for a A-law byte. */
-#define	QUANT_MASK	(0xf)		/* Quantization field mask. */
-#define	NSEGS		(8)		/* Number of A-law segments. */
-#define	SEG_SHIFT	(4)		/* Left shift for segment number. */
-#define	SEG_MASK	(0x70)		/* Segment field mask. */
-
-#define	BIAS		(0x84)		/* Bias for linear code. */
-
-/*
- * alaw2linear() - Convert an A-law value to 16-bit linear PCM
- *
- */
-static int alaw2linear(unsigned char	a_val)
-{
-	int		t;
-	int		seg;
-
-	a_val ^= 0x55;
-
-	t = a_val & QUANT_MASK;
-	seg = ((unsigned)a_val & SEG_MASK) >> SEG_SHIFT;
-	if(seg) t= (t + t + 1 + 32) << (seg + 2);
-	else    t= (t + t + 1     ) << 3;
-
-	return ((a_val & SIGN_BIT) ? t : -t);
-}
-
-static int ulaw2linear(unsigned char	u_val)
-{
-	int		t;
-
-	/* Complement to obtain normal u-law value. */
-	u_val = ~u_val;
-
-	/*
-	 * Extract and bias the quantization bits. Then
-	 * shift up by the segment number and subtract out the bias.
-	 */
-	t = ((u_val & QUANT_MASK) << 3) + BIAS;
-	t <<= ((unsigned)u_val & SEG_MASK) >> SEG_SHIFT;
-
-	return ((u_val & SIGN_BIT) ? (BIAS - t) : (t - BIAS));
-}
-
-/**
- * \brief convert samples to 16 bit
- * \param bps byte per sample for the source format, must be >= 2
- * \param le 0 for big-, 1 for little-endian
- * \param us 0 for signed, 1 for unsigned input
- * \param src input samples
- * \param samples output samples
- * \param src_len number of bytes in src
- */
-static inline void decode_to16(int bps, int le, int us, uint8_t **src, short **samples, int src_len)
-{
-    register int n = src_len / bps;
-    if (le) *src += bps - 2;
-    for(;n>0;n--) {
-        *(*samples)++ = ((*src)[le] << 8 | (*src)[1 - le]) - (us?0x8000:0);
-        *src += bps;
-    }
-    if (le) *src -= bps - 2;
-}
-
-const uint8_t ff_reverse[256] =
-    {
-      0x00,0x80,0x40,0xC0,0x20,0xA0,0x60,0xE0,0x10,0x90,0x50,0xD0,0x30,0xB0,0x70,0xF0,
-      0x08,0x88,0x48,0xC8,0x28,0xA8,0x68,0xE8,0x18,0x98,0x58,0xD8,0x38,0xB8,0x78,0xF8,
-      0x04,0x84,0x44,0xC4,0x24,0xA4,0x64,0xE4,0x14,0x94,0x54,0xD4,0x34,0xB4,0x74,0xF4,
-      0x0C,0x8C,0x4C,0xCC,0x2C,0xAC,0x6C,0xEC,0x1C,0x9C,0x5C,0xDC,0x3C,0xBC,0x7C,0xFC,
-      0x02,0x82,0x42,0xC2,0x22,0xA2,0x62,0xE2,0x12,0x92,0x52,0xD2,0x32,0xB2,0x72,0xF2,
-      0x0A,0x8A,0x4A,0xCA,0x2A,0xAA,0x6A,0xEA,0x1A,0x9A,0x5A,0xDA,0x3A,0xBA,0x7A,0xFA,
-      0x06,0x86,0x46,0xC6,0x26,0xA6,0x66,0xE6,0x16,0x96,0x56,0xD6,0x36,0xB6,0x76,0xF6,
-      0x0E,0x8E,0x4E,0xCE,0x2E,0xAE,0x6E,0xEE,0x1E,0x9E,0x5E,0xDE,0x3E,0xBE,0x7E,0xFE,
-      0x01,0x81,0x41,0xC1,0x21,0xA1,0x61,0xE1,0x11,0x91,0x51,0xD1,0x31,0xB1,0x71,0xF1,
-      0x09,0x89,0x49,0xC9,0x29,0xA9,0x69,0xE9,0x19,0x99,0x59,0xD9,0x39,0xB9,0x79,0xF9,
-      0x05,0x85,0x45,0xC5,0x25,0xA5,0x65,0xE5,0x15,0x95,0x55,0xD5,0x35,0xB5,0x75,0xF5,
-      0x0D,0x8D,0x4D,0xCD,0x2D,0xAD,0x6D,0xED,0x1D,0x9D,0x5D,0xDD,0x3D,0xBD,0x7D,0xFD,
-      0x03,0x83,0x43,0xC3,0x23,0xA3,0x63,0xE3,0x13,0x93,0x53,0xD3,0x33,0xB3,0x73,0xF3,
-      0x0B,0x8B,0x4B,0xCB,0x2B,0xAB,0x6B,0xEB,0x1B,0x9B,0x5B,0xDB,0x3B,0xBB,0x7B,0xFB,
-      0x07,0x87,0x47,0xC7,0x27,0xA7,0x67,0xE7,0x17,0x97,0x57,0xD7,0x37,0xB7,0x77,0xF7,
-      0x0F,0x8F,0x4F,0xCF,0x2F,0xAF,0x6F,0xEF,0x1F,0x9F,0x5F,0xDF,0x3F,0xBF,0x7F,0xFF,
-    };
-
-CDVDAudioCodecPcm::CDVDAudioCodecPcm() : CDVDAudioCodec()
-{
-  m_iSourceChannels = 0;
-  m_iSourceSampleRate = 0;
-  m_iSourceBitrate = 0;
-  m_decodedDataSize = 0;
-  m_codecID = AV_CODEC_ID_NONE;
-  m_iOutputChannels = 0;
-
-  m_decodedData = NULL;
-  m_decodedDataBufSize = 0;
-  memset(table, 0, sizeof(table));
-}
-
-CDVDAudioCodecPcm::~CDVDAudioCodecPcm()
-{
-  Dispose();
-  delete m_decodedData;
-}
-
-bool CDVDAudioCodecPcm::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
-{
-  SetDefault();
-
-  m_codecID = hints.codec;
-  m_iSourceChannels = hints.channels;
-  m_iSourceSampleRate = hints.samplerate;
-  m_iSourceBitrate = 16;
-
-  switch (m_codecID)
-  {
-    case AV_CODEC_ID_PCM_ALAW:
-    {
-      for (int i = 0; i < 256; i++) table[i] = alaw2linear(i);
-      break;
-    }
-    case AV_CODEC_ID_PCM_MULAW:
-    {
-      for (int i = 0; i < 256; i++) table[i] = ulaw2linear(i);
-      break;
-    }
-    default:
-    {
-      break;
-    }
-  }
-
-  // set desired output
-  m_iOutputChannels = m_iSourceChannels;
-
-  return true;
-}
-
-void CDVDAudioCodecPcm::Dispose()
-{
-}
-
-int CDVDAudioCodecPcm::Decode(uint8_t* pData, int iSize)
-{
-    int n;
-    short *samples;
-    uint8_t *src;
-
-    samples = (short*)m_decodedData;
-    src = pData;
-    int buf_size = iSize;
-
-    if (iSize > m_decodedDataBufSize)
-    {
-        delete m_decodedData;
-        samples = m_decodedData = new short[iSize];
-        if(!m_decodedData)
-            return -1;
-        m_decodedDataBufSize = iSize;
-    }
-
-    switch (m_codecID)
-    {
-    case AV_CODEC_ID_PCM_S32LE:
-        decode_to16(4, 1, 0, &src, &samples, buf_size);
-        break;
-    case AV_CODEC_ID_PCM_S32BE:
-        decode_to16(4, 0, 0, &src, &samples, buf_size);
-        break;
-    case AV_CODEC_ID_PCM_U32LE:
-        decode_to16(4, 1, 1, &src, &samples, buf_size);
-        break;
-    case AV_CODEC_ID_PCM_U32BE:
-        decode_to16(4, 0, 1, &src, &samples, buf_size);
-        break;
-    case AV_CODEC_ID_PCM_S24LE:
-        decode_to16(3, 1, 0, &src, &samples, buf_size);
-        break;
-    case AV_CODEC_ID_PCM_S24BE:
-        decode_to16(3, 0, 0, &src, &samples, buf_size);
-        break;
-    case AV_CODEC_ID_PCM_U24LE:
-        decode_to16(3, 1, 1, &src, &samples, buf_size);
-        break;
-    case AV_CODEC_ID_PCM_U24BE:
-        decode_to16(3, 0, 1, &src, &samples, buf_size);
-        break;
-    case AV_CODEC_ID_PCM_S24DAUD:
-        n = buf_size / 3;
-        for(;n>0;n--) {
-          uint32_t v = src[0] << 16 | src[1] << 8 | src[2];
-          v >>= 4; // sync flags are here
-          *samples++ = ff_reverse[(v >> 8) & 0xff] +
-                       (ff_reverse[v & 0xff] << 8);
-          src += 3;
-        }
-        break;
-    case AV_CODEC_ID_PCM_S16LE:
-        n = buf_size >> 1;
-        for(;n>0;n--) {
-            *samples++ = src[0] | (src[1] << 8);
-            src += 2;
-        }
-        break;
-    case AV_CODEC_ID_PCM_S16BE:
-        n = buf_size >> 1;
-        for(;n>0;n--) {
-            *samples++ = (src[0] << 8) | src[1];
-            src += 2;
-        }
-        break;
-    case AV_CODEC_ID_PCM_U16LE:
-        n = buf_size >> 1;
-        for(;n>0;n--) {
-            *samples++ = (src[0] | (src[1] << 8)) - 0x8000;
-            src += 2;
-        }
-        break;
-    case AV_CODEC_ID_PCM_U16BE:
-        n = buf_size >> 1;
-        for(;n>0;n--) {
-            *samples++ = ((src[0] << 8) | src[1]) - 0x8000;
-            src += 2;
-        }
-        break;
-    case AV_CODEC_ID_PCM_S8:
-        n = buf_size;
-        for(;n>0;n--) {
-            *samples++ = src[0] << 8;
-            src++;
-        }
-        break;
-    case AV_CODEC_ID_PCM_U8:
-        n = buf_size;
-        for(;n>0;n--) {
-            *samples++ = ((int)src[0] - 128) << 8;
-            src++;
-        }
-        break;
-    case AV_CODEC_ID_PCM_ALAW:
-    case AV_CODEC_ID_PCM_MULAW:
-        n = buf_size;
-        for(;n>0;n--) {
-            *samples++ = table[src[0]];
-            src++;
-        }
-        break;
-    default:
-        return -1;
-    }
-
-    m_decodedDataSize = (uint8_t*)samples - (uint8_t*)m_decodedData;
-    return iSize;
-}
-
-int CDVDAudioCodecPcm::GetData(uint8_t** dst)
-{
-  *dst = (uint8_t*)m_decodedData;
-  return m_decodedDataSize;
-}
-
-void CDVDAudioCodecPcm::SetDefault()
-{
-  m_iSourceChannels = 0;
-  m_iSourceSampleRate = 0;
-  m_iSourceBitrate = 0;
-  m_decodedDataSize = 0;
-  m_codecID = AV_CODEC_ID_NONE;
-}
-
-void CDVDAudioCodecPcm::Reset()
-{
-  //SetDefault();
-}
-
-int CDVDAudioCodecPcm::GetChannels()
-{
-  return m_iOutputChannels;
-}
-
-CAEChannelInfo CDVDAudioCodecPcm::GetChannelMap()
-{
-  assert(m_iOutputChannels > 0 && m_iOutputChannels <= 8);
-  static enum AEChannel map[8][9] =
-  {
-    /* MONO   */ {AE_CH_FC, AE_CH_NULL,                                                                      },
-    /* STEREO */ {AE_CH_FL, AE_CH_FR, AE_CH_NULL,                                                            },
-    /* 3.0 ?  */ {AE_CH_FL, AE_CH_FR, AE_CH_FC, AE_CH_NULL,                                                  },
-    /* 4.0 ?  */ {AE_CH_FL, AE_CH_FR, AE_CH_BL, AE_CH_BR , AE_CH_NULL,                                       },
-    /* 5.0    */ {AE_CH_FL, AE_CH_FR, AE_CH_FC, AE_CH_BL , AE_CH_BR, AE_CH_NULL                              },
-    /* 5.1    */ {AE_CH_FL, AE_CH_FR, AE_CH_FC, AE_CH_LFE, AE_CH_BL, AE_CH_BR, AE_CH_NULL,                   },
-    /* 7.0 ?  */ {AE_CH_FL, AE_CH_FR, AE_CH_FC, AE_CH_BL , AE_CH_BR, AE_CH_SL, AE_CH_SR, AE_CH_NULL          },
-    /* 7.1 ?  */ {AE_CH_FL, AE_CH_FR, AE_CH_FC, AE_CH_LFE, AE_CH_BL, AE_CH_BR, AE_CH_SL, AE_CH_SR, AE_CH_NULL}
-  };
-
-  return map[m_iOutputChannels - 1];
-}
-
-int CDVDAudioCodecPcm::GetSampleRate()
-{
-  return m_iSourceSampleRate;
-}
-
-enum AEDataFormat CDVDAudioCodecPcm::GetDataFormat()
-{
-  return AE_FMT_S16NE;
-}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h
deleted file mode 100644
index c2a36d0..0000000
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPcm.h
+++ /dev/null
@@ -1,60 +0,0 @@
-#pragma once
-
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "DVDAudioCodec.h"
-
-class CDVDAudioCodecPcm : public CDVDAudioCodec
-{
-public:
-  CDVDAudioCodecPcm();
-  virtual ~CDVDAudioCodecPcm();
-  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
-  virtual void Dispose();
-  virtual int Decode(uint8_t* pData, int iSize);
-  virtual int GetData(uint8_t** dst);
-  virtual void Reset();
-  virtual int GetChannels();
-  virtual CAEChannelInfo GetChannelMap();
-  virtual int GetSampleRate();
-  virtual enum AEDataFormat GetDataFormat();
-  virtual const char* GetName()  { return "pcm"; }
-
-protected:
-  virtual void SetDefault();
-
-  short* m_decodedData;
-  int m_decodedDataBufSize;
-  int m_decodedDataSize;
-
-  AVCodecID m_codecID;
-  int m_iSourceSampleRate;
-  int m_iSourceChannels;
-  int m_iSourceBitrate;
-
-  int m_iOutputChannels;
-
-  short table[256];
-
-private:
-  CDVDAudioCodecPcm(const CDVDAudioCodecPcm&);
-  CDVDAudioCodecPcm const& operator=(CDVDAudioCodecPcm const&);
-};
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in
index cb6b3d7..6446ee9 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile.in
@@ -3,9 +3,7 @@ INCLUDES+=-I@abs_top_srcdir@/xbmc/cores/dvdplayer
 CXXFLAGS+=-DHAVE_MMX
 
 SRCS  = DVDAudioCodecFFmpeg.cpp
-SRCS += DVDAudioCodecLPcm.cpp
 SRCS += DVDAudioCodecPassthrough.cpp
-SRCS += DVDAudioCodecPcm.cpp
 
 LIB=Audio.a
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 402093d..f77ac40 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -25,6 +25,7 @@
 #include "Video/DVDVideoCodec.h"
 #include "Audio/DVDAudioCodec.h"
 #include "Overlay/DVDOverlayCodec.h"
+#include "cores/dvdplayer/DVDCodecs/DVDCodecs.h"
 
 #if defined(TARGET_DARWIN_OSX)
 #include "Video/DVDVideoCodecVDA.h"
@@ -48,8 +49,6 @@
 #include "android/activity/AndroidFeatures.h"
 #endif
 #include "Audio/DVDAudioCodecFFmpeg.h"
-#include "Audio/DVDAudioCodecPcm.h"
-#include "Audio/DVDAudioCodecLPcm.h"
 #include "Audio/DVDAudioCodecPassthrough.h"
 #include "Overlay/DVDOverlayCodecSSA.h"
 #include "Overlay/DVDOverlayCodecText.h"
@@ -326,54 +325,6 @@ CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint)
   pCodec = OpenCodec( new CDVDAudioCodecPassthrough(), hint, options );
   if( pCodec ) return pCodec;
 
-  switch (hint.codec)
-  {
-  case AV_CODEC_ID_MP2:
-  case AV_CODEC_ID_MP3:
-    {
-      pCodec = OpenCodec( new CDVDAudioCodecFFmpeg(), hint, options );
-      if( pCodec ) return pCodec;
-      break;
-    }
-  case AV_CODEC_ID_PCM_S32LE:
-  case AV_CODEC_ID_PCM_S32BE:
-  case AV_CODEC_ID_PCM_U32LE:
-  case AV_CODEC_ID_PCM_U32BE:
-  case AV_CODEC_ID_PCM_S24LE:
-  case AV_CODEC_ID_PCM_S24BE:
-  case AV_CODEC_ID_PCM_U24LE:
-  case AV_CODEC_ID_PCM_U24BE:
-  case AV_CODEC_ID_PCM_S24DAUD:
-  case AV_CODEC_ID_PCM_S16LE:
-  case AV_CODEC_ID_PCM_S16BE:
-  case AV_CODEC_ID_PCM_U16LE:
-  case AV_CODEC_ID_PCM_U16BE:
-  case AV_CODEC_ID_PCM_S8:
-  case AV_CODEC_ID_PCM_U8:
-  case AV_CODEC_ID_PCM_ALAW:
-  case AV_CODEC_ID_PCM_MULAW:
-    {
-      pCodec = OpenCodec( new CDVDAudioCodecPcm(), hint, options );
-      if( pCodec ) return pCodec;
-      break;
-    }
-#if 0
-  //case AV_CODEC_ID_LPCM_S16BE:
-  //case AV_CODEC_ID_LPCM_S20BE:
-  case AV_CODEC_ID_LPCM_S24BE:
-    {
-      pCodec = OpenCodec( new CDVDAudioCodecLPcm(), hint, options );
-      if( pCodec ) return pCodec;
-      break;
-    }
-#endif
-  default:
-    {
-      pCodec = NULL;
-      break;
-    }
-  }
-
   pCodec = OpenCodec( new CDVDAudioCodecFFmpeg(), hint, options );
   if( pCodec ) return pCodec;
 
-- 
1.9.3


From d9fe1f474f50754d09e48ddac05a15e246fe6f2d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 24 May 2014 19:00:46 +0200
Subject: [PATCH 05/37] AE: let player signal a discontinuity after a clock
 change

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp    | 17 +++++++++++++++--
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h      |  5 ++++-
 .../AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp     | 10 +++++++++-
 .../cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h |  1 +
 .../cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp |  2 +-
 .../AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp     |  6 ++++++
 .../cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h |  2 ++
 xbmc/cores/AudioEngine/Interfaces/AEStream.h            |  5 +++++
 xbmc/cores/dvdplayer/DVDAudio.cpp                       |  9 +++++++++
 xbmc/cores/dvdplayer/DVDAudio.h                         |  1 +
 xbmc/cores/dvdplayer/DVDPlayerAudio.cpp                 | 11 +++++++++--
 11 files changed, 62 insertions(+), 7 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index acca48a..0a291b2 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -45,12 +45,12 @@ void CEngineStats::Reset(unsigned int sampleRate)
   m_playingPTS = 0;
 }
 
-void CEngineStats::UpdateSinkDelay(double delay, int samples, int64_t pts)
+void CEngineStats::UpdateSinkDelay(double delay, int samples, int64_t pts, int clockId)
 {
   CSingleLock lock(m_lock);
   m_sinkUpdate = XbmcThreads::SystemClockMillis();
   m_sinkDelay = delay;
-  m_playingPTS = pts;
+  m_playingPTS = (clockId == m_clockId) ? pts : 0;
   if (samples > m_bufferedSamples)
   {
     CLog::Log(LOGERROR, "CEngineStats::UpdateSinkDelay - inconsistency in buffer time");
@@ -137,6 +137,17 @@ int64_t CEngineStats::GetPlayingPTS()
   return pts;
 }
 
+int CEngineStats::Discontinuity(bool reset)
+{
+  CSingleLock lock(m_lock);
+  m_playingPTS = 0;
+  if (reset)
+    m_clockId = 0;
+  else
+    m_clockId++;
+  return m_clockId;
+}
+
 float CEngineStats::GetWaterLevel()
 {
   CSingleLock lock(m_lock);
@@ -1237,6 +1248,7 @@ CActiveAEStream* CActiveAE::CreateStream(MsgStreamNew *streamMsg)
   stream->m_statsLock = m_stats.GetLock();
   stream->m_fadingSamples = 0;
   stream->m_started = false;
+  stream->m_clockId = m_stats.Discontinuity(true);
 
   if (streamMsg->options & AESTREAM_PAUSED)
     stream->m_paused = true;
@@ -1963,6 +1975,7 @@ bool CActiveAE::RunStages()
           // set pts of last sample
           buf->pkt_start_offset = buf->pkt->nb_samples;
           buf->timestamp = out->timestamp;
+          buf->clockId = out->clockId;
 
           out->Return();
           out = buf;
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
index 467f18e..733551a 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
@@ -160,7 +160,7 @@ class CEngineStats
 {
 public:
   void Reset(unsigned int sampleRate);
-  void UpdateSinkDelay(double delay, int samples, int64_t pts);
+  void UpdateSinkDelay(double delay, int samples, int64_t pts, int clockId = 0);
   void AddSamples(int samples, std::list<CActiveAEStream*> &streams);
   float GetDelay();
   float GetDelay(CActiveAEStream *stream);
@@ -168,6 +168,7 @@ class CEngineStats
   float GetCacheTotal(CActiveAEStream *stream);
   float GetWaterLevel();
   int64_t GetPlayingPTS();
+  int Discontinuity(bool reset = false);
   void SetSuspended(bool state);
   void SetSinkCacheTotal(float time) { m_sinkCacheTotal = time; }
   void SetSinkLatency(float time) { m_sinkLatency = time; }
@@ -176,6 +177,7 @@ class CEngineStats
 protected:
   float m_sinkDelay;
   int64_t m_playingPTS;
+  int m_clockId;
   float m_sinkCacheTotal;
   float m_sinkLatency;
   int m_bufferedSamples;
@@ -246,6 +248,7 @@ class CActiveAE : public IAE, private CThread
   void FreeSoundSample(uint8_t **data);
   float GetDelay(CActiveAEStream *stream) { return m_stats.GetDelay(stream); }
   int64_t GetPlayingPTS() { return m_stats.GetPlayingPTS(); }
+  int Discontinuity() { return m_stats.Discontinuity(); }
   float GetCacheTime(CActiveAEStream *stream) { return m_stats.GetCacheTime(stream); }
   float GetCacheTotal(CActiveAEStream *stream) { return m_stats.GetCacheTotal(stream); }
   void FlushStream(CActiveAEStream *stream);
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
index 56045e2..c1cdf97 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
@@ -44,7 +44,8 @@ CSoundPacket::~CSoundPacket()
 CSampleBuffer::CSampleBuffer() : pkt(NULL), pool(NULL)
 {
   refCount = 0;
-  timestamp = 0.0;
+  timestamp = 0;
+  clockId = -1;
 }
 
 CSampleBuffer::~CSampleBuffer()
@@ -236,7 +237,10 @@ bool CActiveAEBufferPoolResample::ResampleBuffers(double timestamp)
       in = m_inputSamples.front();
       m_inputSamples.pop_front();
       if (timestamp)
+      {
         in->timestamp = timestamp;
+        in->clockId = -1;
+      }
       m_outputSamples.push_back(in);
       busy = true;
     }
@@ -295,11 +299,15 @@ bool CActiveAEBufferPoolResample::ResampleBuffers(double timestamp)
       if (in)
       {
         if (!timestamp)
+        {
           m_lastSamplePts = in->timestamp;
+          m_procSample->clockId = in->clockId;
+        }
         else
         {
           m_lastSamplePts = timestamp;
           in->pkt_start_offset = 0;
+          m_procSample->clockId = -1;
         }
 
         // pts of last sample we added to the buffer
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h
index 008ebdd..ffc307a 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h
@@ -71,6 +71,7 @@ class CSampleBuffer
   CSoundPacket *pkt;
   CActiveAEBufferPool *pool;
   int64_t timestamp;
+  int clockId;
   int pkt_start_offset;
   int refCount;
 };
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index 5d4c6bd..027c7e5 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -847,7 +847,7 @@ unsigned int CActiveAESink::OutputSamples(CSampleBuffer* samples)
       if (pts < 0)
         pts = 0;
     }
-    m_stats->UpdateSinkDelay(sinkDelay, samples->pool ? written : 0, pts);
+    m_stats->UpdateSinkDelay(sinkDelay, samples->pool ? written : 0, pts, samples->clockId);
   }
   return sinkDelay*1000;
 }
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
index 88e4787..1833e9a 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
@@ -218,6 +218,7 @@ unsigned int CActiveAEStream::AddData(uint8_t* const *data, unsigned int offset,
       if (!copied)
       {
         m_currentBuffer->timestamp = pts;
+        m_currentBuffer->clockId = m_clockId;
         m_currentBuffer->pkt_start_offset = m_currentBuffer->pkt->nb_samples;
       }
 
@@ -277,6 +278,11 @@ int64_t CActiveAEStream::GetPlayingPTS()
   return AE.GetPlayingPTS();
 }
 
+void CActiveAEStream::Discontinuity()
+{
+  m_clockId = AE.Discontinuity();
+}
+
 bool CActiveAEStream::IsBuffering()
 {
   CSingleLock lock(m_streamLock);
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
index 927c4d8..8932e98 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
@@ -77,6 +77,7 @@ class CActiveAEStream : public IAEStream
   virtual void FadeVolume(float from, float to, unsigned int time);
   virtual bool IsFading();
   virtual void RegisterSlave(IAEStream *stream);
+  virtual void Discontinuity();
 
 protected:
 
@@ -98,6 +99,7 @@ class CActiveAEStream : public IAEStream
   CSampleBuffer *m_currentBuffer;
   CSoundPacket *m_remapBuffer;
   CActiveAEResample *m_remapper;
+  int m_clockId;
 
   // only accessed by engine
   CActiveAEBufferPool *m_inputBuffers;
diff --git a/xbmc/cores/AudioEngine/Interfaces/AEStream.h b/xbmc/cores/AudioEngine/Interfaces/AEStream.h
index bf9b1d1..052e5a7 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AEStream.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AEStream.h
@@ -233,5 +233,10 @@ class IAEStream
    * Slave a stream to resume when this stream has drained
    */
   virtual void RegisterSlave(IAEStream *stream) = 0;
+
+  /**
+   * Sginal a clock change
+   */
+  virtual void Discontinuity() = 0;
 };
 
diff --git a/xbmc/cores/dvdplayer/DVDAudio.cpp b/xbmc/cores/dvdplayer/DVDAudio.cpp
index 9594912..675c61b 100644
--- a/xbmc/cores/dvdplayer/DVDAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDAudio.cpp
@@ -360,3 +360,12 @@ double CDVDAudio::GetPlayingPts()
 
   return DVD_MSEC_TO_TIME(pts);
 }
+
+void CDVDAudio::Discontinuity()
+{
+  CSingleLock lock (m_critSection);
+  if(!m_pAudioStream)
+    return;
+
+  m_pAudioStream->Discontinuity();
+}
diff --git a/xbmc/cores/dvdplayer/DVDAudio.h b/xbmc/cores/dvdplayer/DVDAudio.h
index 8c13719..fec9a24 100644
--- a/xbmc/cores/dvdplayer/DVDAudio.h
+++ b/xbmc/cores/dvdplayer/DVDAudio.h
@@ -80,6 +80,7 @@ class CDVDAudio
   void Flush();
   void Finish();
   void Drain();
+  void Discontinuity();
 
   void SetSpeed(int iSpeed);
   void SetResampleRatio(double ratio);
diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
index 174660d..2183b43 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
@@ -359,7 +359,12 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe)
 
       m_ptsInput.Flush();
       if (pMsgGeneralResync->m_clock)
-        m_pClock->Discontinuity(m_dvdAudio.GetPlayingPts());
+      {
+        if (m_dvdAudio.GetPlayingPts() != DVD_NOPTS_VALUE)
+          m_pClock->Discontinuity(m_dvdAudio.GetPlayingPts());
+        else
+          m_pClock->Discontinuity(m_audioClock);
+      }
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_RESET))
     {
@@ -634,6 +639,7 @@ void CDVDPlayerAudio::HandleSyncError(double duration)
     m_errors.Flush();
     m_error = 0;
     m_syncclock = false;
+    m_dvdAudio.Discontinuity();
 
     return;
   }
@@ -664,7 +670,8 @@ void CDVDPlayerAudio::HandleSyncError(double duration)
         error = m_error;
       }
 
-      m_pClock->Update(clock+error, absolute, limit - 0.001, "CDVDPlayerAudio::HandleSyncError2");
+      if (m_pClock->Update(clock+error, absolute, limit - 0.001, "CDVDPlayerAudio::HandleSyncError2"))
+        m_dvdAudio.Discontinuity();
     }
     else if (m_synctype == SYNC_RESAMPLE)
     {
-- 
1.9.3


From 2da861b243fb59a7e22310526a968ae1308e682c Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 24 May 2014 20:17:30 +0200
Subject: [PATCH 06/37] dvdplayer audio: remove obsolte methods and useless
 locks

---
 xbmc/cores/dvdplayer/DVDAudio.cpp       | 21 ---------------------
 xbmc/cores/dvdplayer/DVDAudio.h         |  2 --
 xbmc/cores/dvdplayer/DVDPlayerAudio.cpp |  3 ---
 3 files changed, 26 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDAudio.cpp b/xbmc/cores/dvdplayer/DVDAudio.cpp
index 675c61b..9c543ab 100644
--- a/xbmc/cores/dvdplayer/DVDAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDAudio.cpp
@@ -282,17 +282,6 @@ void CDVDAudio::Resume()
   if (m_pAudioStream) m_pAudioStream->Resume();
 }
 
-double CDVDAudio::GetDelay()
-{
-  CSingleLock lock (m_critSection);
-
-  double delay = 0.0;
-  if(m_pAudioStream)
-    delay = m_pAudioStream->GetDelay();
-
-  return delay * DVD_TIME_BASE;
-}
-
 void CDVDAudio::Flush()
 {
   CSingleLock lock (m_critSection);
@@ -340,17 +329,8 @@ double CDVDAudio::GetCacheTime()
   return delay;
 }
 
-double CDVDAudio::GetCacheTotal()
-{
-  CSingleLock lock (m_critSection);
-  if(!m_pAudioStream)
-    return 0.0;
-  return m_pAudioStream->GetCacheTotal();
-}
-
 double CDVDAudio::GetPlayingPts()
 {
-  CSingleLock lock (m_critSection);
   if(!m_pAudioStream)
     return DVD_NOPTS_VALUE;
 
@@ -363,7 +343,6 @@ double CDVDAudio::GetPlayingPts()
 
 void CDVDAudio::Discontinuity()
 {
-  CSingleLock lock (m_critSection);
   if(!m_pAudioStream)
     return;
 
diff --git a/xbmc/cores/dvdplayer/DVDAudio.h b/xbmc/cores/dvdplayer/DVDAudio.h
index fec9a24..7023c75 100644
--- a/xbmc/cores/dvdplayer/DVDAudio.h
+++ b/xbmc/cores/dvdplayer/DVDAudio.h
@@ -72,11 +72,9 @@ class CDVDAudio
   bool IsValidFormat(const DVDAudioFrame &audioframe);
   void Destroy();
   unsigned int AddPackets(const DVDAudioFrame &audioframe);
-  double GetDelay(); // returns the time it takes to play a packet if we add one at this time
   double GetPlayingPts();
   void   SetPlayingPts(double pts);
   double GetCacheTime();  // returns total amount of data cached in audio output at this time
-  double GetCacheTotal(); // returns total amount the audio device can buffer
   void Flush();
   void Finish();
   void Drain();
diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
index 2183b43..0e4eeec 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
@@ -580,9 +580,6 @@ void CDVDPlayerAudio::Process()
       m_messageParent.Put(new CDVDMsgInt(CDVDMsg::PLAYER_STARTED, DVDPLAYER_AUDIO));
     }
 
-    if( m_dvdAudio.GetPlayingPts() == DVD_NOPTS_VALUE )
-      continue;
-
     if( m_speed != DVD_PLAYSPEED_NORMAL )
       continue;
 
-- 
1.9.3


From 288c027f4e238995e6bf9b407a5ff4b2a1c270c2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 28 May 2014 10:41:27 +0200
Subject: [PATCH 07/37] WASAPI: fall back to float if engine requests a planar
 format

---
 xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
index 31c3588..a17352d 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
@@ -1005,8 +1005,14 @@ bool CAESinkWASAPI::InitializeExclusive(AEAudioFormat &format)
 
   if (format.m_dataFormat <= AE_FMT_FLOAT)
     BuildWaveFormatExtensible(format, wfxex);
-  else
+  else if (AE_IS_RAW(format.m_dataFormat))
     BuildWaveFormatExtensibleIEC61397(format, wfxex_iec61937);
+  else
+  {
+    // planar formats are currently not supported by this sink
+    format.m_dataFormat = AE_FMT_FLOAT;
+    BuildWaveFormatExtensible(format, wfxex);
+  }
 
   /* Test for incomplete format and provide defaults */
   if (format.m_sampleRate == 0 ||
-- 
1.9.3


From 3ffc519ef58c12dd4a0a47b9c61398a5e4d8cf11 Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Wed, 28 May 2014 09:20:33 +0200
Subject: [PATCH 08/37] AESinkPULSE: Correctly handle unsupported formats and
 fallback to float

---
 xbmc/cores/AudioEngine/Sinks/AESinkPULSE.cpp | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPULSE.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPULSE.cpp
index 4adfd46..dcb31f1 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPULSE.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPULSE.cpp
@@ -484,6 +484,14 @@ bool CAESinkPULSE::Initialize(AEAudioFormat &format, std::string &device)
   struct pa_channel_map map;
   pa_channel_map_init(&map);
 
+   // PULSE cannot cope with e.g. planar formats so we fallback to FLOAT
+   // when we receive an invalid pulse format
+   if (AEFormatToPulseFormat(format.m_dataFormat) == PA_SAMPLE_INVALID)
+   {
+     CLog::Log(LOGDEBUG, "PULSE does not support format: %s - will fallback to AE_FMT_FLOAT", CAEUtil::DataFormatToStr(format.m_dataFormat));
+     format.m_dataFormat = AE_FMT_FLOAT;
+   }
+
   m_passthrough = AE_IS_RAW(format.m_dataFormat);
 
   if(m_passthrough)
-- 
1.9.3


From 7630fd6e771b98a1b8e001a1e8a59368783c005d Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:34:39 +0200
Subject: [PATCH 09/37] videoplayer: adapt lateness detection and dropping to
 buffering

---
 xbmc/cores/VideoRenderers/RenderManager.cpp        |  16 +-
 xbmc/cores/VideoRenderers/RenderManager.h          |  12 +-
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |  38 +++-
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp        |  41 +++++
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.h          |   7 +
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            | 197 +++++++++++++++++----
 xbmc/cores/dvdplayer/DVDPlayerVideo.h              |  23 +++
 7 files changed, 296 insertions(+), 38 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 6832721..f4b381e 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -286,6 +286,8 @@ bool CXBMCRenderManager::Configure(unsigned int width, unsigned int height, unsi
     m_bIsStarted = true;
     m_bReconfigured = true;
     m_presentstep = PRESENT_IDLE;
+    m_presentpts = DVD_NOPTS_VALUE;
+    m_sleeptime = 1.0;
     m_presentevent.notifyAll();
 
     m_firstFlipPage = false;  // tempfix
@@ -629,7 +631,7 @@ void CXBMCRenderManager::SetViewMode(int iViewMode)
     m_pRenderer->SetViewMode(iViewMode);
 }
 
-void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
+void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, double pts /* = 0 */, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
 {
   { CSharedLock lock(m_sharedSection);
 
@@ -697,6 +699,7 @@ void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0L
     m.timestamp     = timestamp;
     m.presentfield  = sync;
     m.presentmethod = presentmethod;
+    m.pts           = pts;
     requeue(m_queued, m_free);
 
     /* signal to any waiters to check state */
@@ -1065,6 +1068,8 @@ void CXBMCRenderManager::PrepareNextRender()
     m_discard.push_back(m_presentsource);
     m_presentsource = idx;
     m_queued.pop_front();
+    m_sleeptime = m_Queue[idx].timestamp - clocktime;
+    m_presentpts = m_Queue[idx].pts;
     m_presentevent.notifyAll();
   }
 }
@@ -1081,3 +1086,12 @@ void CXBMCRenderManager::DiscardBuffer()
     m_presentstep   = PRESENT_IDLE;
   m_presentevent.notifyAll();
 }
+
+bool CXBMCRenderManager::GetStats(double &sleeptime, double &pts, int &bufferLevel)
+{
+  CSingleLock lock(m_presentlock);
+  sleeptime = m_sleeptime;
+  pts = m_presentpts;
+  bufferLevel = m_queued.size() + m_discard.size();
+  return true;
+}
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index c469795..949c652b 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -98,10 +98,11 @@ class CXBMCRenderManager
    *
    * @param bStop reference to stop flag of calling thread
    * @param timestamp of frame delivered with AddVideoPicture
+   * @param pts used for lateness detection
    * @param source depreciated
    * @param sync signals frame, top, or bottom field
    */
-  void FlipPage(volatile bool& bStop, double timestamp = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
+  void FlipPage(volatile bool& bStop, double timestamp = 0.0, double pts = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
   unsigned int PreInit();
   void UnInit();
   bool Flush();
@@ -176,6 +177,12 @@ class CXBMCRenderManager
   int WaitForBuffer(volatile bool& bStop, int timeout = 100);
 
   /**
+   * Can be called by player for lateness detection. This is done best by
+   * looking at the end of the queue.
+   */
+  bool GetStats(double &sleeptime, double &pts, int &bufferLevel);
+
+  /**
    * Video player call this on flush in oder to discard any queued frames
    */
   void DiscardBuffer();
@@ -222,6 +229,7 @@ class CXBMCRenderManager
 
   struct SPresent
   {
+    double         pts;
     double         timestamp;
     EFIELDSYNC     presentfield;
     EPRESENTMETHOD presentmethod;
@@ -233,6 +241,8 @@ class CXBMCRenderManager
 
   ERenderFormat   m_format;
 
+  double     m_sleeptime;
+  double     m_presentpts;
   double     m_presentcorr;
   double     m_presenterr;
   double     m_errorbuff[ERRORBUFFSIZE];
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 741017d..c5b24d6 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -136,6 +136,10 @@ struct DVDVideoUserData
 #define DVP_FLAG_NOSKIP             0x00000010 // indicate this picture should never be dropped
 #define DVP_FLAG_DROPPED            0x00000020 // indicate that this picture has been dropped in decoder stage, will have no data
 
+#define DVP_FLAG_DROPDEINT          0x00000040 // indicate that this picture was requested to have been dropped in deint stage
+#define DVP_FLAG_NO_POSTPROC        0x00000100 // see GetCodecStats
+#define DVP_FLAG_DRAIN              0x00000200 // see GetCodecStats
+
 // DVP_FLAG 0x00000100 - 0x00000f00 is in use by libmpeg2!
 
 #define DVP_QSCALE_UNKNOWN          0
@@ -153,6 +157,8 @@ class CDVDCodecOptions;
 #define VC_PICTURE  0x00000004  // the decoder got a picture, call Decode(NULL, 0) again to parse the rest of the data
 #define VC_USERDATA 0x00000008  // the decoder found some userdata,  call Decode(NULL, 0) again to parse the rest of the data
 #define VC_FLUSHED  0x00000010  // the decoder lost it's state, we need to restart decoding again
+#define VC_DROPPED  0x00000020  // needed to identify if a picture was dropped
+
 class CDVDVideoCodec
 {
 public:
@@ -270,7 +276,6 @@ class CDVDVideoCodec
     return 0;
   }
 
-
   /**
    * Number of references to old pictures that are allowed to
    * be retained when calling decode on the next demux packet
@@ -287,4 +292,35 @@ class CDVDVideoCodec
   * Interact with user settings so that user disabled codecs are disabled
   */
   static bool IsCodecDisabled(DVDCodecAvailableType* map, unsigned int size, AVCodecID id);
+
+   /* For calculation of dropping requirements player asks for some information.
+   *
+   * - pts : right after decoder, used to detect gaps (dropped frames in decoder)
+   * - droppedPics : indicates if decoder has dropped a picture
+   *                 -1 means that decoder has no info on this.
+   *
+   * If codec does not implement this method, pts of decoded frame at input
+   * video player is used. In case decoder does post-proc and de-interlacing there
+   * may be quite some frames queued up between exit decoder and entry player.
+   */
+  virtual bool GetCodecStats(double &pts, int &droppedPics)
+  {
+    droppedPics= -1;
+    return false;
+  }
+
+  /**
+   * Codec can be informed by player with the following flags:
+   *
+   * DVP_FLAG_NO_POSTPROC : if speed is not normal the codec can switch off
+   *                        postprocessing and de-interlacing
+   *
+   * DVP_FLAG_DRAIN : codecs may do postprocessing and de-interlacing.
+   *                  If video buffers in RenderManager are about to run dry,
+   *                  this is signaled to codec. Codec can wait for post-proc
+   *                  to be finished instead of returning empty and getting another
+   *                  packet.
+   *
+   */
+  virtual void SetCodecControl(int flags) {}
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index b6c1e04..c48108f 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -167,6 +167,7 @@ CDVDVideoCodecFFmpeg::CDVDVideoCodecFFmpeg() : CDVDVideoCodec()
   m_iLastKeyframe = 0;
   m_dts = DVD_NOPTS_VALUE;
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
 }
 
 CDVDVideoCodecFFmpeg::~CDVDVideoCodecFFmpeg()
@@ -342,6 +343,14 @@ void CDVDVideoCodecFFmpeg::SetDropState(bool bDrop)
 {
   if( m_pCodecContext )
   {
+    if (bDrop && m_pHardware && m_pHardware->CanSkipDeint())
+    {
+      m_requestSkipDeint = true;
+      bDrop = false;
+    }
+    else
+      m_requestSkipDeint = false;
+
     // i don't know exactly how high this should be set
     // couldn't find any good docs on it. think it varies
     // from codec to codec on what it does
@@ -543,6 +552,7 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
 void CDVDVideoCodecFFmpeg::Reset()
 {
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
   m_iLastKeyframe = m_pCodecContext->has_b_frames;
   avcodec_flush_buffers(m_pCodecContext);
 
@@ -640,6 +650,22 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
   else
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 
+  if (pDvdVideoPicture->pts != DVD_NOPTS_VALUE)
+    m_decoderPts = pDvdVideoPicture->pts;
+  else
+    m_decoderPts = m_dts;
+
+  if (m_requestSkipDeint)
+  {
+    pDvdVideoPicture->iFlags |= DVP_FLAG_DROPDEINT;
+    m_skippedDeint = 1;
+  }
+  else
+    m_skippedDeint = 0;
+
+  m_requestSkipDeint = false;
+  pDvdVideoPicture->iFlags |= m_codecControlFlags;
+
   if(!m_started)
     pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
 
@@ -821,3 +847,18 @@ unsigned CDVDVideoCodecFFmpeg::GetAllowedReferences()
   else
     return 0;
 }
+
+bool CDVDVideoCodecFFmpeg::GetCodecStats(double &pts, int &droppedPics)
+{
+  pts = m_decoderPts;
+  if (m_skippedDeint)
+    droppedPics = m_skippedDeint;
+  else
+    droppedPics = -1;
+  return true;
+}
+
+void CDVDVideoCodecFFmpeg::SetCodecControl(int flags)
+{
+  m_codecControlFlags = flags;
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
index 75ac0f2..1a80a48 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
@@ -50,6 +50,7 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
     virtual int  Check     (AVCodecContext* avctx) = 0;
     virtual void Reset     () {}
     virtual unsigned GetAllowedReferences() { return 0; }
+    virtual bool CanSkipDeint() {return false; }
     virtual const std::string Name() = 0;
     virtual CCriticalSection* Section() { return NULL; }
   };
@@ -67,6 +68,8 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
   virtual unsigned GetConvergeCount();
   virtual unsigned GetAllowedReferences();
+  virtual bool GetCodecStats(double &pts, int &droppedPics);
+  virtual void SetCodecControl(int flags);
 
   bool               IsHardwareAllowed()                     { return !m_bSoftware; }
   IHardwareDecoder * GetHardware()                           { return m_pHardware; };
@@ -122,4 +125,8 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   double m_dts;
   bool   m_started;
   std::vector<PixelFormat> m_formats;
+  double m_decoderPts, m_decoderInterval;
+  int    m_skippedDeint;
+  bool   m_requestSkipDeint;
+  int    m_codecControlFlags;
 };
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 7e88bfc..6f3b0dd 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -38,6 +38,7 @@
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDCodecs/Overlay/DVDOverlayCodecCC.h"
 #include "DVDCodecs/Overlay/DVDOverlaySSA.h"
+#include "guilib/GraphicContext.h"
 #include <sstream>
 #include <iomanip>
 #include <numeric>
@@ -317,8 +318,10 @@ void CDVDPlayerVideo::Process()
 
   int iDropped = 0; //frames dropped in a row
   bool bRequestDrop = false;
+  int iDropDirective;
 
   m_videoStats.Start();
+  m_droppingStats.Reset();
 
   while (!m_bStop)
   {
@@ -430,6 +433,7 @@ void CDVDPlayerVideo::Process()
       picture.iFlags &= ~DVP_FLAG_ALLOCATED;
       m_packets.clear();
       m_started = false;
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH)) // private message sent by (CDVDPlayerVideo::Flush())
     {
@@ -442,6 +446,7 @@ void CDVDPlayerVideo::Process()
       //we need to recalculate the framerate
       //TODO: this needs to be set on a streamchange instead
       ResetFrameRateCalc();
+      m_droppingStats.Reset();
 
       m_stalled = true;
       m_started = false;
@@ -461,6 +466,7 @@ void CDVDPlayerVideo::Process()
         m_iNrOfPicturesNotToSkip = 0;
       if (m_pVideoCodec)
         m_pVideoCodec->SetSpeed(m_speed);
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
@@ -506,6 +512,28 @@ void CDVDPlayerVideo::Process()
         m_iNrOfPicturesNotToSkip = 1;
       }
 
+      bRequestDrop = false;
+      iDropDirective = CalcDropRequirement(pts);
+      if (iDropDirective & EOS_VERYLATE)
+      {
+        if (m_bAllowDrop)
+        {
+          m_pullupCorrection.Flush();
+          bRequestDrop = true;
+        }
+      }
+      int codecControl = 0;
+      if (iDropDirective & EOS_BUFFER_LEVEL)
+        codecControl |= DVP_FLAG_DRAIN;
+      if (m_speed > DVD_PLAYSPEED_NORMAL)
+        codecControl |= DVP_FLAG_NO_POSTPROC;
+      m_pVideoCodec->SetCodecControl(codecControl);
+      if (iDropDirective & EOS_DROPPED)
+      {
+        m_iDroppedFrames++;
+        iDropped++;
+      }
+
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
@@ -558,15 +586,7 @@ void CDVDPlayerVideo::Process()
       }
 
       m_videoStats.AddSampleBytes(pPacket->iSize);
-      // assume decoder dropped a picture if it didn't give us any
-      // picture from a demux packet, this should be reasonable
-      // for libavformat as a demuxer as it normally packetizes
-      // pictures when they come from demuxer
-      if(bRequestDrop && !bPacketDrop && (iDecoderState & VC_BUFFER) && !(iDecoderState & VC_PICTURE))
-      {
-        m_iDroppedFrames++;
-        iDropped++;
-      }
+
       // reset the request, the following while loop may break before
       // setting the flag to a new value
       bRequestDrop = false;
@@ -1180,33 +1200,12 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
   m_FlipTimeStamp += max(0.0, iSleepTime);
   m_FlipTimePts    = pts;
 
-  if (iSleepTime <= 0 && m_speed)
-    m_iLateFrames++;
-  else
-    m_iLateFrames = 0;
-
-  // ask decoder to drop frames next round, as we are very late
-  if(m_iLateFrames > 10)
+  if ((pPicture->iFlags & DVP_FLAG_DROPPED))
   {
-    if (!(pPicture->iFlags & DVP_FLAG_NOSKIP))
-    {
-      //if we're calculating the framerate,
-      //don't drop frames until we've calculated a stable framerate
-      if (m_bAllowDrop || m_speed != DVD_PLAYSPEED_NORMAL)
-      {
-        result |= EOS_VERYLATE;
-        m_pullupCorrection.Flush(); //dropped frames mess up the pattern, so just flush it
-      }
-      m_iDroppedRequest++;
-    }
-  }
-  else
-  {
-    m_iDroppedRequest = 0;
-  }
-
-  if( (pPicture->iFlags & DVP_FLAG_DROPPED) )
+    m_droppingStats.AddOutputDropGain(pts, 1/m_fFrameRate);
+    CLog::Log(LOGDEBUG,"%s - dropped in output", __FUNCTION__);
     return result | EOS_DROPPED;
+  }
 
   // set fieldsync if picture is interlaced
   EFIELDSYNC mDisplayField = FS_NONE;
@@ -1239,7 +1238,7 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
   if (index < 0)
     return EOS_DROPPED;
 
-  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, -1, mDisplayField);
+  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, pts, -1, mDisplayField);
 
   return result;
 #else
@@ -1539,3 +1538,131 @@ void CDVDPlayerVideo::CalcFrameRate()
     m_iFrameRateCount = 0;
   }
 }
+
+int CDVDPlayerVideo::CalcDropRequirement(double pts)
+{
+  int result = 0;
+  double iSleepTime;
+  double iDecoderPts, iRenderPts;
+  double iInterval;
+  double iGain;
+  double iLateness;
+  bool   bNewFrame;
+  int    iDroppedPics = -1;
+  int    iBufferLevel;
+
+  // get decoder stats
+  if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iDroppedPics))
+    iDecoderPts = pts;
+  if (iDecoderPts == DVD_NOPTS_VALUE)
+    iDecoderPts = pts;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if (iBufferLevel < 0)
+    result |= EOS_BUFFER_LEVEL;
+  else if (iBufferLevel < 2)
+  {
+    result |= EOS_BUFFER_LEVEL;
+    CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - hurry: %d", iBufferLevel);
+  }
+
+  bNewFrame = iDecoderPts != m_droppingStats.m_lastDecoderPts;
+
+  iInterval = 1/m_fFrameRate*(double)DVD_TIME_BASE;
+
+  m_FlipTimeStamp = m_pClock->GetAbsoluteClock() + max(0.0, iSleepTime) + iInterval;
+
+  if (m_stalled)
+    m_iCurrentPts = DVD_NOPTS_VALUE;
+  else
+    m_iCurrentPts = iRenderPts - max(0.0, iSleepTime);
+
+  if (m_droppingStats.m_lastDecoderPts > 0
+      && bNewFrame
+      && m_bAllowDrop)
+  {
+    iGain = (iDecoderPts - m_droppingStats.m_lastDecoderPts - iInterval)/(double)DVD_TIME_BASE;
+    if (iDroppedPics > 0)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = iDroppedPics * 1/m_fFrameRate;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += gain.gain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped pictures, Sleeptime: %f, Bufferlevel: %d, Gain: %f", iSleepTime, iBufferLevel, iGain);
+    }
+    else if (iDroppedPics < 0 && iGain > 1/m_fFrameRate)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = iGain;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += iGain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped in decoder, Sleeptime: %f, Bufferlevel: %d, Gain: %f", iSleepTime, iBufferLevel, iGain);
+    }
+  }
+  m_droppingStats.m_lastDecoderPts = iDecoderPts;
+
+  // subtract gains
+  while (!m_droppingStats.m_gain.empty() &&
+         iRenderPts >= m_droppingStats.m_gain.front().pts)
+  {
+    m_droppingStats.m_totalGain -= m_droppingStats.m_gain.front().gain;
+    m_droppingStats.m_gain.pop_front();
+  }
+
+  // calculate lateness
+  iLateness = iSleepTime + m_droppingStats.m_totalGain;
+  if (iLateness < 0 && m_speed)
+  {
+    if (bNewFrame)
+      m_droppingStats.m_lateFrames++;
+
+    // if lateness is smaller than frametime, we observe this state
+    // for 10 cycles
+    if (m_droppingStats.m_lateFrames > 10 || iLateness < -2/m_fFrameRate)
+    {
+      // is frame allowed to skip
+      if (m_iNrOfPicturesNotToSkip <= 0)
+      {
+        if (bNewFrame || m_droppingStats.m_dropRequests < 5)
+        {
+          result |= EOS_VERYLATE;
+        }
+        m_droppingStats.m_dropRequests++;
+      }
+    }
+  }
+  else
+  {
+    m_droppingStats.m_dropRequests = 0;
+    m_droppingStats.m_lateFrames = 0;
+  }
+  m_droppingStats.m_lastRenderPts = iRenderPts;
+  return result;
+}
+
+void CDroppingStats::Reset()
+{
+  m_gain.clear();
+  m_totalGain = 0;
+  m_lastDecoderPts = 0;
+  m_lastRenderPts = 0;
+  m_lateFrames = 0;
+  m_dropRequests = 0;
+}
+
+void CDroppingStats::AddOutputDropGain(double pts, double frametime)
+{
+  CDroppingStats::CGain gain;
+  gain.gain = frametime;
+  gain.pts = pts;
+  m_gain.push_back(gain);
+  m_totalGain += frametime;
+}
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 9e578bf..fcbdd3d 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -36,6 +36,25 @@ class CDVDOverlayCodecCC;
 
 #define VIDEO_PICTURE_QUEUE_SIZE 1
 
+class CDroppingStats
+{
+public:
+  void Reset();
+  void AddOutputDropGain(double pts, double frametime);
+  struct CGain
+  {
+    double gain;
+    double pts;
+  };
+  std::deque<CGain> m_gain;
+  double m_totalGain;
+  double m_lastDecoderPts;
+  double m_lastRenderPts;
+  unsigned int m_lateFrames;
+  unsigned int m_dropRequests;
+};
+
+
 class CDVDPlayerVideo : public CThread
 {
 public:
@@ -104,6 +123,7 @@ class CDVDPlayerVideo : public CThread
 #define EOS_ABORT 1
 #define EOS_DROPPED 2
 #define EOS_VERYLATE 4
+#define EOS_BUFFER_LEVEL 8
 
   void AutoCrop(DVDVideoPicture* pPicture);
   void AutoCrop(DVDVideoPicture *pPicture, RECT &crop);
@@ -130,6 +150,7 @@ class CDVDPlayerVideo : public CThread
 
   void   ResetFrameRateCalc();
   void   CalcFrameRate();
+  int    CalcDropRequirement(double pts);
 
   double m_fFrameRate;       //framerate of the video currently playing
   bool   m_bCalcFrameRate;  //if we should calculate the framerate from the timestamps
@@ -183,5 +204,7 @@ class CDVDPlayerVideo : public CThread
   CPullupCorrection m_pullupCorrection;
 
   std::list<DVDMessageListItem> m_packets;
+
+  CDroppingStats m_droppingStats;
 };
 
-- 
1.9.3


From 068cdbf74a5eca286dfc91d39a4d34c753613cd7 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 2 Sep 2012 16:05:21 +0200
Subject: [PATCH 10/37] video player: present correct pts to user for a/v sync
 (after buffering in renderer)

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 16 ++++++++++++++++
 xbmc/cores/dvdplayer/DVDPlayerVideo.h   |  2 +-
 2 files changed, 17 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 6f3b0dd..8f31a2c 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1458,6 +1458,22 @@ void CDVDPlayerVideo::ResetFrameRateCalc()
                         g_advancedSettings.m_videoFpsDetect == 0;
 }
 
+double CDVDPlayerVideo::GetCurrentPts()
+{
+  double iSleepTime, iRenderPts;
+  int iBufferLevel;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if( m_stalled )
+    iRenderPts = DVD_NOPTS_VALUE;
+  else
+    iRenderPts = iRenderPts - max(0.0, iSleepTime);
+
+  return iRenderPts;
+}
+
 #define MAXFRAMERATEDIFF   0.01
 #define MAXFRAMESERR    1000
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index fcbdd3d..51962fa 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -100,7 +100,7 @@ class CDVDPlayerVideo : public CThread
 
   bool InitializedOutputDevice();
 
-  double GetCurrentPts()                           { return m_iCurrentPts; }
+  double GetCurrentPts();
   int    GetPullupCorrection()                     { return m_pullupCorrection.GetPatternLength(); }
 
   double GetOutputDelay(); /* returns the expected delay, from that a packet is put in queue */
-- 
1.9.3


From 183929f793343f450d73a1ce716a29f59cc9bdb6 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 1 Jun 2013 11:21:19 +0200
Subject: [PATCH 11/37] renderer: bump buffers to 5

---
 xbmc/cores/VideoRenderers/BaseRenderer.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index fb41ccf..f5e5677 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -29,7 +29,7 @@
 
 #define MAX_PLANES 3
 #define MAX_FIELDS 3
-#define NUM_BUFFERS 3
+#define NUM_BUFFERS 5
 
 class CSetting;
 
-- 
1.9.3


From ed9f3ab8bbbfbaea961d5fc568b449ef50ac2440 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:41:31 +0200
Subject: [PATCH 12/37] videoplayer: update frametime, it might change due to
 fps detection

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 8f31a2c..759f39f 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -706,6 +706,8 @@ void CDVDPlayerVideo::Process()
 
             int iResult = OutputPicture(&picture, pts);
 
+            frametime = (double)DVD_TIME_BASE/m_fFrameRate;
+
             if(m_started == false)
             {
               m_codecname = m_pVideoCodec->GetName();
-- 
1.9.3


From 394d504300781f1e98952211d697aff5d5279257 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:43:06 +0200
Subject: [PATCH 13/37] videoplayer: give streams with invalid fps a chance for
 fps detection

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 759f39f..14aaf6b 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1500,7 +1500,7 @@ void CDVDPlayerVideo::CalcFrameRate()
   double frameduration = m_pullupCorrection.GetFrameDuration();
 
   if (frameduration == DVD_NOPTS_VALUE ||
-      (g_advancedSettings.m_videoFpsDetect == 1 && m_pullupCorrection.GetPatternLength() > 1))
+      (g_advancedSettings.m_videoFpsDetect == 1 && (m_pullupCorrection.GetPatternLength() > 1 && !m_bFpsInvalid)))
   {
     //reset the stored framerates if no good framerate was detected
     m_fStableFrameRate = 0.0;
-- 
1.9.3


From 4f7656c9137946f20c271515e946cdcba5299f6c Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:49:05 +0200
Subject: [PATCH 14/37] dvdplayer: allow rewinding at end of stream, do a seek
 after rewind

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 8aaef28..559ed82 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1634,7 +1634,7 @@ void CDVDPlayer::HandlePlaySpeed()
 
     }
     else if (m_CurrentVideo.id >= 0
-          &&  m_CurrentVideo.inited == true
+          &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
           &&  m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts()
           &&  m_SpeedState.lasttime != GetTime())
     {
@@ -2296,6 +2296,12 @@ void CDVDPlayer::HandleMessages()
           pvrinputstream->Pause( speed == 0 );
         }
 
+        // do a seek after rewind, clock is not in sync with current pts
+        if (m_playSpeed < 0 && speed >= 0)
+        {
+          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true));
+        }
+
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
         // audioplayer, stops outputing audio to audiorendere, but still tries to
         // sleep an correct amount for each packet
-- 
1.9.3


From 1334bd1212a83d9c2394d5eed6c52c997fc5f87a Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 20 Aug 2012 16:06:39 +0200
Subject: [PATCH 15/37] dvdplayer: observe pts counter overflow

---
 .../cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 197 ++++++++++++++++++++-
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h  |   4 +
 2 files changed, 200 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 710482f..49eff5c 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -18,7 +18,6 @@
  *
  */
 
-#include "system.h"
 #ifndef __STDC_CONSTANT_MACROS
 #define __STDC_CONSTANT_MACROS
 #endif
@@ -26,6 +25,7 @@
 #define __STDC_LIMIT_MACROS
 #endif
 #ifdef TARGET_POSIX
+#include "system.h"
 #include "stdint.h"
 #endif
 #include "DVDDemuxFFmpeg.h"
@@ -427,6 +427,9 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
 
   CreateStreams();
 
+  m_bPtsWrapChecked = false;
+  m_bPtsWrap = false;
+
   return true;
 }
 
@@ -568,6 +571,12 @@ double CDVDDemuxFFmpeg::ConvertTimestamp(int64_t pts, int den, int num)
   if (pts == (int64_t)AV_NOPTS_VALUE)
     return DVD_NOPTS_VALUE;
 
+  if (m_bPtsWrap)
+  {
+    if (pts < m_iStartTime && pts < m_iEndTime)
+      pts += m_iMaxTime;
+  }
+
   // do calculations in floats as they can easily overflow otherwise
   // we don't care for having a completly exact timestamp anyway
   double timestamp = (double)pts * num  / den;
@@ -707,6 +716,24 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
           m_pkt.pkt.pts = AV_NOPTS_VALUE;
         }
 
+        if (!m_bPtsWrapChecked && m_pFormatContext->iformat->flags & AVFMT_TS_DISCONT)
+        {
+          int defaultStream = av_find_default_stream_index(m_pFormatContext);
+          int64_t duration = m_pFormatContext->streams[defaultStream]->duration * 1.5;
+          m_iMaxTime = 1LL<<m_pFormatContext->streams[defaultStream]->pts_wrap_bits;
+          m_iStartTime = m_pFormatContext->streams[defaultStream]->start_time;
+          if (m_iStartTime != DVD_NOPTS_VALUE)
+          {
+            m_iEndTime = (m_iStartTime + duration) & ~m_iMaxTime;
+            if (m_iEndTime < m_iStartTime)
+            {
+              CLog::Log(LOGNOTICE,"CDVDDemuxFFmpeg::Read - file contains pts overflow");
+              m_bPtsWrap = true;
+            }
+          }
+          m_bPtsWrapChecked = true;
+        }
+
         // copy contents into our own packet
         pPacket->iSize = m_pkt.pkt.size;
 
@@ -840,7 +867,16 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
     ret = av_seek_frame(m_pFormatContext, -1, seek_pts, backwords ? AVSEEK_FLAG_BACKWARD : 0);
 
     if(ret >= 0)
+    {
       UpdateCurrentPTS();
+
+      // seek may fail silently on streams which allow discontinuity
+      // if current timestamp is way off asume a pts overflow and try bisect seek
+      if (m_bPtsWrap && fabs(time - m_iCurrentPts/1000) > 10000)
+      {
+        ret = SeekTimeDiscont(seek_pts, backwords) ? 1 : -1;
+      }
+    }
   }
 
   if(m_iCurrentPts == DVD_NOPTS_VALUE)
@@ -859,6 +895,165 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
   return (ret >= 0);
 }
 
+bool CDVDDemuxFFmpeg::SeekTimeDiscont(int64_t pts, bool backwards)
+{
+  // this code is taken from ffmpeg function ff_gen_search
+  // it is modified to assume a pts overflow if timestamp < start_time
+  if (!m_pFormatContext->iformat->read_timestamp)
+    return false;
+
+  int defaultStream = av_find_default_stream_index(m_pFormatContext);
+
+  if (defaultStream < 0)
+  {
+    return false;
+  }
+
+  // timestamp for default must be expressed in AV_TIME_BASE units
+  pts = av_rescale_rnd(pts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                      AV_TIME_BASE * (int64_t)m_pFormatContext->streams[defaultStream]->time_base.num,
+                      AV_ROUND_NEAR_INF);
+
+  int64_t pos, pos_min, pos_max, pos_limit, ts, ts_min, ts_max;
+  int64_t start_pos, filesize;
+  int no_change;
+
+  pos_min = m_pFormatContext->data_offset;
+  ts_min = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                     &pos_min, INT64_MAX);
+  if (ts_min == AV_NOPTS_VALUE)
+    return false;
+
+  if(ts_min >= pts)
+  {
+    pos = pos_min;
+    return true;
+  }
+
+  int step= 1024;
+  filesize = m_pInput->GetLength();
+  pos_max = filesize - 1;
+  do
+  {
+    pos_max -= step;
+    ts_max = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                       &pos_max, pos_max + step);
+    step += step;
+  }while (ts_max == AV_NOPTS_VALUE && pos_max >= step);
+
+  if (ts_max == AV_NOPTS_VALUE)
+    return false;
+
+  if (ts_max < m_iStartTime && ts_max < m_iEndTime)
+    ts_max += m_iMaxTime;
+
+  for(;;)
+  {
+    int64_t tmp_pos = pos_max + 1;
+    int64_t tmp_ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                               &tmp_pos, INT64_MAX);
+    if(tmp_ts == AV_NOPTS_VALUE)
+      break;
+
+    if (tmp_ts < m_iStartTime && tmp_ts < m_iEndTime)
+      tmp_ts += m_iMaxTime;
+
+    ts_max = tmp_ts;
+    pos_max = tmp_pos;
+    if (tmp_pos >= filesize)
+      break;
+  }
+  pos_limit = pos_max;
+
+  if(ts_max <= pts)
+  {
+    bool ret = SeekByte(pos_max);
+    if (ret)
+    {
+      m_iCurrentPts = ConvertTimestamp(ts_max, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                       m_pFormatContext->streams[defaultStream]->time_base.num);
+    }
+    return ret;
+  }
+
+  if(ts_min > ts_max)
+  {
+    return false;
+  }
+  else if (ts_min == ts_max)
+  {
+    pos_limit = pos_min;
+  }
+
+  no_change=0;
+  while (pos_min < pos_limit)
+  {
+    if (no_change == 0)
+    {
+      int64_t approximate_keyframe_distance= pos_max - pos_limit;
+      // interpolate position (better than dichotomy)
+      pos = av_rescale_rnd(pts - ts_min, pos_max - pos_min,
+                                       ts_max - ts_min, AV_ROUND_NEAR_INF)
+          + pos_min - approximate_keyframe_distance;
+    }
+    else if (no_change == 1)
+    {
+      // bisection, if interpolation failed to change min or max pos last time
+      pos = (pos_min + pos_limit) >> 1;
+    }
+    else
+    {
+      /* linear search if bisection failed, can only happen if there
+         are very few or no keyframes between min/max */
+      pos = pos_min;
+    }
+    if (pos <= pos_min)
+      pos= pos_min + 1;
+    else if (pos > pos_limit)
+      pos= pos_limit;
+    start_pos = pos;
+
+    ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                   &pos, INT64_MAX);
+    if (pos == pos_max)
+      no_change++;
+    else
+      no_change=0;
+
+    if (ts == AV_NOPTS_VALUE)
+    {
+      return false;
+    }
+
+    if (ts < m_iStartTime && ts < m_iEndTime)
+      ts += m_iMaxTime;
+
+    if (pts <= ts)
+    {
+      pos_limit = start_pos - 1;
+      pos_max = pos;
+      ts_max = ts;
+    }
+    if (pts >= ts)
+    {
+      pos_min = pos;
+      ts_min = ts;
+    }
+  }
+
+  pos = (backwards) ? pos_min : pos_max;
+  ts  = (backwards) ?  ts_min :  ts_max;
+
+  bool ret = SeekByte(pos);
+  if (ret)
+  {
+    m_iCurrentPts = ConvertTimestamp(ts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                     m_pFormatContext->streams[defaultStream]->time_base.num);
+  }
+
+  return ret;
+}
+
 bool CDVDDemuxFFmpeg::SeekByte(int64_t pos)
 {
   CSingleLock lock(m_critSection);
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
index 44e101c..3b0f615 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -99,6 +99,7 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   DemuxPacket* Read();
 
   bool SeekTime(int time, bool backwords = false, double* startpts = NULL);
+  bool SeekTimeDiscont(int64_t pts, bool backwards);
   bool SeekByte(int64_t pos);
   int GetStreamLength();
   CDemuxStream* GetStream(int iStreamId);
@@ -153,5 +154,8 @@ class CDVDDemuxFFmpeg : public CDVDDemux
     AVPacket pkt;       // packet ffmpeg returned
     int      result;    // result from av_read_packet
   }m_pkt;
+
+  bool m_bPtsWrap, m_bPtsWrapChecked;
+  int64_t m_iStartTime, m_iMaxTime, m_iEndTime;
 };
 
-- 
1.9.3


From 1b1b64748c8513ddff234bae0f8256b5efebaad3 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 2 Oct 2012 13:02:10 +0200
Subject: [PATCH 16/37] dvdplayer: avoid short screen flicker caused by
 unnecessary reconfigure of renderer

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 14aaf6b..737ca42 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1052,13 +1052,16 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
 
 #ifdef HAS_VIDEO_PLAYBACK
   double config_framerate = m_bFpsInvalid ? 0.0 : m_fFrameRate;
+  double render_framerate = g_graphicsContext.GetFPS();
+  if (CSettings::Get().GetInt("videoplayer.adjustrefreshrate") == ADJUST_REFRESHRATE_OFF)
+    render_framerate = config_framerate;
   /* check so that our format or aspect has changed. if it has, reconfigure renderer */
   if (!g_renderManager.IsConfigured()
    || ( m_output.width           != pPicture->iWidth )
    || ( m_output.height          != pPicture->iHeight )
    || ( m_output.dwidth          != pPicture->iDisplayWidth )
    || ( m_output.dheight         != pPicture->iDisplayHeight )
-   || ( m_output.framerate       != config_framerate )
+   || (!m_bFpsInvalid && fmod(m_output.framerate, config_framerate) != 0.0 && render_framerate != config_framerate)
    || ( m_output.color_format    != (unsigned int)pPicture->format )
    || ( m_output.extended_format != pPicture->extended_format )
    || ( m_output.color_matrix    != pPicture->color_matrix    && pPicture->color_matrix    != 0 ) // don't reconfigure on unspecified
-- 
1.9.3


From 1b1f8fcd7ca91f1fa3d2ca1ea1ab0612d5fde55c Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 11 Oct 2012 12:05:50 +0200
Subject: [PATCH 17/37] vdpau: advanced settings for auto deinterlacing

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 8 ++++----
 xbmc/settings/AdvancedSettings.cpp             | 4 ++++
 xbmc/settings/AdvancedSettings.h               | 2 ++
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index e58681b..3f87a7d 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1970,10 +1970,10 @@ EINTERLACEMETHOD CMixer::GetDeinterlacingMethod(bool log /* = false */)
   if (method == VS_INTERLACEMETHOD_AUTO)
   {
     int deint = -1;
-//    if (m_config.outHeight >= 720)
-//      deint = g_advancedSettings.m_videoVDPAUdeintHD;
-//    else
-//      deint = g_advancedSettings.m_videoVDPAUdeintSD;
+    if (m_config.outHeight >= 720)
+      deint = g_advancedSettings.m_videoVDPAUdeintHD;
+    else
+      deint = g_advancedSettings.m_videoVDPAUdeintSD;
 
     if (deint != -1)
     {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 6835504..7d50649 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -157,6 +157,8 @@ void CAdvancedSettings::Initialize()
   m_videoAutoScaleMaxFps = 30.0f;
   m_videoDisableBackgroundDeinterlace = false;
   m_videoCaptureUseOcclusionQuery = -1; //-1 is auto detect
+  m_videoVDPAUdeintHD = -1;
+  m_videoVDPAUdeintSD = -1;
   m_videoVDPAUtelecine = false;
   m_videoVDPAUdeintSkipChromaHD = false;
   m_DXVACheckCompatibility = false;
@@ -596,6 +598,8 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
     XMLUtils::GetBoolean(pElement,"disableswmultithreading",m_videoDisableSWMultithreading);
     XMLUtils::GetBoolean(pElement, "disablebackgrounddeinterlace", m_videoDisableBackgroundDeinterlace);
     XMLUtils::GetInt(pElement, "useocclusionquery", m_videoCaptureUseOcclusionQuery, -1, 1);
+    XMLUtils::GetInt(pElement,"vdpauHDdeint",m_videoVDPAUdeintHD);
+    XMLUtils::GetInt(pElement,"vdpauSDdeint",m_videoVDPAUdeintSD);
     XMLUtils::GetBoolean(pElement,"vdpauInvTelecine",m_videoVDPAUtelecine);
     XMLUtils::GetBoolean(pElement,"vdpauHDdeintSkipChroma",m_videoVDPAUdeintSkipChromaHD);
 
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index c57a9fb..6c505a8 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -163,6 +163,8 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     int m_videoPercentSeekBackwardBig;
     CStdString m_videoPPFFmpegDeint;
     CStdString m_videoPPFFmpegPostProc;
+    int m_videoVDPAUdeintHD;
+    int m_videoVDPAUdeintSD;
     bool m_videoVDPAUtelecine;
     bool m_videoVDPAUdeintSkipChromaHD;
     bool m_musicUseTimeSeeking;
-- 
1.9.3


From 850f6b7d782253eacf6fa45a79d86bda4438107e Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 2 Nov 2012 13:20:03 +0100
Subject: [PATCH 18/37] player: fix rewind

---
 xbmc/cores/dvdplayer/DVDMessage.h       |  5 ++++-
 xbmc/cores/dvdplayer/DVDPlayer.cpp      | 30 +++++++++++++++++++-----------
 xbmc/cores/dvdplayer/DVDPlayer.h        |  7 ++++---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp |  4 +++-
 xbmc/cores/dvdplayer/DVDPlayerVideo.h   |  1 +
 5 files changed, 31 insertions(+), 16 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDMessage.h b/xbmc/cores/dvdplayer/DVDMessage.h
index be6603a..6ff2400 100644
--- a/xbmc/cores/dvdplayer/DVDMessage.h
+++ b/xbmc/cores/dvdplayer/DVDMessage.h
@@ -220,7 +220,7 @@ class CDVDMsgPlayerSetState : public CDVDMsg
 class CDVDMsgPlayerSeek : public CDVDMsg
 {
 public:
-  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false)
+  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false, bool sync = true)
     : CDVDMsg(PLAYER_SEEK)
     , m_time(time)
     , m_backward(backward)
@@ -228,6 +228,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
     , m_accurate(accurate)
     , m_restore(restore)
     , m_trickplay(trickplay)
+    , m_sync(sync)
   {}
   int  GetTime()              { return m_time; }
   bool GetBackward()          { return m_backward; }
@@ -235,6 +236,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
   bool GetAccurate()          { return m_accurate; }
   bool GetRestore()           { return m_restore; }
   bool GetTrickPlay()         { return m_trickplay; }
+  bool GetSync()              { return m_sync; }
 private:
   int  m_time;
   bool m_backward;
@@ -242,6 +244,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
   bool m_accurate;
   bool m_restore; // whether to restore any EDL cut time
   bool m_trickplay;
+  bool m_sync;
 };
 
 class CDVDMsgPlayerSeekChapter : public CDVDMsg
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 559ed82..26c3542 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1635,11 +1635,13 @@ void CDVDPlayer::HandlePlaySpeed()
     }
     else if (m_CurrentVideo.id >= 0
           &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
-          &&  m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts()
+          &&  (m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts() || fabs(m_SpeedState.lastabstime - CDVDClock::GetAbsoluteClock()) > DVD_MSEC_TO_TIME(200))
+          &&  (m_dvdPlayerVideo.GetCurrentPts() != DVD_NOPTS_VALUE)
           &&  m_SpeedState.lasttime != GetTime())
     {
       m_SpeedState.lastpts  = m_dvdPlayerVideo.GetCurrentPts();
       m_SpeedState.lasttime = GetTime();
+      m_SpeedState.lastabstime = CDVDClock::GetAbsoluteClock();
       // check how much off clock video is when ff/rw:ing
       // a problem here is that seeking isn't very accurate
       // and since the clock will be resynced after seek
@@ -1658,7 +1660,7 @@ void CDVDPlayer::HandlePlaySpeed()
       {
         CLog::Log(LOGDEBUG, "CDVDPlayer::Process - Seeking to catch up");
         int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
-        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true));
+        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true, false));
       }
     }
   }
@@ -2145,7 +2147,7 @@ void CDVDPlayer::HandleMessages()
           else
             m_StateInput.dts = start;
 
-          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
+          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate(), msg.GetSync());
         }
         else
           CLog::Log(LOGWARNING, "error while seeking");
@@ -2281,9 +2283,10 @@ void CDVDPlayer::HandleMessages()
           double offset;
           offset  = CDVDClock::GetAbsoluteClock() - m_State.timestamp;
           offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
+          offset  = DVD_TIME_TO_MSEC(offset);
           if(offset >  1000) offset =  1000;
           if(offset < -1000) offset = -1000;
-          m_State.time     += DVD_TIME_TO_MSEC(offset);
+          m_State.time     += offset;
           m_State.timestamp =  CDVDClock::GetAbsoluteClock();
         }
 
@@ -2299,7 +2302,8 @@ void CDVDPlayer::HandleMessages()
         // do a seek after rewind, clock is not in sync with current pts
         if (m_playSpeed < 0 && speed >= 0)
         {
-          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true));
+          int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset);
+          m_messenger.Put(new CDVDMsgPlayerSeek(iTime, true, true, false, false, true));
         }
 
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
@@ -3315,7 +3319,7 @@ void CDVDPlayer::UpdateClockMaster()
   }
 }
 
-void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
+void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool sync)
 {
   double startpts;
   if(accurate)
@@ -3327,19 +3331,23 @@ void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
   if(startpts != DVD_NOPTS_VALUE)
     startpts -= m_offset_pts;
 
-  m_CurrentAudio.inited      = false;
+  if (sync)
+  {
+    m_CurrentAudio.inited      = false;
+    m_CurrentVideo.inited      = false;
+    m_CurrentSubtitle.inited   = false;
+    m_CurrentTeletext.inited   = false;
+  }
+
   m_CurrentAudio.dts         = DVD_NOPTS_VALUE;
   m_CurrentAudio.startpts    = startpts;
 
-  m_CurrentVideo.inited      = false;
   m_CurrentVideo.dts         = DVD_NOPTS_VALUE;
   m_CurrentVideo.startpts    = startpts;
 
-  m_CurrentSubtitle.inited   = false;
   m_CurrentSubtitle.dts      = DVD_NOPTS_VALUE;
   m_CurrentSubtitle.startpts = startpts;
 
-  m_CurrentTeletext.inited   = false;
   m_CurrentTeletext.dts      = DVD_NOPTS_VALUE;
   m_CurrentTeletext.startpts = startpts;
 
@@ -3383,7 +3391,7 @@ void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
       m_CurrentTeletext.started = false;
     }
 
-    if(pts != DVD_NOPTS_VALUE)
+    if(pts != DVD_NOPTS_VALUE && sync)
       m_clock.Discontinuity(pts);
     UpdatePlayState(0);
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.h b/xbmc/cores/dvdplayer/DVDPlayer.h
index 03e91b2..8857884 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.h
+++ b/xbmc/cores/dvdplayer/DVDPlayer.h
@@ -308,7 +308,7 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   bool GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
 
 
-  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
+  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true, bool sync = true);
 
   void HandleMessages();
   void HandlePlaySpeed();
@@ -358,8 +358,9 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   int m_playSpeed;
   struct SSpeedState
   {
-    double lastpts;  // holds last display pts during ff/rw operations
-    double lasttime;
+    double  lastpts;  // holds last display pts during ff/rw operations
+    int64_t lasttime;
+    double  lastabstime;
   } m_SpeedState;
 
   int m_errorCount;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 737ca42..bf784d5 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1473,7 +1473,7 @@ double CDVDPlayerVideo::GetCurrentPts()
 
   if( m_stalled )
     iRenderPts = DVD_NOPTS_VALUE;
-  else
+  else if ( m_speed == DVD_PLAYSPEED_NORMAL)
     iRenderPts = iRenderPts - max(0.0, iSleepTime);
 
   return iRenderPts;
@@ -1572,6 +1572,8 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts)
   int    iDroppedPics = -1;
   int    iBufferLevel;
 
+  m_droppingStats.m_lastPts = pts;
+
   // get decoder stats
   if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iDroppedPics))
     iDecoderPts = pts;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 51962fa..6fe596c 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -50,6 +50,7 @@ class CDroppingStats
   double m_totalGain;
   double m_lastDecoderPts;
   double m_lastRenderPts;
+  double m_lastPts;
   unsigned int m_lateFrames;
   unsigned int m_dropRequests;
 };
-- 
1.9.3


From 9163b138553d609650b3536fc0a5b8bb9cd7e8f4 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Mar 2013 15:18:53 +0100
Subject: [PATCH 19/37] OMXPlayer: some caching fixes for pvr

---
 xbmc/cores/omxplayer/OMXPlayer.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index 502df4a..c8579a2 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -2548,7 +2548,8 @@ void COMXPlayer::HandleMessages()
           m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), (speed < 0), true, false, false, true));
 
         m_playSpeed = speed;
-        m_caching = CACHESTATE_DONE;
+        if (m_caching != CACHESTATE_PVR && m_playSpeed != DVD_PLAYSPEED_NORMAL)
+          m_caching = CACHESTATE_DONE;
         m_clock.SetSpeed(speed);
         m_av_clock.OMXSetSpeed(speed);
         m_av_clock.OMXPause();
-- 
1.9.3


From eba56c5efaf7bdd624fd9634f398509fe2cc6f81 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Mar 2013 20:50:59 +0100
Subject: [PATCH 20/37] fix incorrect display of fps when dr kicks in

---
 xbmc/Application.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 82dbee5..5a6ae42 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2311,10 +2311,11 @@ void CApplication::Render()
     if (frameTime < singleFrameTime)
       Sleep(singleFrameTime - frameTime);
   }
-  m_lastFrameTime = XbmcThreads::SystemClockMillis();
 
   if (flip)
     g_graphicsContext.Flip(dirtyRegions);
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
   CTimeUtils::UpdateFrameTime(flip);
 
   g_renderManager.UpdateResolution();
-- 
1.9.3


From 26e019a9e7764ab1e2afa112508dd9a5e4e47dc7 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 11 Jun 2013 16:20:29 +0200
Subject: [PATCH 21/37] renderer: allow some lateness within vblank interval

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 12 ++++++++++--
 xbmc/cores/VideoRenderers/RenderManager.h   |  1 +
 2 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index f4b381e..5e9f666 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -380,6 +380,8 @@ void CXBMCRenderManager::FrameFinish()
   if(g_graphicsContext.IsFullScreenVideo())
     WaitPresentTime(m.timestamp);
 
+  m_clock_framefinish = GetPresentTime();
+
   { CSingleLock lock(m_presentlock);
 
     if(m_presentstep == PRESENT_FRAME)
@@ -1032,6 +1034,12 @@ void CXBMCRenderManager::PrepareNextRender()
 
   double clocktime = GetPresentTime();
   double frametime = 1.0 / GetMaximumFPS();
+  double correction = 0.0;
+  int fps = g_VideoReferenceClock.GetRefreshRate();
+  if((fps > 0) && g_graphicsContext.IsFullScreenVideo() && (clocktime != m_clock_framefinish))
+  {
+    correction = frametime;
+  }
 
   /* see if any future queued frames are already due */
   std::deque<int>::reverse_iterator curr, prev;
@@ -1040,8 +1048,8 @@ void CXBMCRenderManager::PrepareNextRender()
   ++prev;
   while (prev != m_queued.rend())
   {
-    if(clocktime > m_Queue[*prev].timestamp                 /* previous frame is late */
-    && clocktime > m_Queue[*curr].timestamp - frametime)    /* selected frame is close to it's display time */
+    if(clocktime > m_Queue[*prev].timestamp + correction                 /* previous frame is late */
+    && clocktime > m_Queue[*curr].timestamp - frametime + correction)    /* selected frame is close to it's display time */
       break;
     ++curr;
     ++prev;
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index 949c652b..d84ff6c 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -252,6 +252,7 @@ class CXBMCRenderManager
   XbmcThreads::ConditionVariable  m_presentevent;
   CCriticalSection m_presentlock;
   CEvent     m_flushEvent;
+  double     m_clock_framefinish;
 
 
   OVERLAY::CRenderer m_overlays;
-- 
1.9.3


From da7276c90afd26fdc6c67b83d86b08406fef8094 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 25 Jul 2013 17:18:13 +0200
Subject: [PATCH 22/37] ActiveAE: slightly reduce buffer size

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index 0a291b2..4ef75d5 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -30,8 +30,8 @@ using namespace ActiveAE;
 #include "settings/AdvancedSettings.h"
 #include "windowing/WindowingFactory.h"
 
-#define MAX_CACHE_LEVEL 0.5   // total cache time of stream in seconds
-#define MAX_WATER_LEVEL 0.25  // buffered time after stream stages in seconds
+#define MAX_CACHE_LEVEL 0.4   // total cache time of stream in seconds
+#define MAX_WATER_LEVEL 0.2   // buffered time after stream stages in seconds
 #define MAX_BUFFER_TIME 0.1   // max time of a buffer in seconds
 
 void CEngineStats::Reset(unsigned int sampleRate)
-- 
1.9.3


From be35477dc1eb80b10201458087ef8fbf0297de0c Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 4 Aug 2013 10:11:16 +0200
Subject: [PATCH 23/37] Revert "vdpau: comment some features that will be added
 later"

This reverts commit e00b4f65864d623ab4d2e9e5c06db138e661f1cf.
---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 12 ++++--------
 1 file changed, 4 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 3f87a7d..f7418e8 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1097,8 +1097,7 @@ int CDecoder::Decode(AVCodecContext *avctx, AVFrame *pFrame)
     m_bufferStats.IncDecoded();
     m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
-    //TODO
-    // m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
+    m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
   }
 
   int retval = 0;
@@ -2294,8 +2293,7 @@ void CMixer::InitCycle()
   int flags;
   uint64_t latency;
   m_config.stats->GetParams(latency, flags);
-  // TODO
-  if (0) //flags & DVP_FLAG_NO_POSTPROC)
+  if (flags & DVP_FLAG_NO_POSTPROC)
     SetPostProcFeatures(false);
   else
     SetPostProcFeatures(true);
@@ -2307,8 +2305,7 @@ void CMixer::InitCycle()
   bool interlaced = m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_INTERLACED;
   m_SeenInterlaceFlag |= interlaced;
 
-  // TODO
-  if (//!(flags & DVP_FLAG_NO_POSTPROC) &&
+  if (!(flags & DVP_FLAG_NO_POSTPROC) &&
       (mode == VS_DEINTERLACEMODE_FORCE ||
       (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
@@ -2330,8 +2327,7 @@ void CMixer::InitCycle()
         m_config.stats->SetCanSkipDeint(true);
       }
 
-      // TODO
-      if (0) //m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
+      if (m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
       {
         m_mixersteps = 1;
       }
-- 
1.9.3


From cf724f8fce14c5b27e783124462af1abbd4095d9 Mon Sep 17 00:00:00 2001
From: Marcel Groothuis <margro.xbmc@gmail.com>
Date: Thu, 5 Dec 2013 22:02:50 +0100
Subject: [PATCH 24/37] ffmpeg demuxer: faster channel change for PVR addons
 without internal demuxing (such as MediaPortal, ArgusTV, MythTV, NextPVR)
 Credits: FernetMenta, Davilla, Popcornmix, Whaupt

---
 .../cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 143 ++++++++++++++++++---
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h  |   5 +-
 .../dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp    |  13 +-
 3 files changed, 139 insertions(+), 22 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 49eff5c..4d4be02 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -52,6 +52,8 @@
 #include "URL.h"
 #include "cores/FFmpeg.h"
 
+#define FF_MAX_EXTRADATA_SIZE ((1 << 28) - FF_INPUT_BUFFER_PADDING_SIZE)
+
 void CDemuxStreamAudioFFmpeg::GetStreamInfo(std::string& strInfo)
 {
   if(!m_stream) return;
@@ -153,6 +155,7 @@ CDVDDemuxFFmpeg::CDVDDemuxFFmpeg() : CDVDDemux()
   m_program = UINT_MAX;
   m_pkt.result = -1;
   memset(&m_pkt.pkt, 0, sizeof(AVPacket));
+  m_streaminfo = true; /* set to true if we want to look for streams before playback */
 }
 
 CDVDDemuxFFmpeg::~CDVDDemuxFFmpeg()
@@ -173,10 +176,11 @@ bool CDVDDemuxFFmpeg::Aborted()
   return false;
 }
 
-bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
+bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo)
 {
   AVInputFormat* iformat = NULL;
   std::string strFile;
+  m_streaminfo = streaminfo;
   m_iCurrentPts = DVD_NOPTS_VALUE;
   m_speed = DVD_PLAYSPEED_NORMAL;
   m_program = UINT_MAX;
@@ -187,8 +191,6 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
   m_pInput = pInput;
   strFile = m_pInput->GetFileName();
 
-  bool streaminfo = true; /* set to true if we want to look for streams before playback*/
-
   if( m_pInput->GetContent().length() > 0 )
   {
     std::string content = m_pInput->GetContent();
@@ -388,13 +390,12 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
   m_bMatroska = strncmp(m_pFormatContext->iformat->name, "matroska", 8) == 0;	// for "matroska.webm"
   m_bAVI = strcmp(m_pFormatContext->iformat->name, "avi") == 0;
 
-  if (streaminfo)
+  if (m_streaminfo)
   {
-    /* too speed up dvd switches, only analyse very short */
+    /* to speed up dvd switches, only analyse very short */
     if(m_pInput->IsStreamType(DVDSTREAM_TYPE_DVD))
       m_pFormatContext->max_analyze_duration = 500000;
 
-
     CLog::Log(LOGDEBUG, "%s - avformat_find_stream_info starting", __FUNCTION__);
     int iErr = avformat_find_stream_info(m_pFormatContext, NULL);
     if (iErr < 0)
@@ -414,6 +415,9 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
     }
     CLog::Log(LOGDEBUG, "%s - av_find_stream_info finished", __FUNCTION__);
   }
+  else
+    m_program = 0;
+
   // reset any timeout
   m_timeout.SetInfinite();
 
@@ -467,7 +471,7 @@ void CDVDDemuxFFmpeg::Reset()
 {
   CDVDInputStream* pInputStream = m_pInput;
   Dispose();
-  Open(pInputStream);
+  Open(pInputStream, m_streaminfo);
 }
 
 void CDVDDemuxFFmpeg::Flush()
@@ -662,25 +666,32 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
     }
     else
     {
+      ParsePacket(&m_pkt.pkt);
+
       AVStream *stream = m_pFormatContext->streams[m_pkt.pkt.stream_index];
 
-      if (m_program != UINT_MAX)
+      if (IsVideoReady())
       {
-        /* check so packet belongs to selected program */
-        for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
+        if (m_program != UINT_MAX)
         {
-          if(m_pkt.pkt.stream_index == (int)m_pFormatContext->programs[m_program]->stream_index[i])
+          /* check so packet belongs to selected program */
+          for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
           {
-            pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
-            break;
+            if(m_pkt.pkt.stream_index == (int)m_pFormatContext->programs[m_program]->stream_index[i])
+            {
+              pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
+              break;
+            }
           }
-        }
 
-        if (!pPacket)
-          bReturnEmpty = true;
+          if (!pPacket)
+            bReturnEmpty = true;
+        }
+        else
+          pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
       }
       else
-        pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
+        bReturnEmpty = true;
 
       if (pPacket)
       {
@@ -1623,3 +1634,101 @@ bool CDVDDemuxFFmpeg::IsProgramChange()
   }
   return false;
 }
+
+void CDVDDemuxFFmpeg::ParsePacket(AVPacket *pkt)
+{
+  AVStream *st = m_pFormatContext->streams[pkt->stream_index];
+  CDemuxStream *stream = GetStreamInternal(pkt->stream_index);
+
+  // if the stream is new, tell ffmpeg to parse the stream
+  if (!stream && !st->parser)
+  {
+    st->need_parsing = AVSTREAM_PARSE_FULL;
+  }
+
+  // split extradata
+  if(st->parser && st->parser->parser->split && !st->codec->extradata)
+  {
+    int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
+    if (i > 0 && i < FF_MAX_EXTRADATA_SIZE)
+    {
+      // Found extradata, fill it in. This will cause
+      // a new stream to be created and used.
+      st->codec->extradata_size = i;
+      st->codec->extradata = (uint8_t*)av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+      if (st->codec->extradata)
+      {
+        CLog::Log(LOGDEBUG, "CDVDDemuxFFmpeg::Read() fetching extradata, extradata_size(%d)", st->codec->extradata_size);
+        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
+        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+      }
+      else
+      {
+        st->codec->extradata_size = 0;
+      }
+    }
+  }
+
+  // for video we need a decoder to get desired information into codec context
+  if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&
+      (!st->codec->width || st->codec->pix_fmt == PIX_FMT_NONE))
+  {
+    // open a decoder, it will be cleared down by ffmpeg on closing the stream
+    if (!st->codec->codec)
+    {
+      const AVCodec* codec;
+      AVDictionary *thread_opt = NULL;
+      codec = avcodec_find_decoder(st->codec->codec_id);
+      // Force thread count to 1 since the h264 decoder will not extract
+      // SPS and PPS to extradata during multi-threaded decoding
+      av_dict_set(&thread_opt, "threads", "1", 0);
+      avcodec_open2(st->codec, codec, &thread_opt);
+
+      av_dict_free(&thread_opt);
+    }
+
+    // We don't need to actually decode here
+    // we just want to transport SPS data into codec context
+    st->codec->skip_idct = AVDISCARD_ALL;
+    st->codec->skip_frame = AVDISCARD_ALL;
+    st->codec->skip_loop_filter = AVDISCARD_ALL;
+
+    // We are looking for an IDR frame
+    AVFrame picture;
+    memset(&picture, 0, sizeof(AVFrame));
+    picture.pts = picture.pkt_dts = picture.pkt_pts = picture.best_effort_timestamp = AV_NOPTS_VALUE;
+    picture.pkt_pos = -1;
+    picture.key_frame = 1;
+    picture.format = -1;
+
+    int got_picture = 0;
+    avcodec_decode_video2(st->codec, &picture, &got_picture, pkt);
+  }
+}
+
+bool CDVDDemuxFFmpeg::IsVideoReady()
+{
+  AVStream *st;
+  if(m_program != UINT_MAX)
+  {
+    for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
+    {
+      int idx = m_pFormatContext->programs[m_program]->stream_index[i];
+      st = m_pFormatContext->streams[idx];
+      if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&
+          (!st->codec->width || st->codec->pix_fmt == PIX_FMT_NONE))
+        return false;
+    }
+  }
+  else
+  {
+    for (unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
+    {
+      st = m_pFormatContext->streams[i];
+      if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&
+          (!st->codec->width || st->codec->pix_fmt == PIX_FMT_NONE))
+        return false;
+    }
+  }
+  return true;
+}
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
index 3b0f615..083182e 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -88,7 +88,7 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   CDVDDemuxFFmpeg();
   virtual ~CDVDDemuxFFmpeg();
 
-  bool Open(CDVDInputStream* pInput);
+  bool Open(CDVDInputStream* pInput, bool streaminfo = true);
   void Dispose();
   void Reset();
   void Flush();
@@ -127,6 +127,8 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   CDemuxStream* GetStreamInternal(int iStreamId);
   void CreateStreams(unsigned int program = UINT_MAX);
   void DisposeStreams();
+  void ParsePacket(AVPacket *pkt);
+  bool IsVideoReady();
 
   AVDictionary *GetFFMpegOptionsFromURL(const CURL &url);
   double ConvertTimestamp(int64_t pts, int den, int num);
@@ -157,5 +159,6 @@ class CDVDDemuxFFmpeg : public CDVDDemux
 
   bool m_bPtsWrap, m_bPtsWrapChecked;
   int64_t m_iStartTime, m_iMaxTime, m_iEndTime;
+  bool m_streaminfo;
 };
 
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
index ca689d0..f383563 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
@@ -99,26 +99,31 @@ CDVDDemux* CDVDFactoryDemuxer::CreateDemuxer(CDVDInputStream* pInputStream)
   }
 #endif
 
+  bool streaminfo = true; /* Look for streams before playback */
   if (pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
   {
     CDVDInputStreamPVRManager* pInputStreamPVR = (CDVDInputStreamPVRManager*)pInputStream;
     CDVDInputStream* pOtherStream = pInputStreamPVR->GetOtherStream();
+
+    /* Don't parse the streaminfo for live streams to reduce the channel switch time */
+    bool liveStream = (pInputStream->GetFileName().substr(0, 14) == "pvr://channels");
+    streaminfo = !liveStream;
+
     if(pOtherStream)
     {
       /* Used for MediaPortal PVR addon (uses PVR otherstream for playback of rtsp streams) */
       if (pOtherStream->IsStreamType(DVDSTREAM_TYPE_FFMPEG))
       {
         auto_ptr<CDVDDemuxFFmpeg> demuxer(new CDVDDemuxFFmpeg());
-        if(demuxer->Open(pOtherStream))
+        if(demuxer->Open(pOtherStream, streaminfo))
           return demuxer.release();
         else
           return NULL;
       }
     }
 
-    std::string filename = pInputStream->GetFileName();
     /* Use PVR demuxer only for live streams */
-    if (filename.substr(0, 14) == "pvr://channels")
+    if (liveStream)
     {
       boost::shared_ptr<CPVRClient> client;
       if (g_PVRClients->GetPlayingClient(client) &&
@@ -134,7 +139,7 @@ CDVDDemux* CDVDFactoryDemuxer::CreateDemuxer(CDVDInputStream* pInputStream)
   }
 
   auto_ptr<CDVDDemuxFFmpeg> demuxer(new CDVDDemuxFFmpeg());
-  if(demuxer->Open(pInputStream))
+  if(demuxer->Open(pInputStream, streaminfo))
     return demuxer.release();
   else
     return NULL;
-- 
1.9.3


From 14e1b975fa66c1954f8b8f195bd22e60ba17498f Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 14 Nov 2013 20:35:04 +0100
Subject: [PATCH 25/37] ffmpeg demuxer: make sure we start mpegts video with an
 i-frame

---
 .../cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 31 +++++++++++++++++++++-
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h  |  1 +
 2 files changed, 31 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 4d4be02..56eaccc 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -386,6 +386,13 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo)
   if (iformat && (strcmp(iformat->name, "mjpeg") == 0) && m_ioContext->seekable == 0)
     m_pFormatContext->max_analyze_duration = 500000;
 
+  bool short_analyze = false;
+  if (iformat && (strcmp(iformat->name, "mpegts") == 0))
+  {
+    m_pFormatContext->max_analyze_duration = 500000;
+    short_analyze = true;
+  }
+
   // we need to know if this is matroska or avi later
   m_bMatroska = strncmp(m_pFormatContext->iformat->name, "matroska", 8) == 0;	// for "matroska.webm"
   m_bAVI = strcmp(m_pFormatContext->iformat->name, "avi") == 0;
@@ -414,6 +421,12 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo)
       }
     }
     CLog::Log(LOGDEBUG, "%s - av_find_stream_info finished", __FUNCTION__);
+
+    if (short_analyze)
+    {
+      // make sure we start video with an i-frame
+      ResetVideoStreams();
+    }
   }
   else
     m_program = 0;
@@ -1670,7 +1683,7 @@ void CDVDDemuxFFmpeg::ParsePacket(AVPacket *pkt)
   }
 
   // for video we need a decoder to get desired information into codec context
-  if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&
+  if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && st->codec->extradata &&
       (!st->codec->width || st->codec->pix_fmt == PIX_FMT_NONE))
   {
     // open a decoder, it will be cleared down by ffmpeg on closing the stream
@@ -1732,3 +1745,19 @@ bool CDVDDemuxFFmpeg::IsVideoReady()
   }
   return true;
 }
+
+void CDVDDemuxFFmpeg::ResetVideoStreams()
+{
+  AVStream *st;
+  for (unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
+  {
+    st = m_pFormatContext->streams[i];
+    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
+    {
+      if (st->codec->extradata)
+        m_dllAvUtil.av_free(st->codec->extradata);
+      st->codec->extradata = NULL;
+      st->codec->width = 0;
+    }
+  }
+}
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
index 083182e..26ee264 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -129,6 +129,7 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   void DisposeStreams();
   void ParsePacket(AVPacket *pkt);
   bool IsVideoReady();
+  void ResetVideoStreams();
 
   AVDictionary *GetFFMpegOptionsFromURL(const CURL &url);
   double ConvertTimestamp(int64_t pts, int den, int num);
-- 
1.9.3


From 44b93dd842bd0a37f61e22bf61366a7ff13e53f3 Mon Sep 17 00:00:00 2001
From: Wolfgang Haupt <w.haupt@at-visions.com>
Date: Thu, 5 Dec 2013 22:11:57 +0100
Subject: [PATCH 26/37] DVDFactoryDemuxer: skip streaminfo for udp tcp and
 pvr-channels

---
 .../dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp    | 14 ++++++---
 xbmc/utils/URIUtils.cpp                            | 35 ++++++++++++++++++++++
 xbmc/utils/URIUtils.h                              |  4 +++
 3 files changed, 49 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
index f383563..d6580fd 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
@@ -105,9 +105,9 @@ CDVDDemux* CDVDFactoryDemuxer::CreateDemuxer(CDVDInputStream* pInputStream)
     CDVDInputStreamPVRManager* pInputStreamPVR = (CDVDInputStreamPVRManager*)pInputStream;
     CDVDInputStream* pOtherStream = pInputStreamPVR->GetOtherStream();
 
-    /* Don't parse the streaminfo for live streams to reduce the channel switch time */
-    bool liveStream = (pInputStream->GetFileName().substr(0, 14) == "pvr://channels");
-    streaminfo = !liveStream;
+    /* Don't parse the streaminfo for some cases of streams to reduce the channel switch time */
+    bool useFastswitch = URIUtils::IsUsingFastSwitch(pInputStream->GetFileName());
+    streaminfo = !useFastswitch;
 
     if(pOtherStream)
     {
@@ -123,7 +123,7 @@ CDVDDemux* CDVDFactoryDemuxer::CreateDemuxer(CDVDInputStream* pInputStream)
     }
 
     /* Use PVR demuxer only for live streams */
-    if (liveStream)
+    if (URIUtils::IsPVRChannel(pInputStream->GetFileName()))
     {
       boost::shared_ptr<CPVRClient> client;
       if (g_PVRClients->GetPlayingClient(client) &&
@@ -138,6 +138,12 @@ CDVDDemux* CDVDFactoryDemuxer::CreateDemuxer(CDVDInputStream* pInputStream)
     }
   }
 
+  if (pInputStream->IsStreamType(DVDSTREAM_TYPE_FFMPEG))
+  {
+    bool useFastswitch = URIUtils::IsUsingFastSwitch(pInputStream->GetFileName());
+    streaminfo = !useFastswitch;
+  }
+
   auto_ptr<CDVDDemuxFFmpeg> demuxer(new CDVDDemuxFFmpeg());
   if(demuxer->Open(pInputStream, streaminfo))
     return demuxer.release();
diff --git a/xbmc/utils/URIUtils.cpp b/xbmc/utils/URIUtils.cpp
index fd2eb5a..22932b7 100644
--- a/xbmc/utils/URIUtils.cpp
+++ b/xbmc/utils/URIUtils.cpp
@@ -788,6 +788,36 @@ bool URIUtils::IsFTP(const CStdString& strFile)
          StringUtils::StartsWithNoCase(strFile2, "ftps:");
 }
 
+bool URIUtils::IsUDP(const CStdString& strFile)
+{
+  CStdString strFile2(strFile);
+
+  if (IsStack(strFile))
+    strFile2 = CStackDirectory::GetFirstStackedFile(strFile);
+
+  return StringUtils::StartsWithNoCase(strFile2, "udp:");
+}
+
+bool URIUtils::IsTCP(const CStdString& strFile)
+{
+  CStdString strFile2(strFile);
+
+  if (IsStack(strFile))
+    strFile2 = CStackDirectory::GetFirstStackedFile(strFile);
+
+  return StringUtils::StartsWithNoCase(strFile2, "tcp:");
+}
+
+bool URIUtils::IsPVRChannel(const CStdString& strFile)
+{
+  CStdString strFile2(strFile);
+
+  if (IsStack(strFile))
+    strFile2 = CStackDirectory::GetFirstStackedFile(strFile);
+
+  return StringUtils::StartsWithNoCase(strFile2, "pvr://channels");
+}
+
 bool URIUtils::IsDAV(const CStdString& strFile)
 {
   CStdString strFile2(strFile);
@@ -1284,3 +1314,8 @@ bool URIUtils::UpdateUrlEncoding(std::string &strFilename)
   strFilename = newFilename;
   return true;
 }
+
+bool URIUtils::IsUsingFastSwitch(const CStdString& strFile)
+{
+  return IsUDP(strFile) || IsTCP(strFile) || IsPVRChannel(strFile);
+}
diff --git a/xbmc/utils/URIUtils.h b/xbmc/utils/URIUtils.h
index b94e94c..b45630f 100644
--- a/xbmc/utils/URIUtils.h
+++ b/xbmc/utils/URIUtils.h
@@ -88,6 +88,8 @@ class URIUtils
   static bool IsDOSPath(const CStdString &path);
   static bool IsDVD(const CStdString& strFile);
   static bool IsFTP(const CStdString& strFile);
+  static bool IsUDP(const CStdString& strFile);
+  static bool IsTCP(const CStdString& strFile);
   static bool IsHD(const CStdString& strFileName);
   static bool IsHDHomeRun(const CStdString& strFile);
   static bool IsSlingbox(const CStdString& strFile);
@@ -127,6 +129,8 @@ class URIUtils
   static bool IsAndroidApp(const CStdString& strFile);
   static bool IsLibraryFolder(const CStdString& strFile);
   static bool IsLibraryContent(const std::string& strFile);
+  static bool IsPVRChannel(const CStdString& strFile);
+  static bool IsUsingFastSwitch(const CStdString& strFile);
 
   static void AddSlashAtEnd(std::string& strFolder);
   static bool HasSlashAtEnd(const std::string& strFile, bool checkURL = false);
-- 
1.9.3


From 6afeed968a8e8a3ff8347d38699c1dbb0f70a63d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 28 Jan 2014 08:43:29 +0100
Subject: [PATCH 27/37] squash fast switch

---
 .../cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 23 ++++++++++++++--------
 1 file changed, 15 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 56eaccc..d0f13a1 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -1722,15 +1722,19 @@ void CDVDDemuxFFmpeg::ParsePacket(AVPacket *pkt)
 bool CDVDDemuxFFmpeg::IsVideoReady()
 {
   AVStream *st;
+  bool hasVideo = false;
   if(m_program != UINT_MAX)
   {
     for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
     {
       int idx = m_pFormatContext->programs[m_program]->stream_index[i];
       st = m_pFormatContext->streams[idx];
-      if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&
-          (!st->codec->width || st->codec->pix_fmt == PIX_FMT_NONE))
-        return false;
+      if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
+      {
+        if (st->codec->width && st->codec->pix_fmt != PIX_FMT_NONE)
+          return true;
+        hasVideo = true;
+      }
     }
   }
   else
@@ -1738,12 +1742,15 @@ bool CDVDDemuxFFmpeg::IsVideoReady()
     for (unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
     {
       st = m_pFormatContext->streams[i];
-      if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&
-          (!st->codec->width || st->codec->pix_fmt == PIX_FMT_NONE))
-        return false;
+      if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
+      {
+        if (st->codec->width && st->codec->pix_fmt != PIX_FMT_NONE)
+          return true;
+        hasVideo = true;
+      }
     }
   }
-  return true;
+  return !hasVideo;
 }
 
 void CDVDDemuxFFmpeg::ResetVideoStreams()
@@ -1755,7 +1762,7 @@ void CDVDDemuxFFmpeg::ResetVideoStreams()
     if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
     {
       if (st->codec->extradata)
-        m_dllAvUtil.av_free(st->codec->extradata);
+        av_free(st->codec->extradata);
       st->codec->extradata = NULL;
       st->codec->width = 0;
     }
-- 
1.9.3


From 74ca9198acceec6c9f63de70771e7eb9b23a66a2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 13 Apr 2014 10:52:26 +0200
Subject: [PATCH 28/37] squash fast channel

---
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 13 ++++++++++---
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h   |  1 +
 2 files changed, 11 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index d0f13a1..1aeae2b 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -156,6 +156,7 @@ CDVDDemuxFFmpeg::CDVDDemuxFFmpeg() : CDVDDemux()
   m_pkt.result = -1;
   memset(&m_pkt.pkt, 0, sizeof(AVPacket));
   m_streaminfo = true; /* set to true if we want to look for streams before playback */
+  m_checkvideo = false;
 }
 
 CDVDDemuxFFmpeg::~CDVDDemuxFFmpeg()
@@ -386,11 +387,10 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo)
   if (iformat && (strcmp(iformat->name, "mjpeg") == 0) && m_ioContext->seekable == 0)
     m_pFormatContext->max_analyze_duration = 500000;
 
-  bool short_analyze = false;
   if (iformat && (strcmp(iformat->name, "mpegts") == 0))
   {
     m_pFormatContext->max_analyze_duration = 500000;
-    short_analyze = true;
+    m_checkvideo = true;
   }
 
   // we need to know if this is matroska or avi later
@@ -422,14 +422,17 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo)
     }
     CLog::Log(LOGDEBUG, "%s - av_find_stream_info finished", __FUNCTION__);
 
-    if (short_analyze)
+    if (m_checkvideo)
     {
       // make sure we start video with an i-frame
       ResetVideoStreams();
     }
   }
   else
+  {
     m_program = 0;
+    m_checkvideo = true;
+  }
 
   // reset any timeout
   m_timeout.SetInfinite();
@@ -1723,6 +1726,10 @@ bool CDVDDemuxFFmpeg::IsVideoReady()
 {
   AVStream *st;
   bool hasVideo = false;
+
+  if(!m_checkvideo)
+    return true;
+
   if(m_program != UINT_MAX)
   {
     for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
index 26ee264..322a3b8 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -161,5 +161,6 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   bool m_bPtsWrap, m_bPtsWrapChecked;
   int64_t m_iStartTime, m_iMaxTime, m_iEndTime;
   bool m_streaminfo;
+  bool m_checkvideo;
 };
 
-- 
1.9.3


From b721145b7619edecbcdfc519b1c39a69cb19b74f Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 22 Dec 2013 14:52:29 +0100
Subject: [PATCH 29/37] linux: add shared lib for sse4 operations

---
 Makefile.in                   |   8 ++-
 configure.in                  |  18 +++++++
 xbmc/DllPaths_generated.h.in  |   3 ++
 xbmc/linux/sse4/CopyFrame.cpp | 115 ++++++++++++++++++++++++++++++++++++++++++
 xbmc/linux/sse4/DllLibSSE4.h  |  43 ++++++++++++++++
 xbmc/linux/sse4/Makefile.in   |  20 ++++++++
 6 files changed, 206 insertions(+), 1 deletion(-)
 create mode 100644 xbmc/linux/sse4/CopyFrame.cpp
 create mode 100644 xbmc/linux/sse4/DllLibSSE4.h
 create mode 100644 xbmc/linux/sse4/Makefile.in

diff --git a/Makefile.in b/Makefile.in
index e07970f..6a6346d 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -314,6 +314,12 @@ CHECK_LIBADD=@WAYLAND_TEST_LIBS@
 endif
 endif
 
+ifeq (@USE_SSE4@,1)
+LIBSSE4+=sse4
+sse4 : force
+	$(MAKE) -C xbmc/linux/sse4
+endif
+
 CHECK_PROGRAMS = xbmc-test
 
 CLEAN_FILES += $(CHECK_PROGRAMS) $(CHECK_EXTENSIONS)
@@ -441,7 +447,7 @@ endif
 
 codecs: papcodecs dvdpcodecs dvdpextcodecs
 
-libs: libhdhomerun imagelib libexif system/libcpluff-@ARCH@.so $(CMYTH)
+libs: $(LIBSSE4) libhdhomerun imagelib libexif system/libcpluff-@ARCH@.so $(CMYTH)
 
 externals: codecs libs visualizations screensavers libaddon pvraddons
 
diff --git a/configure.in b/configure.in
index 1766ce1..abbfcdf 100644
--- a/configure.in
+++ b/configure.in
@@ -832,6 +832,19 @@ elif test "$use_arch" = "arm"; then
   fi
 fi
 
+use_sse4=no
+if test "$ARCH" = "x86_64-linux" || test "$ARCH" = "i486-linux"; then
+    SAVE_CFLAGS="$CFLAGS"
+    CFLAGS="-msse4.1"
+    AC_COMPILE_IFELSE(
+      [AC_LANG_SOURCE([int foo;])],
+      [ use_sse4=yes
+        USE_SSE4=1],
+      [ use_sse=no
+        USE_SSE4=0])
+    CFLAGS="$SAVE_CFLAGS"
+fi
+
 # Checks for library functions.
 AC_FUNC_ALLOCA
 AC_FUNC_CHOWN
@@ -2583,6 +2596,10 @@ if test "$use_codec_libstagefright" = "yes"; then
 OUTPUT_FILES="$OUTPUT_FILES xbmc/cores/dvdplayer/DVDCodecs/Video/libstagefrightICS/Makefile"
 fi
 
+if test "$use_sse4" = "yes"; then
+OUTPUT_FILES="$OUTPUT_FILES xbmc/linux/sse4/Makefile"
+fi
+
 OUTPUT_FILES="$OUTPUT_FILES \
   xbmc/interfaces/python/Makefile \
   xbmc/interfaces/python/test/Makefile"
@@ -2661,6 +2678,7 @@ AC_SUBST(GTEST_CONFIGURED)
 AC_SUBST(USE_DOXYGEN)
 AC_SUBST(USE_PVR_ADDONS)
 AC_SUBST(UPNP_DEFINES)
+AC_SUBST(USE_SSE4)
 
 # pushd and popd are not available in other shells besides bash, so implement
 # our own pushd/popd functions
diff --git a/xbmc/DllPaths_generated.h.in b/xbmc/DllPaths_generated.h.in
index baebb4d..dacbbd6 100644
--- a/xbmc/DllPaths_generated.h.in
+++ b/xbmc/DllPaths_generated.h.in
@@ -92,4 +92,7 @@
 /* xkbcommon */
 #define DLL_PATH_XKBCOMMON "@XKBCOMMON_LIBRARY_SONAME@"
 
+/* sse4 */
+#define DLL_PATH_LIBSSE4      "special://xbmcbin/system/libsse4-@ARCH@.so"
+
 #endif
diff --git a/xbmc/linux/sse4/CopyFrame.cpp b/xbmc/linux/sse4/CopyFrame.cpp
new file mode 100644
index 0000000..6d23d83
--- /dev/null
+++ b/xbmc/linux/sse4/CopyFrame.cpp
@@ -0,0 +1,115 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "smmintrin.h"
+
+#define CACHED_BUFFER_SIZE 4096
+typedef unsigned int UINT;
+
+extern "C"
+{
+
+/*
+ * http://software.intel.com/en-us/articles/copying-accelerated-video-decode-frame-buffers
+ * COPIES VIDEO FRAMES FROM USWC MEMORY TO WB SYSTEM MEMORY VIA CACHED BUFFER
+ * ASSUMES PITCH IS A MULTIPLE OF 64B CACHE LINE SIZE, WIDTH MAY NOT BE
+ */
+void copy_frame( void * pSrc, void * pDest, void * pCacheBlock,
+    UINT width, UINT height, UINT pitch )
+{
+  __m128i         x0, x1, x2, x3;
+  __m128i         *pLoad;
+  __m128i         *pStore;
+  __m128i         *pCache;
+  UINT            x, y, yLoad, yStore;
+  UINT            rowsPerBlock;
+  UINT            width64;
+  UINT            extraPitch;
+
+
+  rowsPerBlock = CACHED_BUFFER_SIZE / pitch;
+  width64 = (width + 63) & ~0x03f;
+  extraPitch = (pitch - width64) / 16;
+
+  pLoad  = (__m128i *)pSrc;
+  pStore = (__m128i *)pDest;
+
+  //  COPY THROUGH 4KB CACHED BUFFER
+  for( y = 0; y < height; y += rowsPerBlock  )
+  {
+    //  ROWS LEFT TO COPY AT END
+    if( y + rowsPerBlock > height )
+      rowsPerBlock = height - y;
+
+    pCache = (__m128i *)pCacheBlock;
+
+    _mm_mfence();
+
+    // LOAD ROWS OF PITCH WIDTH INTO CACHED BLOCK
+    for( yLoad = 0; yLoad < rowsPerBlock; yLoad++ )
+    {
+      // COPY A ROW, CACHE LINE AT A TIME
+      for( x = 0; x < pitch; x +=64 )
+      {
+        x0 = _mm_stream_load_si128( pLoad +0 );
+        x1 = _mm_stream_load_si128( pLoad +1 );
+        x2 = _mm_stream_load_si128( pLoad +2 );
+        x3 = _mm_stream_load_si128( pLoad +3 );
+
+        _mm_store_si128( pCache +0,     x0 );
+        _mm_store_si128( pCache +1, x1 );
+        _mm_store_si128( pCache +2, x2 );
+        _mm_store_si128( pCache +3, x3 );
+
+        pCache += 4;
+        pLoad += 4;
+      }
+    }
+
+    _mm_mfence();
+
+    pCache = (__m128i *)pCacheBlock;
+
+    // STORE ROWS OF FRAME WIDTH FROM CACHED BLOCK
+    for( yStore = 0; yStore < rowsPerBlock; yStore++ )
+    {
+      // copy a row, cache line at a time
+      for( x = 0; x < width64; x +=64 )
+      {
+        x0 = _mm_load_si128( pCache );
+        x1 = _mm_load_si128( pCache +1 );
+        x2 = _mm_load_si128( pCache +2 );
+        x3 = _mm_load_si128( pCache +3 );
+
+        _mm_stream_si128( pStore,       x0 );
+        _mm_stream_si128( pStore +1, x1 );
+        _mm_stream_si128( pStore +2, x2 );
+        _mm_stream_si128( pStore +3, x3 );
+
+        pCache += 4;
+        pStore += 4;
+      }
+
+      pCache += extraPitch;
+      pStore += extraPitch;
+    }
+  }
+}
+}
diff --git a/xbmc/linux/sse4/DllLibSSE4.h b/xbmc/linux/sse4/DllLibSSE4.h
new file mode 100644
index 0000000..01424ac
--- /dev/null
+++ b/xbmc/linux/sse4/DllLibSSE4.h
@@ -0,0 +1,43 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DynamicDll.h"
+
+extern "C" {
+
+}
+
+class DllLibSSE4Interface
+{
+public:
+  virtual ~DllLibSSE4Interface() {}
+  virtual void copy_frame(void * pSrc, void * pDest, void * pCacheBlock, UINT width, UINT height, UINT pitch) = 0;
+};
+
+class DllLibSSE4 : public DllDynamic, DllLibSSE4Interface
+{
+  DECLARE_DLL_WRAPPER(DllLibSSE4, DLL_PATH_LIBSSE4)
+  DEFINE_METHOD6(void, copy_frame, (void *p1, void *p2, void *p3, UINT p4, UINT p5, UINT p6))
+
+  BEGIN_METHOD_RESOLVE()
+    RESOLVE_METHOD(copy_frame)
+  END_METHOD_RESOLVE()
+};
diff --git a/xbmc/linux/sse4/Makefile.in b/xbmc/linux/sse4/Makefile.in
new file mode 100644
index 0000000..45aa826
--- /dev/null
+++ b/xbmc/linux/sse4/Makefile.in
@@ -0,0 +1,20 @@
+ARCH=@ARCH@
+DEFINES+=
+CXXFLAGS=-fPIC -msse4.1
+LIBNAME=libsse4
+OBJS=CopyFrame.o
+
+LIB_SHARED=@abs_top_srcdir@/system/$(LIBNAME)-$(ARCH).so
+
+all: $(LIB_SHARED)
+
+$(LIB_SHARED): $(OBJS)
+	$(CXX) $(CFLAGS) $(LDFLAGS) -shared -g -o $(LIB_SHARED) $(OBJS)
+
+CLEAN_FILES = \
+	$(LIB_SHARED) \
+
+DISTCLEAN_FILES= \
+	Makefile \
+
+include ../../../Makefile.include
-- 
1.9.3


From d5bff220ec13394d5d568aae7acd72e62b839473 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 19 Dec 2013 15:36:11 +0100
Subject: [PATCH 30/37] vaapi: option to enable sw filters

---
 language/English/strings.po                        |  17 ++-
 system/settings/settings.xml                       |  15 ++
 xbmc/cores/VideoRenderers/RenderManager.cpp        |   4 +-
 xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp   |   1 +
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |   2 +
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp        |  71 ++++++++--
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.h          |   4 +
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp     | 152 +++++++++++++++++++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h       |  31 +++++
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |  30 ++--
 10 files changed, 290 insertions(+), 37 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index fb26ead..c6822b1 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -6162,7 +6162,13 @@ msgctxt "#13456"
 msgid "Hardware accelerated"
 msgstr ""
 
-#empty strings from id 13457 to 13499
+#. Option for video related setting #13454: sw filter
+#: system/settings/settings.xml
+msgctxt "#13457"
+msgid "Use SW Filter for VAAPI"
+msgstr ""
+
+#empty strings from id 13458 to 13499
 
 #: system/settings/settings.xml
 msgctxt "#13500"
@@ -15279,7 +15285,14 @@ msgctxt "#36431"
 msgid "Defines whether video decoding should be performed in software (requires more CPU) or with hardware acceleration where possible."
 msgstr ""
 
-#empty strings from id 36432 to 36499
+#. Description for video related setting #13457: vaapi sw filter 
+#: system/settings/settings.xml
+msgctxt "#36432"
+msgid "This option enables the deinterlacing methods available for software decoding. It gives the possiblity to use high quality deinterlacers in combination with VAAPI."
+msgstr ""
+
+#empty strings from id 36433 to 36499
+
 #end reservation
 
 #: system/settings/settings.xml
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 391bcee..c0f64ab 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -715,6 +715,21 @@
           <default>false</default>
           <control type="toggle" />
         </setting>
+        <setting id="videoplayer.usevaapiswfilter" type="boolean" parent="videoplayer.usevaapi" label="13457" help="36432">
+          <requirement>HAVE_LIBVA</requirement>
+          <dependencies>
+            <dependency type="enable">
+              <and>
+                <condition setting="videoplayer.usevaapi" operator="is">true</condition>
+                <condition setting="videoplayer.decodingmethod" operator="is">1</condition>
+              </and>
+            </dependency>
+            <dependency type="visible" on="property" name="codecoptionvisible" setting="videoplayer.usevaapivc1" operator="is">true</dependency>
+          </dependencies>
+          <level>3</level>
+          <default>false</default>
+          <control type="toggle" />
+        </setting>
         <setting id="videoplayer.usedxva2" type="boolean" label="13427" help="36158">
           <requirement>HasDXVA2</requirement>
           <dependencies>
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 5e9f666..32ce5bb 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -988,10 +988,10 @@ EINTERLACEMETHOD CXBMCRenderManager::AutoInterlaceMethodInternal(EINTERLACEMETHO
   if (mInt == VS_INTERLACEMETHOD_NONE)
     return VS_INTERLACEMETHOD_NONE;
 
-  if(!m_pRenderer->Supports(mInt))
+  if(m_pRenderer && !m_pRenderer->Supports(mInt))
     mInt = VS_INTERLACEMETHOD_AUTO;
 
-  if (mInt == VS_INTERLACEMETHOD_AUTO)
+  if (m_pRenderer && mInt == VS_INTERLACEMETHOD_AUTO)
     return m_pRenderer->AutoInterlaceMethod();
 
   return mInt;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp
index 2958d43..06e0010 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp
@@ -464,6 +464,7 @@ static const EFormatMap g_format_map[] = {
 ,  { PIX_FMT_YUV420P16,   RENDER_FMT_YUV420P16  }
 ,  { PIX_FMT_UYVY422,     RENDER_FMT_UYVY422    }
 ,  { PIX_FMT_YUYV422,     RENDER_FMT_YUYV422    }
+,  { PIX_FMT_NV12,        RENDER_FMT_NV12       }
 ,  { PIX_FMT_VAAPI_VLD,   RENDER_FMT_VAAPI      }
 ,  { PIX_FMT_DXVA2_VLD,   RENDER_FMT_DXVA       }
 ,  { PIX_FMT_NONE     ,   RENDER_FMT_NONE       }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index c5b24d6..3efc007 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -323,4 +323,6 @@ class CDVDVideoCodec
    *
    */
   virtual void SetCodecControl(int flags) {}
+
+  virtual bool IsInterlaced() { return false; }
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index c48108f..3b70aa0 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -38,6 +38,7 @@
 #include "utils/log.h"
 #include "boost/shared_ptr.hpp"
 #include "threads/Atomics.h"
+#include "settings/MediaSettings.h"
 
 #ifndef TARGET_POSIX
 #define RINT(x) ((x) >= 0 ? ((int)((x) + 0.5)) : ((int)((x) - 0.5)))
@@ -168,6 +169,7 @@ CDVDVideoCodecFFmpeg::CDVDVideoCodecFFmpeg() : CDVDVideoCodec()
   m_dts = DVD_NOPTS_VALUE;
   m_started = false;
   m_decoderPts = DVD_NOPTS_VALUE;
+  m_interlace = false;
 }
 
 CDVDVideoCodecFFmpeg::~CDVDVideoCodecFFmpeg()
@@ -375,7 +377,7 @@ unsigned int CDVDVideoCodecFFmpeg::SetFilters(unsigned int flags)
 {
   m_filters_next.clear();
 
-  if(m_pHardware)
+  if(m_pHardware && !m_pHardware->UseFilter())
     return 0;
 
   if(flags & FILTER_ROTATE)
@@ -449,10 +451,10 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
     if(section)
       lock = shared_ptr<CSingleLock>(new CSingleLock(*section));
 
-    int result;
+    int result = 0;
     if(pData)
       result = m_pHardware->Check(m_pCodecContext);
-    else
+    else if (!m_pHardware->UseFilter())
       result = m_pHardware->Decode(m_pCodecContext, NULL);
 
     if(result)
@@ -507,19 +509,60 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
   || m_pCodecContext->codec_id == AV_CODEC_ID_SVQ3)
     m_started = true;
 
-  if(m_pHardware == NULL)
+  m_interlace = m_pFrame->interlaced_frame;
+
+  if(m_pHardware == NULL || m_pHardware->UseFilter())
   {
+    if (m_pHardware)
+    {
+      m_pFrame->pkt_dts = pts_dtoi(m_dts);
+      int result = m_pHardware->Decode(m_pCodecContext, m_pFrame);
+      if (result == VC_BUFFER || result == VC_ERROR)
+        return result;
+      m_pHardware->MapFrame(m_pCodecContext, m_pFrame);
+      m_dts = pts_itod(m_pFrame->pkt_dts);
+      m_pFrame->pkt_dts = 0;
+    }
+
     bool need_scale = std::find( m_formats.begin()
                                , m_formats.end()
-                               , m_pCodecContext->pix_fmt) == m_formats.end();
+                               , m_pFrame->format) == m_formats.end();
 
     bool need_reopen  = false;
+
+
+    // ask codec to do deinterlacing if possible
+    EDEINTERLACEMODE mDeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+    EINTERLACEMETHOD mInt       = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
+
+    unsigned int mFilters = 0;
+
+    if (mDeintMode != VS_DEINTERLACEMODE_OFF)
+    {
+      if (mDeintMode == VS_DEINTERLACEMODE_FORCE ||
+          m_pFrame->interlaced_frame)
+      {
+        if (mInt == VS_INTERLACEMETHOD_DEINTERLACE)
+          mFilters = CDVDVideoCodec::FILTER_DEINTERLACE_ANY;
+        else if(mInt == VS_INTERLACEMETHOD_DEINTERLACE_HALF)
+          mFilters = CDVDVideoCodec::FILTER_DEINTERLACE_ANY | CDVDVideoCodec::FILTER_DEINTERLACE_HALFED;
+
+        if (mDeintMode == VS_DEINTERLACEMODE_AUTO && mFilters)
+          mFilters |=  CDVDVideoCodec::FILTER_DEINTERLACE_FLAGGED;
+      }
+    }
+
+    if (!g_renderManager.Supports(RENDERFEATURE_ROTATION))
+      mFilters |= CDVDVideoCodec::FILTER_ROTATE;
+
+    SetFilters(mFilters);
+
     if(!m_filters.Equals(m_filters_next))
       need_reopen = true;
 
     if(m_pFilterIn)
     {
-      if(m_pFilterIn->outputs[0]->format != m_pCodecContext->pix_fmt
+      if(m_pFilterIn->outputs[0]->format != m_pFrame->format
       || m_pFilterIn->outputs[0]->w      != m_pCodecContext->width
       || m_pFilterIn->outputs[0]->h      != m_pCodecContext->height)
         need_reopen = true;
@@ -536,7 +579,7 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
   }
 
   int result;
-  if(m_pHardware)
+  if(m_pHardware && !m_pHardware->UseFilter())
     result = m_pHardware->Decode(m_pCodecContext, m_pFrame);
   else if(m_pFilterGraph)
     result = FilterProcess(m_pFrame);
@@ -620,6 +663,7 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
   pDvdVideoPicture->chroma_position = m_pCodecContext->chroma_sample_location;
   pDvdVideoPicture->color_primaries = m_pCodecContext->color_primaries;
   pDvdVideoPicture->color_transfer = m_pCodecContext->color_trc;
+  pDvdVideoPicture->color_matrix = m_pCodecContext->colorspace;
   if(m_pCodecContext->color_range == AVCOL_RANGE_JPEG
   || m_pCodecContext->pix_fmt     == PIX_FMT_YUVJ420P)
     pDvdVideoPicture->color_range = 1;
@@ -643,7 +687,11 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
     pDvdVideoPicture->qscale_type = DVP_QSCALE_UNKNOWN;
   }
 
-  pDvdVideoPicture->dts = m_dts;
+  if (pDvdVideoPicture->iRepeatPicture)
+    pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  else
+    pDvdVideoPicture->dts = m_dts;
+
   m_dts = DVD_NOPTS_VALUE;
   if (m_pFrame->reordered_opaque)
     pDvdVideoPicture->pts = pts_itod(m_pFrame->reordered_opaque);
@@ -674,7 +722,7 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
 
 bool CDVDVideoCodecFFmpeg::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  if(m_pHardware)
+  if(m_pHardware && !m_pHardware->UseFilter())
     return m_pHardware->GetPicture(m_pCodecContext, m_pFrame, pDvdVideoPicture);
 
   if(!GetPictureCommon(pDvdVideoPicture))
@@ -694,6 +742,7 @@ bool CDVDVideoCodecFFmpeg::GetPicture(DVDVideoPicture* pDvdVideoPicture)
   pix_fmt = (PixelFormat)m_pFrame->format;
 
   pDvdVideoPicture->format = CDVDCodecUtils::EFormatFromPixfmt(pix_fmt);
+
   return true;
 }
 
@@ -707,7 +756,7 @@ int CDVDVideoCodecFFmpeg::FilterOpen(const CStdString& filters, bool scale)
   if (filters.empty() && !scale)
     return 0;
 
-  if (m_pHardware)
+  if (m_pHardware && !m_pHardware->UseFilter())
   {
     CLog::Log(LOGWARNING, "CDVDVideoCodecFFmpeg::FilterOpen - skipped opening filters on hardware decode");
     return 0;
@@ -725,7 +774,7 @@ int CDVDVideoCodecFFmpeg::FilterOpen(const CStdString& filters, bool scale)
   CStdString args = StringUtils::Format("%d:%d:%d:%d:%d:%d:%d",
                                         m_pCodecContext->width,
                                         m_pCodecContext->height,
-                                        m_pCodecContext->pix_fmt,
+                                        m_pFrame->format,
                                         m_pCodecContext->time_base.num,
                                         m_pCodecContext->time_base.den,
                                         m_pCodecContext->sample_aspect_ratio.num,
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
index 1a80a48..25f1d25 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
@@ -53,6 +53,8 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
     virtual bool CanSkipDeint() {return false; }
     virtual const std::string Name() = 0;
     virtual CCriticalSection* Section() { return NULL; }
+    virtual bool UseFilter() { return false; }
+    virtual bool MapFrame(AVCodecContext* avctx, AVFrame* frame) { return false; }
   };
 
   CDVDVideoCodecFFmpeg();
@@ -70,6 +72,7 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   virtual unsigned GetAllowedReferences();
   virtual bool GetCodecStats(double &pts, int &droppedPics);
   virtual void SetCodecControl(int flags);
+  virtual bool IsInterlaced() { return m_interlace; }
 
   bool               IsHardwareAllowed()                     { return !m_bSoftware; }
   IHardwareDecoder * GetHardware()                           { return m_pHardware; };
@@ -129,4 +132,5 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   int    m_skippedDeint;
   bool   m_requestSkipDeint;
   int    m_codecControlFlags;
+  bool   m_interlace;
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 386d50a..315f3ca 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -26,6 +26,15 @@
 #include <boost/weak_ptr.hpp>
 #include "utils/log.h"
 #include "threads/SingleLock.h"
+#include "XMemUtils.h"
+#include "utils/CPUInfo.h"
+#include "settings/Settings.h"
+
+extern "C" {
+#include "libavutil/avutil.h"
+}
+
+#define CACHED_BUFFER_SIZE 4096
 
 #define CHECK(a) \
 do { \
@@ -168,12 +177,17 @@ CDecoder::CDecoder()
   m_context         = 0;
   m_hwaccel         = (vaapi_context*)calloc(1, sizeof(vaapi_context));
   memset(m_surfaces, 0, sizeof(*m_surfaces));
+  m_frame_buffer    = NULL;
+  m_cache           = NULL;
 }
 
 CDecoder::~CDecoder()
 {
   Close();
   free(m_hwaccel);
+  _aligned_free(m_frame_buffer);
+  _aligned_free(m_cache);
+  m_dllSSE4.Unload();
 }
 
 void CDecoder::RelBuffer(uint8_t *data)
@@ -393,6 +407,11 @@ bool CDecoder::Open(AVCodecContext *avctx, enum PixelFormat fmt, unsigned int su
   if (!EnsureContext(avctx))
     return false;
 
+  if (avctx->width <= 1920 && avctx->height <= 1088)
+    CheckUseFilter();
+  else
+    m_use_filter = false;
+
   m_hwaccel->display     = m_display->get();
 
   avctx->hwaccel_context = m_hwaccel;
@@ -475,7 +494,35 @@ int CDecoder::Decode(AVCodecContext* avctx, AVFrame* frame)
     return status;
 
   if(frame)
+  {
+    if (m_use_filter)
+    {
+      VASurfaceID surface = GetSurfaceID(frame);
+      std::list<CSurfacePtr>::iterator it;
+      for(it = m_surfaces_used.begin(); it != m_surfaces_used.end(); ++it)
+      {
+        if((*it)->m_id == surface)
+        {
+          m_holder.surface = *it;
+          break;
+        }
+      }
+      if (it == m_surfaces_used.end())
+      {
+        CLog::Log(LOGERROR, "VAAPI::Decode - surface not found");
+        return VC_ERROR;
+      }
+      CProcPic pic;
+      memset(&pic.frame, 0, sizeof(AVFrame));
+      av_frame_ref(&pic.frame, frame);
+      pic.surface = *it;
+      m_surfaces_proc.push_back(pic);
+      if (m_surfaces_proc.size() < m_renderbuffers_count)
+        return VC_BUFFER;
+    }
+
     return VC_BUFFER | VC_PICTURE;
+  }
   else
     return VC_BUFFER;
 }
@@ -553,4 +600,109 @@ unsigned CDecoder::GetAllowedReferences()
   return m_renderbuffers_count;
 }
 
+void CDecoder::Reset()
+{
+  m_surfaces_proc.clear();
+}
+
+void CDecoder::CheckUseFilter()
+{
+  m_use_filter = true;
+  _aligned_free(m_frame_buffer);
+  _aligned_free(m_cache);
+  if (CSettings::Get().GetBool("videoplayer.usevaapiswfilter"))
+  {
+    if (!(g_cpuInfo.GetCPUFeatures() & CPU_FEATURE_SSE4))
+    {
+      CLog::Log(LOGNOTICE,"VAAPI::CheckUseFilter cpu does not support SSE4");
+      m_use_filter = false;
+      return;
+    }
+    if (!m_dllSSE4.Load())
+    {
+      CLog::Log(LOGNOTICE,"VAAPI::CheckUseFilter failed loading sse4 lib");
+      m_use_filter = false;
+      return;
+    }
+    VAImage image;
+    VASurfaceID surface = m_surfaces_free.front()->m_id;
+    VAStatus status = vaDeriveImage(m_display->get(), surface, &image);
+    m_use_filter = true;
+    if (status != VA_STATUS_SUCCESS)
+    {
+      CLog::Log(LOGNOTICE,"VAAPI::CheckUseFilter vaDeriveImage not supported");
+      m_use_filter = false;
+    }
+    if (image.format.fourcc != VA_FOURCC_NV12)
+    {
+      CLog::Log(LOGNOTICE,"VAAPI::CheckUseFilter image format not NV12");
+      m_use_filter = false;
+    }
+    if ((image.pitches[0] % 64) || (image.pitches[1] % 64))
+    {
+      CLog::Log(LOGNOTICE,"VAAPI::CheckUseFilter patches no multiple of 64");
+      m_use_filter = false;
+    }
+    if (m_use_filter)
+    {
+      m_frame_buffer = (uint8_t*)_aligned_malloc(image.height*image.width*2 + 256, 64);
+      m_cache = (uint8_t*)_aligned_malloc(CACHED_BUFFER_SIZE, 64);
+    }
+    vaDestroyImage(m_display->get(),image.image_id);
+  }
+  else
+  {
+    m_use_filter = false;
+  }
+}
+
+bool CDecoder::MapFrame(AVCodecContext* avctx, AVFrame* frame)
+{
+  if (m_surfaces_proc.empty())
+  {
+    return false;
+  }
+  if(frame)
+  {
+    CProcPic pic = m_surfaces_proc.front();
+    m_surfaces_proc.pop_front();
+    VASurfaceID surface = pic.surface->m_id;
+    VASurfaceStatus surf_status;
+    VAImage image;
+    uint8_t *buf;
+    CHECK(vaQuerySurfaceStatus(m_display->get(), surface, &surf_status))
+    while (surf_status != VASurfaceReady)
+    {
+      Sleep(1);
+      CHECK(vaQuerySurfaceStatus(m_display->get(), surface, &surf_status))
+    }
+    CHECK(vaDeriveImage(m_display->get(), surface, &image));
+    CHECK(vaMapBuffer(m_display->get(), image.buf, (void**)&buf))
+
+    uint8_t *src, *dst;
+    src = buf + image.offsets[0];
+    dst = m_frame_buffer + image.offsets[0];
+    m_dllSSE4.copy_frame(src, dst, m_cache, image.width, image.height, image.pitches[0]);
+    src = buf + image.offsets[1];
+    dst = m_frame_buffer + image.offsets[1];
+    m_dllSSE4.copy_frame(src, dst, m_cache, image.width, image.height/2, image.pitches[1]);
+
+    av_frame_unref(frame);
+    av_frame_move_ref(frame, &pic.frame);
+
+    frame->format = AV_PIX_FMT_NV12;
+    frame->data[0] = m_frame_buffer + image.offsets[0];
+    frame->linesize[0] = image.pitches[0];
+    frame->data[1] = m_frame_buffer + image.offsets[1];
+    frame->linesize[1] = image.pitches[1];
+    frame->data[2] = NULL;
+    frame->data[3] = NULL;
+    frame->pkt_size = image.data_size;
+
+    CHECK(vaUnmapBuffer(m_display->get(), image.buf))
+    CHECK(vaDestroyImage(m_display->get(),image.image_id))
+  }
+  return true;
+}
+
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
index ec99162..616b124 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
@@ -27,9 +27,11 @@
 #include <va/va_glx.h>
 #include <list>
 #include <boost/shared_ptr.hpp>
+#include "linux/sse4/DllLibSSE4.h"
 
 extern "C" {
 #include "libavcodec/vaapi.h"
+#include "libavcodec/avcodec.h"
 }
 
 namespace VAAPI {
@@ -102,11 +104,31 @@ struct CHolder
   {}
 };
 
+struct CProcPic
+{
+  AVFrame frame;
+  CSurfacePtr surface;
+  CProcPic()
+  {}
+  CProcPic(const CProcPic &other)
+  {
+    memcpy(&this->frame, &other.frame, sizeof(AVFrame));
+    surface = other.surface;
+  }
+  CProcPic & operator= (const CProcPic &other)
+  {
+    memcpy(&this->frame, &other.frame, sizeof(AVFrame));
+    surface = other.surface;
+    return *this;
+  }
+};
+
 class CDecoder
   : public CDVDVideoCodecFFmpeg::IHardwareDecoder
 {
   bool EnsureContext(AVCodecContext *avctx);
   bool EnsureSurfaces(AVCodecContext *avctx, unsigned n_surfaces_count);
+  void CheckUseFilter();
 public:
   CDecoder();
  ~CDecoder();
@@ -115,9 +137,12 @@ class CDecoder
   virtual bool GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture);
   virtual int  Check     (AVCodecContext* avctx);
   virtual void Close();
+  virtual void Reset();
   virtual const std::string Name() { return "vaapi"; }
   virtual CCriticalSection* Section() { if(m_display) return m_display.get(); else return NULL; }
   virtual unsigned GetAllowedReferences();
+  virtual bool UseFilter() { return m_use_filter; }
+  virtual bool MapFrame(AVCodecContext* avctx, AVFrame* frame);
 
   int   GetBuffer(AVCodecContext *avctx, AVFrame *pic, int flags);
   void  RelBuffer(uint8_t *data);
@@ -133,14 +158,20 @@ class CDecoder
   int                    m_refs;
   std::list<CSurfacePtr> m_surfaces_used;
   std::list<CSurfacePtr> m_surfaces_free;
+  std::list<CProcPic>    m_surfaces_proc;
 
   CDisplayPtr    m_display;
   VAConfigID     m_config;
   VAContextID    m_context;
+  bool           m_use_filter;
+  uint8_t       *m_frame_buffer;
+  uint8_t       *m_cache;
 
   vaapi_context *m_hwaccel;
 
   CHolder        m_holder; // silly struct to pass data to renderer
+
+  DllLibSSE4     m_dllSSE4;
 };
 
 }
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index bf784d5..979c74c 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -552,28 +552,6 @@ void CDVDPlayerVideo::Process()
       // decoder still needs to provide an empty image structure, with correct flags
       m_pVideoCodec->SetDropState(bRequestDrop);
 
-      // ask codec to do deinterlacing if possible
-      EDEINTERLACEMODE mDeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
-      EINTERLACEMETHOD mInt       = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
-
-      unsigned int     mFilters = 0;
-
-      if (mDeintMode != VS_DEINTERLACEMODE_OFF)
-      {
-        if (mInt == VS_INTERLACEMETHOD_DEINTERLACE)
-          mFilters = CDVDVideoCodec::FILTER_DEINTERLACE_ANY;
-        else if(mInt == VS_INTERLACEMETHOD_DEINTERLACE_HALF)
-          mFilters = CDVDVideoCodec::FILTER_DEINTERLACE_ANY | CDVDVideoCodec::FILTER_DEINTERLACE_HALFED;
-
-        if (mDeintMode == VS_DEINTERLACEMODE_AUTO && mFilters)
-          mFilters |=  CDVDVideoCodec::FILTER_DEINTERLACE_FLAGGED;
-      }
-
-      if (!g_renderManager.Supports(RENDERFEATURE_ROTATION))
-        mFilters |= CDVDVideoCodec::FILTER_ROTATE;
-
-      mFilters = m_pVideoCodec->SetFilters(mFilters);
-
       int iDecoderState = m_pVideoCodec->Decode(pPacket->pData, pPacket->iSize, pPacket->dts, pPacket->pts);
 
       // buffer packets so we can recover should decoder flush for some reason
@@ -660,6 +638,8 @@ void CDVDPlayerVideo::Process()
 
             //Deinterlace if codec said format was interlaced or if we have selected we want to deinterlace
             //this video
+            EDEINTERLACEMODE mDeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+            EINTERLACEMETHOD mInt       = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
             if ((mDeintMode == VS_DEINTERLACEMODE_AUTO && (picture.iFlags & DVP_FLAG_INTERLACED)) || mDeintMode == VS_DEINTERLACEMODE_FORCE)
             {
               if(mInt == VS_INTERLACEMETHOD_SW_BLEND)
@@ -702,7 +682,13 @@ void CDVDPlayerVideo::Process()
             }
 
             if (picture.iRepeatPicture)
+            {
+              bool deint = m_pVideoCodec->IsInterlaced();
+              picture.iDuration = frametime;
+              if (deint && (frametime <= 0.02*DVD_TIME_BASE))
+                picture.iDuration *= 2;
               picture.iDuration *= picture.iRepeatPicture + 1;
+            }
 
             int iResult = OutputPicture(&picture, pts);
 
-- 
1.9.3


From f1beaaef353bb1a89165466d5772257c66fc207b Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 28 Jan 2014 10:05:26 +0100
Subject: [PATCH 31/37] xbmc pr 3080

---
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp      | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 3b70aa0..80915d4 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -477,6 +477,14 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
   av_init_packet(&avpkt);
   avpkt.data = pData;
   avpkt.size = iSize;
+#define SET_PKT_TS(ts) \
+  if(ts != DVD_NOPTS_VALUE)\
+    avpkt.ts = (ts / DVD_TIME_BASE) * AV_TIME_BASE;\
+  else\
+    avpkt.ts = AV_NOPTS_VALUE
+  SET_PKT_TS(pts);
+  SET_PKT_TS(dts);
+#undef SET_PKT_TS
   /* We lie, but this flag is only used by pngdec.c.
    * Setting it correctly would allow CorePNG decoding. */
   avpkt.flags = AV_PKT_FLAG_KEY;
@@ -693,8 +701,10 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
     pDvdVideoPicture->dts = m_dts;
 
   m_dts = DVD_NOPTS_VALUE;
-  if (m_pFrame->reordered_opaque)
-    pDvdVideoPicture->pts = pts_itod(m_pFrame->reordered_opaque);
+
+  int64_t bpts = av_frame_get_best_effort_timestamp(m_pFrame);
+  if(bpts != AV_NOPTS_VALUE)
+    pDvdVideoPicture->pts = (double)bpts * DVD_TIME_BASE / AV_TIME_BASE;
   else
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 
-- 
1.9.3


From 10c9dff872513b9bf786f53702dd3a7f2c88d74b Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 28 Jan 2014 17:24:58 +0100
Subject: [PATCH 32/37] set preatpicture if pts is equal to last frame

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 80915d4..ab36704 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -704,7 +704,15 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
 
   int64_t bpts = av_frame_get_best_effort_timestamp(m_pFrame);
   if(bpts != AV_NOPTS_VALUE)
+  {
     pDvdVideoPicture->pts = (double)bpts * DVD_TIME_BASE / AV_TIME_BASE;
+    if (pDvdVideoPicture->pts == m_decoderPts)
+    {
+      pDvdVideoPicture->iRepeatPicture = -0.5;
+      pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
+      pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+    }
+  }
   else
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 
-- 
1.9.3


From 5f8d9343ade961f4a8af7e38757c2102b6a81074 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 11 Feb 2014 18:15:06 +0100
Subject: [PATCH 33/37] ActiveAE: add some debug logging

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
index 1833e9a..413005a 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
@@ -263,7 +263,13 @@ unsigned int CActiveAEStream::AddData(uint8_t* const *data, unsigned int offset,
       }
     }
     if (!m_inMsgEvent.WaitMSec(200))
+    {
+      double cachetime = GetCacheTime();
+      CSingleLock lock(m_streamLock);
+      CLog::Log(LOGWARNING, "CActiveAEStream::AddData - timeout waiting for buffer, paused: %d, cache time: %f, free buffers: %d",
+                             m_paused, cachetime, m_streamFreeBuffers);
       break;
+    }
   }
   return copied;
 }
-- 
1.9.3


From 3285a4eb92799bdfd6c1c89181c5af4edba26069 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 25 May 2014 21:25:31 +0200
Subject: [PATCH 34/37] squash swfilter

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 315f3ca..4452cfb 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -519,6 +519,8 @@ int CDecoder::Decode(AVCodecContext* avctx, AVFrame* frame)
       m_surfaces_proc.push_back(pic);
       if (m_surfaces_proc.size() < m_renderbuffers_count)
         return VC_BUFFER;
+
+      return VC_PICTURE;
     }
 
     return VC_BUFFER | VC_PICTURE;
-- 
1.9.3


From 21be5f9ad1211c140092a7e268e2c8240583cb58 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Mon, 26 May 2014 08:07:39 +0200
Subject: [PATCH 35/37] swfilter, squash me too

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 4452cfb..befb6d6 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -517,7 +517,7 @@ int CDecoder::Decode(AVCodecContext* avctx, AVFrame* frame)
       av_frame_ref(&pic.frame, frame);
       pic.surface = *it;
       m_surfaces_proc.push_back(pic);
-      if (m_surfaces_proc.size() < m_renderbuffers_count)
+      if (m_surfaces_proc.size() < m_renderbuffers_count + 1)
         return VC_BUFFER;
 
       return VC_PICTURE;
@@ -526,7 +526,15 @@ int CDecoder::Decode(AVCodecContext* avctx, AVFrame* frame)
     return VC_BUFFER | VC_PICTURE;
   }
   else
-    return VC_BUFFER;
+  {
+    if (m_use_filter)
+    {
+      if (m_surfaces_proc.size() < m_renderbuffers_count + 1)
+        return VC_BUFFER;
+    }
+    else
+      return VC_BUFFER;
+  }
 }
 
 bool CDecoder::GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture)
-- 
1.9.3


From 4cbf9280725cbd829c0ae859a0d8de01e8612e69 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 31 May 2014 09:19:23 +0200
Subject: [PATCH 37/37] squash me

---
 xbmc/cores/paplayer/DVDPlayerCodec.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/paplayer/DVDPlayerCodec.cpp b/xbmc/cores/paplayer/DVDPlayerCodec.cpp
index 3a35a49..31bc974 100644
--- a/xbmc/cores/paplayer/DVDPlayerCodec.cpp
+++ b/xbmc/cores/paplayer/DVDPlayerCodec.cpp
@@ -236,11 +236,13 @@ bool DVDPlayerCodec::Init(const CStdString &strFile, unsigned int filecache)
                        m_SampleRate,
                        ActiveAE::CActiveAEResample::GetAVSampleFormat(AE_FMT_FLOAT),
                        CAEUtil::DataFormatToUsedBits(AE_FMT_FLOAT),
+                       CAEUtil::DataFormatToDitherBits(AE_FMT_FLOAT),
                        ActiveAE::CActiveAEResample::GetAVChannelLayout(m_ChannelInfo),
                        m_ChannelInfo.Count(),
                        m_SampleRate,
                        ActiveAE::CActiveAEResample::GetAVSampleFormat(m_DataFormat),
                        CAEUtil::DataFormatToUsedBits(m_DataFormat),
+                       CAEUtil::DataFormatToDitherBits(m_DataFormat),
                        false,
                        false,
                        NULL,
-- 
1.9.3

