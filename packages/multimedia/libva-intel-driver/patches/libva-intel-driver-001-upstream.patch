From 763dc06dc4714158dd2cdbe35c41d2c2192c871e Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Fri, 8 Aug 2014 11:30:25 +0200
Subject: [PATCH 01/19] vebox: silence compilation warning.

Silence the following compilation warning:
  CC     i965_drv_video_la-gen75_vpp_vebox.lo
gen75_vpp_vebox.c: In function 'bdw_veb_dndi_iecp_command':
gen75_vpp_vebox.c:1537:5: warning: suggest parentheses around arithmetic in operand of '|' [-Wparentheses]

Also simplify the calculation of the VEB_DI_IECP::endingX variable
with existing helper macros.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 16 ++++++----------
 1 file changed, 6 insertions(+), 10 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index 1113c90..f452e67 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -805,8 +805,8 @@ void hsw_veb_dndi_iecp_command(VADriverContextP ctx, struct intel_vebox_context
 {
     struct intel_batchbuffer *batch = proc_ctx->batch;
     unsigned char frame_ctrl_bits = 0;
-    unsigned int startingX = 0;
-    unsigned int endingX = (proc_ctx->width_input + 63 ) / 64 * 64;
+    const unsigned int startingX = 0;
+    const unsigned int endingX = ALIGN(proc_ctx->width_input, 64) - 1;
 
     /* s1:update the previous and current input */
 /*    tempFrame = proc_ctx->frame_store[FRAME_IN_PREVIOUS];
@@ -829,9 +829,7 @@ void hsw_veb_dndi_iecp_command(VADriverContextP ctx, struct intel_vebox_context
     /*s3:set reloc buffer address */
     BEGIN_VEB_BATCH(batch, 10);
     OUT_VEB_BATCH(batch, VEB_DNDI_IECP_STATE | (10 - 2));
-    OUT_VEB_BATCH(batch,
-                  startingX << 16 |
-                  (endingX-1));
+    OUT_VEB_BATCH(batch, (startingX << 16) | endingX);
     OUT_RELOC(batch,
               proc_ctx->frame_store[FRAME_IN_CURRENT].obj_surface->bo,
               I915_GEM_DOMAIN_RENDER, 0, frame_ctrl_bits);
@@ -1532,14 +1530,12 @@ void bdw_veb_dndi_iecp_command(VADriverContextP ctx, struct intel_vebox_context
 {
     struct intel_batchbuffer *batch = proc_ctx->batch;
     unsigned char frame_ctrl_bits = 0;
-    unsigned int startingX = 0;
-    unsigned int endingX = (proc_ctx->width_input + 63 ) / 64 * 64;
+    const unsigned int startingX = 0;
+    const unsigned int endingX = ALIGN(proc_ctx->width_input, 64) - 1;
 
     BEGIN_VEB_BATCH(batch, 0x14);
     OUT_VEB_BATCH(batch, VEB_DNDI_IECP_STATE | (0x14 - 2));//DWord 0
-    OUT_VEB_BATCH(batch,
-                  startingX << 16 |
-                  endingX -1);//DWord 1
+    OUT_VEB_BATCH(batch, (startingX << 16) | endingX);
 
     OUT_RELOC(batch,
               proc_ctx->frame_store[FRAME_IN_CURRENT].obj_surface->bo,

From 65e494c4b503bceeb6fcd038bdcbff3f6ec3875e Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Fri, 8 Aug 2014 15:06:10 +0200
Subject: [PATCH 02/19] vebox: drop magic numbers in filters mask.

Use the existing VPP_{DNDI,IECP}_xxx flags instead of magic numbers.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 16 ++++++++--------
 src/gen75_vpp_vebox.h |  2 ++
 2 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index f452e67..76ecc6b 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -626,7 +626,7 @@ void hsw_veb_iecp_aoi_table(VADriverContextP ctx, struct intel_vebox_context *pr
 
 void hsw_veb_state_table_setup(VADriverContextP ctx, struct intel_vebox_context *proc_ctx)
 {
-    if(proc_ctx->filters_mask & 0x000000ff) {
+    if(proc_ctx->filters_mask & VPP_DNDI_MASK) {
         dri_bo *dndi_bo = proc_ctx->dndi_state_table.bo;
         dri_bo_map(dndi_bo, 1);
         proc_ctx->dndi_state_table.ptr = dndi_bo->virtual;
@@ -636,7 +636,7 @@ void hsw_veb_state_table_setup(VADriverContextP ctx, struct intel_vebox_context
         dri_bo_unmap(dndi_bo);
     }
 
-    if(proc_ctx->filters_mask & 0x0000ff00) {
+    if(proc_ctx->filters_mask & VPP_IECP_MASK) {
         dri_bo *iecp_bo = proc_ctx->iecp_state_table.bo;
         dri_bo_map(iecp_bo, 1);
         proc_ctx->iecp_state_table.ptr = iecp_bo->virtual;
@@ -655,9 +655,9 @@ void hsw_veb_state_table_setup(VADriverContextP ctx, struct intel_vebox_context
 void hsw_veb_state_command(VADriverContextP ctx, struct intel_vebox_context *proc_ctx)
 {
     struct intel_batchbuffer *batch = proc_ctx->batch;
-    unsigned int is_dn_enabled   = (proc_ctx->filters_mask & 0x01)? 1: 0;
-    unsigned int is_di_enabled   = (proc_ctx->filters_mask & 0x02)? 1: 0;
-    unsigned int is_iecp_enabled = (proc_ctx->filters_mask & 0xff00)?1:0;
+    unsigned int is_dn_enabled   = !!(proc_ctx->filters_mask & VPP_DNDI_DN);
+    unsigned int is_di_enabled   = !!(proc_ctx->filters_mask & VPP_DNDI_DI);
+    unsigned int is_iecp_enabled = !!(proc_ctx->filters_mask & VPP_IECP_MASK);
     unsigned int is_first_frame  = !!((proc_ctx->frame_order == -1) &&
                                       (is_di_enabled ||
                                        is_dn_enabled));
@@ -1446,9 +1446,9 @@ struct intel_vebox_context * gen75_vebox_context_init(VADriverContextP ctx)
 void bdw_veb_state_command(VADriverContextP ctx, struct intel_vebox_context *proc_ctx)
 {
     struct intel_batchbuffer *batch = proc_ctx->batch;
-    unsigned int is_dn_enabled   = (proc_ctx->filters_mask & 0x01)? 1: 0;
-    unsigned int is_di_enabled   = (proc_ctx->filters_mask & 0x02)? 1: 0;
-    unsigned int is_iecp_enabled = (proc_ctx->filters_mask & 0xff00)?1:0;
+    unsigned int is_dn_enabled   = !!(proc_ctx->filters_mask & VPP_DNDI_DN);
+    unsigned int is_di_enabled   = !!(proc_ctx->filters_mask & VPP_DNDI_DI);
+    unsigned int is_iecp_enabled = !!(proc_ctx->filters_mask & VPP_IECP_MASK);
     unsigned int is_first_frame  = !!((proc_ctx->frame_order == -1) &&
                                       (is_di_enabled ||
                                        is_dn_enabled));
diff --git a/src/gen75_vpp_vebox.h b/src/gen75_vpp_vebox.h
index a78a165..a0842b0 100644
--- a/src/gen75_vpp_vebox.h
+++ b/src/gen75_vpp_vebox.h
@@ -43,12 +43,14 @@
 
 #define VPP_DNDI_DN        0x00000001
 #define VPP_DNDI_DI        0x00000002
+#define VPP_DNDI_MASK      0x000000ff
 #define VPP_IECP_STD_STE   0x00000100
 #define VPP_IECP_ACE       0x00000200
 #define VPP_IECP_TCC       0x00000400
 #define VPP_IECP_PRO_AMP   0x00000800
 #define VPP_IECP_CSC       0x00001000
 #define VPP_IECP_AOI       0x00002000
+#define VPP_IECP_MASK      0x0000ff00
 #define MAX_FILTER_SUM     8
 
 #define PRE_FORMAT_CONVERT      0x01

From 88bbe79a7419d81b66b3fffff8d28b88c6bdba22 Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Fri, 8 Aug 2014 10:35:14 +0200
Subject: [PATCH 03/19] vebox: fix indication of field ordering in sequence.

VEBOX_DNDI_STATE::dndi_top_first indicates whether the top field is
first in sequence (TFF), or if the bottom field comes first. This is
an indication of the temporal sequence for input frames, available
in the "history" buffer. As such, the correct flag to check against,
from a VA-API perspective, is VA_DEINTERLACING_BOTTOM_FIELD_FIRST.

https://bugs.freedesktop.org/show_bug.cgi?id=72518
https://bugs.freedesktop.org/show_bug.cgi?id=72522

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index 76ecc6b..e06d8fe 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -131,7 +131,7 @@ void hsw_veb_dndi_table(VADriverContextP ctx, struct intel_vebox_context *proc_c
         assert(di_param);
 
         progressive_dn = 0;
-        dndi_top_first = !(di_param->flags & VA_DEINTERLACING_BOTTOM_FIELD);
+        dndi_top_first = !(di_param->flags & VA_DEINTERLACING_BOTTOM_FIELD_FIRST);
         motion_compensated_enable = (di_param->algorithm == VAProcDeinterlacingMotionCompensated);
     }
 

From 88d5a444a29ad84b2734da1a2692170bee3a6320 Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Fri, 8 Aug 2014 10:45:53 +0200
Subject: [PATCH 04/19] vebox: fix order of submitted commands.

For each frame, the Intel HD Graphics hardware specification mandates
that the following commands should be submitted, in-order: VEBOX_STATE,
VEBOX_SURFACE_STATE(input), VEBOX_SURFACE_STATE(output), VEB_DI_IECP.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index e06d8fe..9a60c27 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -1334,11 +1334,10 @@ VAStatus gen75_vebox_process_picture(VADriverContextP ctx,
     } else {
         intel_batchbuffer_start_atomic_veb(proc_ctx->batch, 0x1000);
         intel_batchbuffer_emit_mi_flush(proc_ctx->batch);
-        hsw_veb_surface_state(ctx, proc_ctx, INPUT_SURFACE); 
-        hsw_veb_surface_state(ctx, proc_ctx, OUTPUT_SURFACE); 
         hsw_veb_state_table_setup(ctx, proc_ctx);
-
         hsw_veb_state_command(ctx, proc_ctx);		
+        hsw_veb_surface_state(ctx, proc_ctx, INPUT_SURFACE); 
+        hsw_veb_surface_state(ctx, proc_ctx, OUTPUT_SURFACE); 
         hsw_veb_dndi_iecp_command(ctx, proc_ctx);
         intel_batchbuffer_end_atomic(proc_ctx->batch);
         intel_batchbuffer_flush(proc_ctx->batch);
@@ -1632,11 +1631,10 @@ VAStatus gen8_vebox_process_picture(VADriverContextP ctx,
     } else {
         intel_batchbuffer_start_atomic_veb(proc_ctx->batch, 0x1000);
         intel_batchbuffer_emit_mi_flush(proc_ctx->batch);
-        hsw_veb_surface_state(ctx, proc_ctx, INPUT_SURFACE); 
-        hsw_veb_surface_state(ctx, proc_ctx, OUTPUT_SURFACE); 
         hsw_veb_state_table_setup(ctx, proc_ctx);
-
         bdw_veb_state_command(ctx, proc_ctx);		
+        hsw_veb_surface_state(ctx, proc_ctx, INPUT_SURFACE); 
+        hsw_veb_surface_state(ctx, proc_ctx, OUTPUT_SURFACE); 
         bdw_veb_dndi_iecp_command(ctx, proc_ctx);
         intel_batchbuffer_end_atomic(proc_ctx->batch);
         intel_batchbuffer_flush(proc_ctx->batch);

From 5734683d3e7d7690171760ed2dd5ff10ece7b7ca Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Mon, 11 Aug 2014 16:44:31 +0200
Subject: [PATCH 05/19] vebox: fix invalid conversion and scaling params order.

The arguments to vpp_surface_convert() were mixed up. i.e. both input
and output surfaces were reversed. Changed the vpp_surface_scaling()
arguments order as well to have more consistent helper functions.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index 9a60c27..6971077 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -54,9 +54,9 @@ extern VAStatus
 i965_DestroyImage(VADriverContextP ctx, VAImageID image);
 
 
-VAStatus vpp_surface_convert(VADriverContextP ctx,
-                             struct object_surface *src_obj_surf,
-                             struct object_surface *dst_obj_surf)
+VAStatus
+vpp_surface_convert(VADriverContextP ctx, struct object_surface *src_obj_surf,
+    struct object_surface *dst_obj_surf)
 {
     VAStatus va_status = VA_STATUS_SUCCESS;
 
@@ -86,9 +86,9 @@ VAStatus vpp_surface_convert(VADriverContextP ctx,
     return va_status;
 }
 
-VAStatus vpp_surface_scaling(VADriverContextP ctx,
-                             struct object_surface *dst_obj_surf,
-                             struct object_surface *src_obj_surf)
+static VAStatus
+vpp_surface_scaling(VADriverContextP ctx, struct object_surface *src_obj_surf,
+    struct object_surface *dst_obj_surf)
 {
     VAStatus va_status = VA_STATUS_SUCCESS;
     int flags = I965_PP_FLAG_AVS;
@@ -1177,7 +1177,7 @@ int hsw_veb_pre_format_convert(VADriverContextP ctx,
              }
          }
        
-         vpp_surface_convert(ctx, proc_ctx->surface_input_vebox_object, proc_ctx->surface_input_object);
+         vpp_surface_convert(ctx, proc_ctx->surface_input_object, proc_ctx->surface_input_vebox_object);
       }
 
       /* create one temporary NV12 surfaces for conversion*/
@@ -1248,7 +1248,7 @@ int hsw_veb_post_format_convert(VADriverContextP ctx,
 
     if (proc_ctx->format_convert_flags & POST_COPY_CONVERT) {
         /* copy the saved frame in the second call */
-        vpp_surface_convert(ctx,proc_ctx->surface_output_object, obj_surface);
+        vpp_surface_convert(ctx, obj_surface, proc_ctx->surface_output_object);
     } else if(!(proc_ctx->format_convert_flags & POST_FORMAT_CONVERT) &&
        !(proc_ctx->format_convert_flags & POST_SCALING_CONVERT)){
         /* Output surface format is covered by vebox pipeline and 
@@ -1257,14 +1257,14 @@ int hsw_veb_post_format_convert(VADriverContextP ctx,
     } else if ((proc_ctx->format_convert_flags & POST_FORMAT_CONVERT) &&
                !(proc_ctx->format_convert_flags & POST_SCALING_CONVERT)){
        /* convert and copy NV12 to YV12/IMC3/IMC2/RGBA output*/
-        vpp_surface_convert(ctx,proc_ctx->surface_output_object, obj_surface);
+        vpp_surface_convert(ctx, obj_surface, proc_ctx->surface_output_object);
 
     } else if(proc_ctx->format_convert_flags & POST_SCALING_CONVERT) {
        /* scaling, convert and copy NV12 to YV12/IMC3/IMC2/RGBA output*/
         assert(obj_surface->fourcc == VA_FOURCC_NV12);
      
         /* first step :surface scaling */
-        vpp_surface_scaling(ctx,proc_ctx->surface_output_scaled_object, obj_surface);
+        vpp_surface_scaling(ctx, obj_surface, proc_ctx->surface_output_scaled_object);
 
         /* second step: color format convert and copy to output */
         obj_surface = proc_ctx->surface_output_object;
@@ -1276,7 +1276,7 @@ int hsw_veb_post_format_convert(VADriverContextP ctx,
            obj_surface->fourcc ==  VA_FOURCC_IMC1 ||
            obj_surface->fourcc ==  VA_FOURCC_IMC3 ||
            obj_surface->fourcc ==  VA_FOURCC_RGBA) {
-           vpp_surface_convert(ctx, proc_ctx->surface_output_object, proc_ctx->surface_output_scaled_object);
+            vpp_surface_convert(ctx, proc_ctx->surface_output_scaled_object, obj_surface);
        }else {
            assert(0); 
        }

From 9032a6c40c7f5e89f1d3ef5875363af7668b1690 Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Mon, 11 Aug 2014 11:44:12 +0200
Subject: [PATCH 06/19] vebox: clean-up frame store initialization.

Rename FRAME_STORE_SUM to FRAME_STORE_COUNT, use existing macros to
determine the number of elements in the frame store array, avoid
duplicate zero initializations.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 12 ++++--------
 src/gen75_vpp_vebox.h |  4 ++--
 2 files changed, 6 insertions(+), 10 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index 6971077..05694f2 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -911,7 +911,7 @@ void hsw_veb_resource_prepare(VADriverContextP ctx,
     proc_ctx->fourcc_output = output_fourcc;
    
     /* create pipeline surfaces */
-    for(i = 0; i < FRAME_STORE_SUM; i ++) {
+    for(i = 0; i < ARRAY_ELEMS(proc_ctx->frame_store); i ++) {
         if(proc_ctx->frame_store[i].obj_surface){
             continue; //refer external surface for vebox pipeline
         }
@@ -1377,7 +1377,7 @@ void gen75_vebox_context_destroy(VADriverContextP ctx,
        proc_ctx->surface_output_scaled_object = NULL;
      }
 
-    for(i = 0; i < FRAME_STORE_SUM; i ++) {
+    for(i = 0; i < ARRAY_ELEMS(proc_ctx->frame_store); i ++) {
         if (proc_ctx->frame_store[i].is_internal_surface == 1) {
             assert(proc_ctx->frame_store[i].surface_id != VA_INVALID_ID);
 
@@ -1418,13 +1418,9 @@ struct intel_vebox_context * gen75_vebox_context_init(VADriverContextP ctx)
     int i;
 
     proc_context->batch = intel_batchbuffer_new(intel, I915_EXEC_VEBOX, 0);
-    memset(proc_context->frame_store, 0, sizeof(VEBFrameStore)*FRAME_STORE_SUM);
 
-    for (i = 0; i < FRAME_STORE_SUM; i ++) {
+    for (i = 0; i < ARRAY_ELEMS(proc_context->frame_store); i++)
         proc_context->frame_store[i].surface_id = VA_INVALID_ID;
-        proc_context->frame_store[i].is_internal_surface = 0;
-        proc_context->frame_store[i].obj_surface = NULL;
-    }
   
     proc_context->filters_mask          = 0;
     proc_context->frame_order           = -1; /* the first frame */
@@ -1469,7 +1465,7 @@ void bdw_veb_state_command(VADriverContextP ctx, struct intel_vebox_context *pro
 
         if ((di_param->algorithm == VAProcDeinterlacingMotionAdaptive ||
             di_param->algorithm == VAProcDeinterlacingMotionCompensated) &&
-            proc_ctx->frame_order != -1)
+            (1||proc_ctx->frame_order != -1))
             di_output_frames_flag = 0; /* Output both Current Frame and Previous Frame */
     }
 
diff --git a/src/gen75_vpp_vebox.h b/src/gen75_vpp_vebox.h
index a0842b0..4c763e4 100644
--- a/src/gen75_vpp_vebox.h
+++ b/src/gen75_vpp_vebox.h
@@ -67,7 +67,7 @@ enum {
     FRAME_OUT_CURRENT,
     FRAME_OUT_PREVIOUS,
     FRAME_OUT_STATISTIC,
-    FRAME_STORE_SUM,
+    FRAME_STORE_COUNT,
 };
 
 enum SURFACE_FORMAT{
@@ -121,7 +121,7 @@ struct intel_vebox_context
     int width_output;
     int height_output;
 
-    VEBFrameStore frame_store[FRAME_STORE_SUM];
+    VEBFrameStore frame_store[FRAME_STORE_COUNT];
 
     VEBBuffer dndi_state_table;
     VEBBuffer iecp_state_table;

From 946800d78798a5f92131a22539e6830d7d3da476 Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Mon, 11 Aug 2014 13:52:31 +0200
Subject: [PATCH 07/19] vebox: factor out initialization of pipeline
 parameters.

Factor out initialization and validation of pipeline parameters.
In particular, introduce a new gen75_vebox_init_pipe_params() helper
function that initializes the filters mask and ensures the supplied
filters are going to be supported.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 127 ++++++++++++++++++++++----------------------------
 1 file changed, 57 insertions(+), 70 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index 05694f2..819860d 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -1285,41 +1285,60 @@ int hsw_veb_post_format_convert(VADriverContextP ctx,
     return 0;
 }
 
-VAStatus gen75_vebox_process_picture(VADriverContextP ctx,
-                         struct intel_vebox_context *proc_ctx)
+static VAStatus
+gen75_vebox_init_pipe_params(VADriverContextP ctx,
+    struct intel_vebox_context *proc_ctx)
 {
-    struct i965_driver_data *i965 = i965_driver_data(ctx);
- 
-    VAProcPipelineParameterBuffer *pipe = proc_ctx->pipeline_param;
-    VAProcFilterParameterBuffer* filter = NULL;
-    struct object_buffer *obj_buf = NULL;
+    struct i965_driver_data * const i965 = i965_driver_data(ctx);
+    const VAProcPipelineParameterBuffer * const pipe = proc_ctx->pipeline_param;
+    VAProcFilterParameterBuffer *filter;
     unsigned int i;
 
-    for (i = 0; i < pipe->num_filters; i ++) {
-         obj_buf = BUFFER(pipe->filters[i]);
-         
-         assert(obj_buf && obj_buf->buffer_store);
-
-         if (!obj_buf || !obj_buf->buffer_store)
-             goto error;
-
-         filter = (VAProcFilterParameterBuffer*)obj_buf-> buffer_store->buffer;
-            
-         if (filter->type == VAProcFilterNoiseReduction) {
-             proc_ctx->filters_mask |= VPP_DNDI_DN;
-             proc_ctx->filter_dn = filter;
-         } else if (filter->type == VAProcFilterDeinterlacing) {
-             proc_ctx->filters_mask |= VPP_DNDI_DI;
-             proc_ctx->filter_di = filter;
-         } else if (filter->type == VAProcFilterColorBalance) {
-             proc_ctx->filters_mask |= VPP_IECP_PRO_AMP;
-             proc_ctx->filter_iecp_amp = filter;
-             proc_ctx->filter_iecp_amp_num_elements = obj_buf->num_elements;
-         } else if (filter->type == VAProcFilterSkinToneEnhancement) {
-             proc_ctx->filters_mask |= VPP_IECP_STD_STE;
-             proc_ctx->filter_iecp_std = filter;
-         }
+    proc_ctx->filters_mask = 0;
+    for (i = 0; i < pipe->num_filters; i++) {
+        struct object_buffer * const obj_buffer = BUFFER(pipe->filters[i]);
+
+        assert(obj_buffer && obj_buffer->buffer_store);
+        if (!obj_buffer || !obj_buffer->buffer_store)
+            return VA_STATUS_ERROR_INVALID_PARAMETER;
+
+        filter = (VAProcFilterParameterBuffer *)
+            obj_buffer->buffer_store->buffer;
+        switch (filter->type) {
+        case VAProcFilterNoiseReduction:
+            proc_ctx->filters_mask |= VPP_DNDI_DN;
+            proc_ctx->filter_dn = filter;
+            break;
+        case VAProcFilterDeinterlacing:
+            proc_ctx->filters_mask |= VPP_DNDI_DI;
+            proc_ctx->filter_di = filter;
+            break;
+        case VAProcFilterColorBalance:
+            proc_ctx->filters_mask |= VPP_IECP_PRO_AMP;
+            proc_ctx->filter_iecp_amp = filter;
+            proc_ctx->filter_iecp_amp_num_elements = obj_buffer->num_elements;
+            break;
+        case VAProcFilterSkinToneEnhancement:
+            proc_ctx->filters_mask |= VPP_IECP_STD_STE;
+            proc_ctx->filter_iecp_std = filter;
+            break;
+        default:
+            WARN_ONCE("unsupported filter (type: %d)\n", filter->type);
+            return VA_STATUS_ERROR_UNSUPPORTED_FILTER;
+        }
     }
+    return VA_STATUS_SUCCESS;
+}
+
+VAStatus
+gen75_vebox_process_picture(VADriverContextP ctx,
+    struct intel_vebox_context *proc_ctx)
+{
+    VAStatus status;
+
+    status = gen75_vebox_init_pipe_params(ctx, proc_ctx);
+    if (status != VA_STATUS_SUCCESS)
+        return status;
 
     hsw_veb_pre_format_convert(ctx, proc_ctx);
     hsw_veb_surface_reference(ctx, proc_ctx);
@@ -1349,9 +1368,6 @@ VAStatus gen75_vebox_process_picture(VADriverContextP ctx,
     proc_ctx->frame_order = (proc_ctx->frame_order + 1) % 2;
      
     return VA_STATUS_SUCCESS;
-
-error:
-    return VA_STATUS_ERROR_INVALID_PARAMETER;
 }
 
 void gen75_vebox_context_destroy(VADriverContextP ctx, 
@@ -1578,41 +1594,15 @@ void bdw_veb_dndi_iecp_command(VADriverContextP ctx, struct intel_vebox_context
     ADVANCE_VEB_BATCH(batch);
 }
 
-VAStatus gen8_vebox_process_picture(VADriverContextP ctx,
-                         struct intel_vebox_context *proc_ctx)
+VAStatus
+gen8_vebox_process_picture(VADriverContextP ctx,
+    struct intel_vebox_context *proc_ctx)
 {
-    struct i965_driver_data *i965 = i965_driver_data(ctx);
- 
-    VAProcPipelineParameterBuffer *pipe = proc_ctx->pipeline_param;
-    VAProcFilterParameterBuffer* filter = NULL;
-    struct object_buffer *obj_buf = NULL;
-    unsigned int i;
+    VAStatus status;
 
-    for (i = 0; i < pipe->num_filters; i ++) {
-         obj_buf = BUFFER(pipe->filters[i]);
-         
-         assert(obj_buf && obj_buf->buffer_store);
-
-         if (!obj_buf || !obj_buf->buffer_store)
-             goto error;
-
-         filter = (VAProcFilterParameterBuffer*)obj_buf-> buffer_store->buffer;
-            
-         if (filter->type == VAProcFilterNoiseReduction) {
-             proc_ctx->filters_mask |= VPP_DNDI_DN;
-             proc_ctx->filter_dn = filter;
-         } else if (filter->type == VAProcFilterDeinterlacing) {
-             proc_ctx->filters_mask |= VPP_DNDI_DI;
-             proc_ctx->filter_di = filter;
-         } else if (filter->type == VAProcFilterColorBalance) {
-             proc_ctx->filters_mask |= VPP_IECP_PRO_AMP;
-             proc_ctx->filter_iecp_amp = filter;
-             proc_ctx->filter_iecp_amp_num_elements = obj_buf->num_elements;
-         } else if (filter->type == VAProcFilterSkinToneEnhancement) {
-             proc_ctx->filters_mask |= VPP_IECP_STD_STE;
-             proc_ctx->filter_iecp_std = filter;
-         }
-    }
+    status = gen75_vebox_init_pipe_params(ctx, proc_ctx);
+    if (status != VA_STATUS_SUCCESS)
+        return status;
 
     hsw_veb_pre_format_convert(ctx, proc_ctx);
     hsw_veb_surface_reference(ctx, proc_ctx);
@@ -1642,8 +1632,5 @@ VAStatus gen8_vebox_process_picture(VADriverContextP ctx,
     proc_ctx->frame_order = (proc_ctx->frame_order + 1) % 2;
      
     return VA_STATUS_SUCCESS;
-
-error:
-    return VA_STATUS_ERROR_INVALID_PARAMETER;
 }
 

From 0ec9fa6158c3f52288c43ad030caeca684038657 Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Mon, 11 Aug 2014 14:37:41 +0200
Subject: [PATCH 08/19] vebox: robustify frame store surface storage
 allocations.

Clean-up frame store surface storage allocation, rename the helper
function to gen75_vebox_ensure_surfaces_storage() and make it more
robust to allocation errors. i.e. propagate them up right away.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 206 ++++++++++++++++++++++++++++----------------------
 1 file changed, 115 insertions(+), 91 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index 819860d..264c4fc 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -858,123 +858,143 @@ void hsw_veb_dndi_iecp_command(VADriverContextP ctx, struct intel_vebox_context
     ADVANCE_VEB_BATCH(batch);
 }
 
-void hsw_veb_resource_prepare(VADriverContextP ctx,
-                              struct intel_vebox_context *proc_ctx)
+static VAStatus
+gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
+    struct intel_vebox_context *proc_ctx)
 {
-    VAStatus va_status;
-    dri_bo *bo;
-    struct i965_driver_data *i965 = i965_driver_data(ctx);
+    struct i965_driver_data * const i965 = i965_driver_data(ctx);
+    struct object_surface *input_obj_surface, *output_obj_surface;
     unsigned int input_fourcc, output_fourcc;
     unsigned int input_sampling, output_sampling;
     unsigned int input_tiling, output_tiling;
     unsigned int i, swizzle;
-    struct object_surface *obj_surf_out = NULL, *obj_surf_in = NULL;
-
-    if (proc_ctx->surface_input_vebox_object != NULL) {
-        obj_surf_in = proc_ctx->surface_input_vebox_object;
-    } else {
-        obj_surf_in = proc_ctx->surface_input_object;
-    } 
-
-    if (proc_ctx->surface_output_vebox_object != NULL) {
-        obj_surf_out = proc_ctx->surface_output_vebox_object;
-    } else {
-        obj_surf_out = proc_ctx->surface_output_object;
-    } 
+    drm_intel_bo *bo;
+    VAStatus status;
 
-    if(obj_surf_in->bo == NULL){
-          input_fourcc = VA_FOURCC_NV12;
-          input_sampling = SUBSAMPLE_YUV420;
-          input_tiling = 0;
-          i965_check_alloc_surface_bo(ctx, obj_surf_in, input_tiling, input_fourcc, input_sampling);
-    } else {
-        input_fourcc = obj_surf_in->fourcc;
-        input_sampling = obj_surf_in->subsampling;
-        dri_bo_get_tiling(obj_surf_in->bo, &input_tiling, &swizzle);
+    /* Determine input surface info. Use native VEBOX format whenever
+       possible. i.e. when the input surface format is not supported
+       by the VEBOX engine, then allocate a temporary surface (live
+       during the whole VPP pipeline lifetime)
+
+       XXX: derive an actual surface format compatible with the input
+       surface chroma format */
+    input_obj_surface = proc_ctx->surface_input_vebox_object ?
+        proc_ctx->surface_input_vebox_object : proc_ctx->surface_input_object;
+    if (input_obj_surface->bo) {
+        input_fourcc = input_obj_surface->fourcc;
+        input_sampling = input_obj_surface->subsampling;
+        dri_bo_get_tiling(input_obj_surface->bo, &input_tiling, &swizzle);
         input_tiling = !!input_tiling;
     }
+    else {
+        input_fourcc = VA_FOURCC_NV12;
+        input_sampling = SUBSAMPLE_YUV420;
+        input_tiling = 0;
+        status = i965_check_alloc_surface_bo(ctx, input_obj_surface,
+            input_tiling, input_fourcc, input_sampling);
+        if (status != VA_STATUS_SUCCESS)
+            return status;
+    }
 
-    if(obj_surf_out->bo == NULL){
-          output_fourcc = VA_FOURCC_NV12;
-          output_sampling = SUBSAMPLE_YUV420;
-          output_tiling = 0;
-          i965_check_alloc_surface_bo(ctx, obj_surf_out, output_tiling, output_fourcc, output_sampling);
-    }else {
-        output_fourcc   = obj_surf_out->fourcc;
-        output_sampling = obj_surf_out->subsampling;
-        dri_bo_get_tiling(obj_surf_out->bo, &output_tiling, &swizzle);
+    /* Determine output surface info.
+
+       XXX: derive an actual surface format compatible with the input
+       surface chroma format */
+    output_obj_surface = proc_ctx->surface_output_vebox_object ?
+        proc_ctx->surface_output_vebox_object : proc_ctx->surface_output_object;
+    if (output_obj_surface->bo) {
+        output_fourcc   = output_obj_surface->fourcc;
+        output_sampling = output_obj_surface->subsampling;
+        dri_bo_get_tiling(output_obj_surface->bo, &output_tiling, &swizzle);
         output_tiling = !!output_tiling;
     }
+    else {
+        output_fourcc = VA_FOURCC_NV12;
+        output_sampling = SUBSAMPLE_YUV420;
+        output_tiling = 0;
+        status = i965_check_alloc_surface_bo(ctx, output_obj_surface,
+            output_tiling, output_fourcc, output_sampling);
+        if (status != VA_STATUS_SUCCESS)
+            return status;
+    }
 
-    /* vebox pipelien input surface format info */
+    /* Update VEBOX pipeline formats */
     proc_ctx->fourcc_input = input_fourcc;
     proc_ctx->fourcc_output = output_fourcc;
    
-    /* create pipeline surfaces */
-    for(i = 0; i < ARRAY_ELEMS(proc_ctx->frame_store); i ++) {
-        if(proc_ctx->frame_store[i].obj_surface){
-            continue; //refer external surface for vebox pipeline
-        }
-    
+    /* Create pipeline surfaces */
+    for (i = 0; i < ARRAY_ELEMS(proc_ctx->frame_store); i ++) {
+        struct object_surface *obj_surface;
         VASurfaceID new_surface;
-        struct object_surface *obj_surf = NULL;
-
-        va_status =   i965_CreateSurfaces(ctx,
-                                          proc_ctx ->width_input,
-                                          proc_ctx ->height_input,
-                                          VA_RT_FORMAT_YUV420,
-                                          1,
-                                          &new_surface);
-        assert(va_status == VA_STATUS_SUCCESS);
-
-        obj_surf = SURFACE(new_surface);
-        assert(obj_surf);
-
-        if( i <= FRAME_IN_PREVIOUS || i == FRAME_OUT_CURRENT_DN) {
-            i965_check_alloc_surface_bo(ctx, obj_surf, input_tiling, input_fourcc, input_sampling);
-        } else if( i == FRAME_IN_STMM || i == FRAME_OUT_STMM){
-            i965_check_alloc_surface_bo(ctx, obj_surf, 1, input_fourcc, input_sampling);
-        } else if( i >= FRAME_OUT_CURRENT){
-            i965_check_alloc_surface_bo(ctx, obj_surf, output_tiling, output_fourcc, output_sampling);
+
+        if (proc_ctx->frame_store[i].obj_surface)
+            continue; // user allocated surface, not VEBOX internal
+
+        status = i965_CreateSurfaces(ctx, proc_ctx->width_input,
+            proc_ctx->height_input, VA_RT_FORMAT_YUV420, 1, &new_surface);
+        if (status != VA_STATUS_SUCCESS)
+            return status;
+
+        obj_surface = SURFACE(new_surface);
+        assert(obj_surface != NULL);
+
+        if (i <= FRAME_IN_PREVIOUS || i == FRAME_OUT_CURRENT_DN) {
+            status = i965_check_alloc_surface_bo(ctx, obj_surface,
+                input_tiling, input_fourcc, input_sampling);
+        }
+        else if (i == FRAME_IN_STMM || i == FRAME_OUT_STMM) {
+            status = i965_check_alloc_surface_bo(ctx, obj_surface,
+                1, input_fourcc, input_sampling);
         }
+        else if (i >= FRAME_OUT_CURRENT) {
+            status = i965_check_alloc_surface_bo(ctx, obj_surface,
+                output_tiling, output_fourcc, output_sampling);
+        }
+        if (status != VA_STATUS_SUCCESS)
+            return status;
 
         proc_ctx->frame_store[i].surface_id = new_surface;
         proc_ctx->frame_store[i].is_internal_surface = 1;
-        proc_ctx->frame_store[i].obj_surface = obj_surf;
+        proc_ctx->frame_store[i].obj_surface = obj_surface;
     }
 
-    /* alloc dndi state table  */
-    dri_bo_unreference(proc_ctx->dndi_state_table.bo);
-    bo = dri_bo_alloc(i965->intel.bufmgr,
-                      "vebox: dndi state Buffer",
-                      0x1000, 0x1000);
+    /* Allocate DNDI state table  */
+    drm_intel_bo_unreference(proc_ctx->dndi_state_table.bo);
+    bo = drm_intel_bo_alloc(i965->intel.bufmgr, "vebox: dndi state Buffer",
+        0x1000, 0x1000);
     proc_ctx->dndi_state_table.bo = bo;
-    dri_bo_reference(proc_ctx->dndi_state_table.bo);
+    if (!bo)
+        return VA_STATUS_ERROR_ALLOCATION_FAILED;
+    drm_intel_bo_reference(proc_ctx->dndi_state_table.bo);
  
-    /* alloc iecp state table  */
-    dri_bo_unreference(proc_ctx->iecp_state_table.bo);
-    bo = dri_bo_alloc(i965->intel.bufmgr,
-                      "vebox: iecp state Buffer",
-                      0x1000, 0x1000);
+    /* Allocate IECP state table  */
+    drm_intel_bo_unreference(proc_ctx->iecp_state_table.bo);
+    bo = drm_intel_bo_alloc(i965->intel.bufmgr, "vebox: iecp state Buffer",
+        0x1000, 0x1000);
     proc_ctx->iecp_state_table.bo = bo;
-    dri_bo_reference(proc_ctx->iecp_state_table.bo);
-
-    /* alloc gamut state table  */
-    dri_bo_unreference(proc_ctx->gamut_state_table.bo);
-    bo = dri_bo_alloc(i965->intel.bufmgr,
-                      "vebox: gamut state Buffer",
-                      0x1000, 0x1000);
+    if (!bo)
+        return VA_STATUS_ERROR_ALLOCATION_FAILED;
+    drm_intel_bo_reference(proc_ctx->iecp_state_table.bo);
+
+    /* Allocate Gamut state table  */
+    drm_intel_bo_unreference(proc_ctx->gamut_state_table.bo);
+    bo = drm_intel_bo_alloc(i965->intel.bufmgr, "vebox: gamut state Buffer",
+        0x1000, 0x1000);
     proc_ctx->gamut_state_table.bo = bo;
-    dri_bo_reference(proc_ctx->gamut_state_table.bo);
-
-    /* alloc vertex state table  */
-    dri_bo_unreference(proc_ctx->vertex_state_table.bo);
-    bo = dri_bo_alloc(i965->intel.bufmgr,
-                      "vertex: iecp state Buffer",
-                      0x1000, 0x1000);
+    if (!bo)
+        return VA_STATUS_ERROR_ALLOCATION_FAILED;
+    drm_intel_bo_reference(proc_ctx->gamut_state_table.bo);
+
+    /* Allocate vertex state table  */
+    drm_intel_bo_unreference(proc_ctx->vertex_state_table.bo);
+    bo = drm_intel_bo_alloc(i965->intel.bufmgr, "vebox: vertex state Buffer",
+        0x1000, 0x1000);
     proc_ctx->vertex_state_table.bo = bo;
-    dri_bo_reference(proc_ctx->vertex_state_table.bo);
+    if (!bo)
+        return VA_STATUS_ERROR_ALLOCATION_FAILED;
+    drm_intel_bo_reference(proc_ctx->vertex_state_table.bo);
 
+    return VA_STATUS_SUCCESS;
 }
 
 static VAStatus
@@ -1344,7 +1364,9 @@ gen75_vebox_process_picture(VADriverContextP ctx,
     hsw_veb_surface_reference(ctx, proc_ctx);
 
     if (proc_ctx->frame_order == -1) {
-        hsw_veb_resource_prepare(ctx, proc_ctx);
+        status = gen75_vebox_ensure_surfaces_storage(ctx, proc_ctx);
+        if (status != VA_STATUS_SUCCESS)
+            return status;
     }
 
     if (proc_ctx->format_convert_flags & POST_COPY_CONVERT) {
@@ -1608,7 +1630,9 @@ gen8_vebox_process_picture(VADriverContextP ctx,
     hsw_veb_surface_reference(ctx, proc_ctx);
 
     if (proc_ctx->frame_order == -1) {
-        hsw_veb_resource_prepare(ctx, proc_ctx);
+        status = gen75_vebox_ensure_surfaces_storage(ctx, proc_ctx);
+        if (status != VA_STATUS_SUCCESS)
+            return status;
     }
 
     if (proc_ctx->format_convert_flags & POST_COPY_CONVERT) {

From 9c6262410ffa972d8871a023c63e38d307ea37f9 Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Mon, 11 Aug 2014 13:55:37 +0200
Subject: [PATCH 09/19] vebox: factor out deinterlacing code.

Completely rework the VEBOX code to factor out and improve the various
deinterlacing algorithms in particular. Introduce temporary variables
that are going to be live for the current VPP processing call.

Drop MADI/MCDI support for now.

Initial focus was to definitively fix first vs. second field detection
code, thus allowing more multiple VEBOX calls with an additional format
conversion away.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 380 ++++++++++++++++++++------------------------------
 src/gen75_vpp_vebox.h |  13 +-
 2 files changed, 165 insertions(+), 228 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index 264c4fc..b060ae2 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -53,7 +53,6 @@ i965_DeriveImage(VADriverContextP ctx, VABufferID surface, VAImage *out_image);
 extern VAStatus
 i965_DestroyImage(VADriverContextP ctx, VAImageID image);
 
-
 VAStatus
 vpp_surface_convert(VADriverContextP ctx, struct object_surface *src_obj_surf,
     struct object_surface *dst_obj_surf)
@@ -121,18 +120,24 @@ void hsw_veb_dndi_table(VADriverContextP ctx, struct intel_vebox_context *proc_c
 {
     struct i965_driver_data *i965 = i965_driver_data(ctx);
     unsigned int* p_table ;
-    int progressive_dn = 1;
-    int dndi_top_first = 0;
-    int motion_compensated_enable = 0;
+    unsigned int progressive_dn = 1;
+    unsigned int dndi_top_first = 0;
+    unsigned int is_mcdi_enabled = 0;
 
-    if (proc_ctx->filters_mask & VPP_DNDI_DI) {
-        VAProcFilterParameterBufferDeinterlacing *di_param =
-            (VAProcFilterParameterBufferDeinterlacing *)proc_ctx->filter_di;
-        assert(di_param);
+    if (proc_ctx->is_di_enabled) {
+        const VAProcFilterParameterBufferDeinterlacing * const deint_params =
+            proc_ctx->filter_di;
 
         progressive_dn = 0;
-        dndi_top_first = !(di_param->flags & VA_DEINTERLACING_BOTTOM_FIELD_FIRST);
-        motion_compensated_enable = (di_param->algorithm == VAProcDeinterlacingMotionCompensated);
+
+        /* If we are in "First Frame" mode, i.e. past frames are not
+           available for motion measure, then don't use the TFF flag */
+        dndi_top_first = !(deint_params->flags & (proc_ctx->is_first_frame ?
+                VA_DEINTERLACING_BOTTOM_FIELD :
+                VA_DEINTERLACING_BOTTOM_FIELD_FIRST));
+
+        is_mcdi_enabled =
+            (deint_params->algorithm == VAProcDeinterlacingMotionCompensated);
     }
 
     /*
@@ -193,7 +198,7 @@ void hsw_veb_dndi_table(VADriverContextP ctx, struct intel_vebox_context *proc_c
                     100<< 16  |  // FMD #2 vertical difference th
                     0  << 14  |  // CAT th1
                     2  << 8   |  // FMD tear threshold
-                    motion_compensated_enable  << 7   |  // MCDI Enable, use motion compensated deinterlace algorithm
+                    is_mcdi_enabled  << 7  |  // MCDI Enable, use motion compensated deinterlace algorithm
                     progressive_dn  << 6   |  // progressive DN
                     0  << 4   |  // reserved
                     dndi_top_first  << 3   |  // DN/DI Top First
@@ -655,33 +660,6 @@ void hsw_veb_state_table_setup(VADriverContextP ctx, struct intel_vebox_context
 void hsw_veb_state_command(VADriverContextP ctx, struct intel_vebox_context *proc_ctx)
 {
     struct intel_batchbuffer *batch = proc_ctx->batch;
-    unsigned int is_dn_enabled   = !!(proc_ctx->filters_mask & VPP_DNDI_DN);
-    unsigned int is_di_enabled   = !!(proc_ctx->filters_mask & VPP_DNDI_DI);
-    unsigned int is_iecp_enabled = !!(proc_ctx->filters_mask & VPP_IECP_MASK);
-    unsigned int is_first_frame  = !!((proc_ctx->frame_order == -1) &&
-                                      (is_di_enabled ||
-                                       is_dn_enabled));
-    unsigned int di_output_frames_flag = 2; /* Output Current Frame Only */
-
-    if(proc_ctx->fourcc_input != proc_ctx->fourcc_output ||
-       (is_dn_enabled == 0 && is_di_enabled == 0)){
-       is_iecp_enabled = 1;
-    }
-
-    if (is_di_enabled) {
-        VAProcFilterParameterBufferDeinterlacing *di_param =
-            (VAProcFilterParameterBufferDeinterlacing *)proc_ctx->filter_di;
-
-        assert(di_param);
-        
-        if (di_param->algorithm == VAProcDeinterlacingBob)
-            is_first_frame = 1;
-
-        if ((di_param->algorithm == VAProcDeinterlacingMotionAdaptive ||
-            di_param->algorithm == VAProcDeinterlacingMotionCompensated) &&
-            proc_ctx->frame_order != -1)
-            di_output_frames_flag = 0; /* Output both Current Frame and Previous Frame */
-    }
 
     BEGIN_VEB_BATCH(batch, 6);
     OUT_VEB_BATCH(batch, VEB_STATE | (6 - 2));
@@ -689,13 +667,13 @@ void hsw_veb_state_command(VADriverContextP ctx, struct intel_vebox_context *pro
                   0 << 26 |       // state surface control bits
                   0 << 11 |       // reserved.
                   0 << 10 |       // pipe sync disable
-                  di_output_frames_flag << 8  |       // DI output frame
+                  proc_ctx->current_output_type << 8  | // DI output frame
                   1 << 7  |       // 444->422 downsample method
                   1 << 6  |       // 422->420 downsample method
-                  is_first_frame  << 5  |   // DN/DI first frame
-                  is_di_enabled   << 4  |             // DI enable
-                  is_dn_enabled   << 3  |             // DN enable
-                  is_iecp_enabled << 2  |             // global IECP enabled
+                  proc_ctx->is_first_frame  << 5  |   // DN/DI first frame
+                  proc_ctx->is_di_enabled   << 4  |   // DI enable
+                  proc_ctx->is_dn_enabled   << 3  |   // DN enable
+                  proc_ctx->is_iecp_enabled << 2  |   // global IECP enabled
                   0 << 1  |       // ColorGamutCompressionEnable
                   0 ) ;           // ColorGamutExpansionEnable.
 
@@ -921,6 +899,8 @@ gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
     /* Update VEBOX pipeline formats */
     proc_ctx->fourcc_input = input_fourcc;
     proc_ctx->fourcc_output = output_fourcc;
+    if (input_fourcc != output_fourcc)
+        proc_ctx->is_iecp_enabled = 1; // IECP needed for format conversion
    
     /* Create pipeline surfaces */
     for (i = 0; i < ARRAY_ELEMS(proc_ctx->frame_store); i ++) {
@@ -953,9 +933,8 @@ gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
         if (status != VA_STATUS_SUCCESS)
             return status;
 
-        proc_ctx->frame_store[i].surface_id = new_surface;
-        proc_ctx->frame_store[i].is_internal_surface = 1;
         proc_ctx->frame_store[i].obj_surface = obj_surface;
+        proc_ctx->frame_store[i].is_internal_surface = 1;
     }
 
     /* Allocate DNDI state table  */
@@ -998,139 +977,62 @@ gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
 }
 
 static VAStatus
-hsw_veb_surface_reference(VADriverContextP ctx,
-                          struct intel_vebox_context *proc_ctx)
+gen75_vebox_ensure_surfaces(VADriverContextP ctx,
+    struct intel_vebox_context *proc_ctx)
 {
-    struct object_surface * obj_surf; 
-    VEBFrameStore tmp_store;
+    struct object_surface *obj_surface;
+    VEBFrameStore *ifs, *ofs;
+    bool is_new_frame = 0;
+    int i;
 
-    if (proc_ctx->surface_input_vebox_object != NULL) {
-        obj_surf = proc_ctx->surface_input_vebox_object;
-    } else {
-        obj_surf = proc_ctx->surface_input_object;
-    } 
-
-    /* update the input surface */ 
-    proc_ctx->frame_store[FRAME_IN_CURRENT].surface_id = VA_INVALID_ID;
-    proc_ctx->frame_store[FRAME_IN_CURRENT].is_internal_surface = 0;
-    proc_ctx->frame_store[FRAME_IN_CURRENT].obj_surface = obj_surf;
-
-    /* update the previous input surface */
-    if (proc_ctx->frame_order != -1) {
-        if (proc_ctx->filters_mask == VPP_DNDI_DN) {
-            proc_ctx->frame_store[FRAME_IN_PREVIOUS] = proc_ctx->frame_store[FRAME_OUT_CURRENT_DN];
-        } else if (proc_ctx->filters_mask & VPP_DNDI_DI) {
-            VAProcFilterParameterBufferDeinterlacing *di_param =
-                (VAProcFilterParameterBufferDeinterlacing *)proc_ctx->filter_di;
-
-            if (di_param && 
-                (di_param->algorithm == VAProcDeinterlacingMotionAdaptive ||
-                di_param->algorithm == VAProcDeinterlacingMotionCompensated)) {
-                if ((proc_ctx->filters_mask & VPP_DNDI_DN) &&
-                    proc_ctx->frame_order == 0) { /* DNDI */
-                    tmp_store = proc_ctx->frame_store[FRAME_OUT_CURRENT_DN];
-                    proc_ctx->frame_store[FRAME_OUT_CURRENT_DN] = proc_ctx->frame_store[FRAME_IN_PREVIOUS];
-                    proc_ctx->frame_store[FRAME_IN_PREVIOUS] = tmp_store;
-                } else { /* DI only */
-                    VAProcPipelineParameterBuffer *pipe = proc_ctx->pipeline_param;
-                    struct object_surface *obj_surf = NULL;
-                    struct i965_driver_data * const i965 = i965_driver_data(ctx);
-
-                    if (!pipe ||
-                        !pipe->num_forward_references ||
-                        pipe->forward_references[0] == VA_INVALID_ID) {
-                        WARN_ONCE("A forward temporal reference is needed for Motion adaptive/compensated deinterlacing !!!\n");
-
-                        return VA_STATUS_ERROR_INVALID_PARAMETER;
-                    }
-
-                    obj_surf = SURFACE(pipe->forward_references[0]);
-                    assert(obj_surf && obj_surf->bo);
-                
-                    proc_ctx->frame_store[FRAME_IN_PREVIOUS].surface_id = pipe->forward_references[0];
-                    proc_ctx->frame_store[FRAME_IN_PREVIOUS].is_internal_surface = 0;
-                    proc_ctx->frame_store[FRAME_IN_PREVIOUS].obj_surface = obj_surf;
-                }
-            }
-        }
+    /* Update the previous input surface */
+    obj_surface = proc_ctx->surface_input_object;
+
+    is_new_frame = proc_ctx->frame_store[FRAME_IN_CURRENT].surface_id !=
+        obj_surface->base.id;
+
+    /* Update the input surface */
+    obj_surface = proc_ctx->surface_input_vebox_object ?
+        proc_ctx->surface_input_vebox_object : proc_ctx->surface_input_object;
+
+    ifs = &proc_ctx->frame_store[FRAME_IN_CURRENT];
+    ifs->obj_surface = obj_surface;
+    ifs->surface_id = proc_ctx->surface_input_object->base.id;
+    ifs->is_internal_surface = proc_ctx->surface_input_vebox_object != NULL;
+
+    /* Update the Spatial Temporal Motion Measure (STMM) surfaces */
+    if (is_new_frame) {
+        const VEBFrameStore tmpfs = proc_ctx->frame_store[FRAME_IN_STMM];
+        proc_ctx->frame_store[FRAME_IN_STMM] =
+            proc_ctx->frame_store[FRAME_OUT_STMM];
+        proc_ctx->frame_store[FRAME_OUT_STMM] = tmpfs;
     }
 
-    /* update STMM surface */
-    if (proc_ctx->frame_order != -1) {
-        tmp_store = proc_ctx->frame_store[FRAME_IN_STMM];
-        proc_ctx->frame_store[FRAME_IN_STMM] = proc_ctx->frame_store[FRAME_OUT_STMM];
-        proc_ctx->frame_store[FRAME_OUT_STMM] = tmp_store;
+    /* Reset the output surfaces to defaults. i.e. clean from user surfaces */
+    for (i = FRAME_OUT_CURRENT_DN; i <= FRAME_OUT_PREVIOUS; i++) {
+        ofs = &proc_ctx->frame_store[i];
+        if (!ofs->is_internal_surface)
+            ofs->obj_surface = NULL;
+        ofs->surface_id = proc_ctx->surface_input_object->base.id;
     }
 
-    /* update the output surface */ 
-    if (proc_ctx->surface_output_vebox_object != NULL) {
-        obj_surf = proc_ctx->surface_output_vebox_object;
-    } else {
-        obj_surf = proc_ctx->surface_output_object;
-    } 
+    /* Update the output surfaces */
+    obj_surface = proc_ctx->surface_output_vebox_object ?
+        proc_ctx->surface_output_vebox_object : proc_ctx->surface_output_object;
 
-    if (proc_ctx->filters_mask == VPP_DNDI_DN) {
-        proc_ctx->frame_store[FRAME_OUT_CURRENT_DN].surface_id = VA_INVALID_ID;
-        proc_ctx->frame_store[FRAME_OUT_CURRENT_DN].is_internal_surface = 0;
-        proc_ctx->frame_store[FRAME_OUT_CURRENT_DN].obj_surface = obj_surf;
+    proc_ctx->current_output_type = 2;
+    if (proc_ctx->filters_mask == VPP_DNDI_DN)
         proc_ctx->current_output = FRAME_OUT_CURRENT_DN;
-    } else if (proc_ctx->filters_mask & VPP_DNDI_DI) {
-        VAProcFilterParameterBufferDeinterlacing *di_param =
-            (VAProcFilterParameterBufferDeinterlacing *)proc_ctx->filter_di;
-
-        if (di_param && 
-            (di_param->algorithm == VAProcDeinterlacingMotionAdaptive ||
-            di_param->algorithm == VAProcDeinterlacingMotionCompensated)) {
-            if (proc_ctx->frame_order == -1) {
-                proc_ctx->frame_store[FRAME_OUT_CURRENT].surface_id = VA_INVALID_ID;
-                proc_ctx->frame_store[FRAME_OUT_CURRENT].is_internal_surface = 0;
-                proc_ctx->frame_store[FRAME_OUT_CURRENT].obj_surface = obj_surf;
-                proc_ctx->current_output = FRAME_OUT_CURRENT;
-            } else if (proc_ctx->frame_order == 0) {
-                proc_ctx->frame_store[FRAME_OUT_PREVIOUS].surface_id = VA_INVALID_ID;
-                proc_ctx->frame_store[FRAME_OUT_PREVIOUS].is_internal_surface = 0;
-                proc_ctx->frame_store[FRAME_OUT_PREVIOUS].obj_surface = obj_surf;
-                proc_ctx->current_output = FRAME_OUT_PREVIOUS;
-            } else {
-                proc_ctx->current_output = FRAME_OUT_CURRENT;
-                proc_ctx->format_convert_flags |= POST_COPY_CONVERT;
-            }
-        } else {
-            proc_ctx->frame_store[FRAME_OUT_CURRENT].surface_id = VA_INVALID_ID;
-            proc_ctx->frame_store[FRAME_OUT_CURRENT].is_internal_surface = 0;
-            proc_ctx->frame_store[FRAME_OUT_CURRENT].obj_surface = obj_surf;
-            proc_ctx->current_output = FRAME_OUT_CURRENT;
-        }
-    } else {
-        proc_ctx->frame_store[FRAME_OUT_CURRENT].surface_id = VA_INVALID_ID;
-        proc_ctx->frame_store[FRAME_OUT_CURRENT].is_internal_surface = 0;
-        proc_ctx->frame_store[FRAME_OUT_CURRENT].obj_surface = obj_surf;
+    else
         proc_ctx->current_output = FRAME_OUT_CURRENT;
-    }
+    ofs = &proc_ctx->frame_store[proc_ctx->current_output];
+    ofs->obj_surface = obj_surface;
+    ofs->surface_id = proc_ctx->surface_input_object->base.id;
+    ofs->is_internal_surface = proc_ctx->surface_output_vebox_object != NULL;
 
     return VA_STATUS_SUCCESS;
 }
 
-void hsw_veb_surface_unreference(VADriverContextP ctx,
-                                 struct intel_vebox_context *proc_ctx)
-{
-    /* unreference the input surface */ 
-    proc_ctx->frame_store[FRAME_IN_CURRENT].surface_id = VA_INVALID_ID;
-    proc_ctx->frame_store[FRAME_IN_CURRENT].is_internal_surface = 0;
-    proc_ctx->frame_store[FRAME_IN_CURRENT].obj_surface = NULL;
-
-    /* unreference the shared output surface */ 
-    if (proc_ctx->filters_mask == VPP_DNDI_DN) {
-        proc_ctx->frame_store[FRAME_OUT_CURRENT_DN].surface_id = VA_INVALID_ID;
-        proc_ctx->frame_store[FRAME_OUT_CURRENT_DN].is_internal_surface = 0;
-        proc_ctx->frame_store[FRAME_OUT_CURRENT_DN].obj_surface = NULL;
-    } else {
-        proc_ctx->frame_store[FRAME_OUT_CURRENT].surface_id = VA_INVALID_ID;
-        proc_ctx->frame_store[FRAME_OUT_CURRENT].is_internal_surface = 0;
-        proc_ctx->frame_store[FRAME_OUT_CURRENT].obj_surface = NULL;
-    }
-}
-
 int hsw_veb_pre_format_convert(VADriverContextP ctx,
                            struct intel_vebox_context *proc_ctx)
 {
@@ -1350,6 +1252,58 @@ gen75_vebox_init_pipe_params(VADriverContextP ctx,
     return VA_STATUS_SUCCESS;
 }
 
+static VAStatus
+gen75_vebox_init_filter_params(VADriverContextP ctx,
+    struct intel_vebox_context *proc_ctx)
+{
+    proc_ctx->format_convert_flags = 0; /* initialized in hsw_veb_pre_format_convert() */
+
+    proc_ctx->is_iecp_enabled = (proc_ctx->filters_mask & VPP_IECP_MASK) != 0;
+    proc_ctx->is_dn_enabled = (proc_ctx->filters_mask & VPP_DNDI_DN) != 0;
+    proc_ctx->is_di_enabled = (proc_ctx->filters_mask & VPP_DNDI_DI) != 0;
+    proc_ctx->is_first_frame = 0;
+    proc_ctx->is_second_field = 0;
+
+    /* Check whether we are deinterlacing the second field */
+    if (proc_ctx->is_di_enabled) {
+        const VAProcFilterParameterBufferDeinterlacing * const deint_params =
+            proc_ctx->filter_di;
+
+        const unsigned int tff =
+            !(deint_params->flags & VA_DEINTERLACING_BOTTOM_FIELD_FIRST);
+        const unsigned int is_top_field =
+            !(deint_params->flags & VA_DEINTERLACING_BOTTOM_FIELD);
+
+        if ((tff ^ is_top_field) != 0) {
+            struct object_surface * const obj_surface =
+                proc_ctx->surface_input_object;
+
+            if (proc_ctx->frame_store[FRAME_IN_CURRENT].surface_id != obj_surface->base.id) {
+                WARN_ONCE("invalid surface provided for second field\n");
+                return VA_STATUS_ERROR_INVALID_PARAMETER;
+            }
+            proc_ctx->is_second_field = 1;
+        }
+    }
+
+    /* Check whether we are deinterlacing the first frame */
+    if (proc_ctx->is_di_enabled) {
+        const VAProcFilterParameterBufferDeinterlacing * const deint_params =
+            proc_ctx->filter_di;
+
+        switch (deint_params->algorithm) {
+        case VAProcDeinterlacingBob:
+            proc_ctx->is_first_frame = 1;
+            break;
+        default:
+            WARN_ONCE("unsupported deinterlacing algorithm (%d)\n",
+                      deint_params->algorithm);
+            return VA_STATUS_ERROR_UNSUPPORTED_FILTER;
+        }
+    }
+    return VA_STATUS_SUCCESS;
+}
+
 VAStatus
 gen75_vebox_process_picture(VADriverContextP ctx,
     struct intel_vebox_context *proc_ctx)
@@ -1360,17 +1314,22 @@ gen75_vebox_process_picture(VADriverContextP ctx,
     if (status != VA_STATUS_SUCCESS)
         return status;
 
+    status = gen75_vebox_init_filter_params(ctx, proc_ctx);
+    if (status != VA_STATUS_SUCCESS)
+        return status;
+
     hsw_veb_pre_format_convert(ctx, proc_ctx);
-    hsw_veb_surface_reference(ctx, proc_ctx);
 
-    if (proc_ctx->frame_order == -1) {
-        status = gen75_vebox_ensure_surfaces_storage(ctx, proc_ctx);
-        if (status != VA_STATUS_SUCCESS)
-            return status;
-    }
+    status = gen75_vebox_ensure_surfaces(ctx, proc_ctx);
+    if (status != VA_STATUS_SUCCESS)
+        return status;
+
+    status = gen75_vebox_ensure_surfaces_storage(ctx, proc_ctx);
+    if (status != VA_STATUS_SUCCESS)
+        return status;
 
     if (proc_ctx->format_convert_flags & POST_COPY_CONVERT) {
-        assert(proc_ctx->frame_order == 1);
+        assert(proc_ctx->is_second_field);
         /* directly copy the saved frame in the second call */
     } else {
         intel_batchbuffer_start_atomic_veb(proc_ctx->batch, 0x1000);
@@ -1385,9 +1344,6 @@ gen75_vebox_process_picture(VADriverContextP ctx,
     }
 
     hsw_veb_post_format_convert(ctx, proc_ctx);
-    // hsw_veb_surface_unreference(ctx, proc_ctx);
-
-    proc_ctx->frame_order = (proc_ctx->frame_order + 1) % 2;
      
     return VA_STATUS_SUCCESS;
 }
@@ -1415,17 +1371,17 @@ void gen75_vebox_context_destroy(VADriverContextP ctx,
        proc_ctx->surface_output_scaled_object = NULL;
      }
 
-    for(i = 0; i < ARRAY_ELEMS(proc_ctx->frame_store); i ++) {
-        if (proc_ctx->frame_store[i].is_internal_surface == 1) {
-            assert(proc_ctx->frame_store[i].surface_id != VA_INVALID_ID);
+    for (i = 0; i < ARRAY_ELEMS(proc_ctx->frame_store); i++) {
+        struct object_surface * const obj_surface =
+            proc_ctx->frame_store[i].obj_surface;
 
-            if (proc_ctx->frame_store[i].surface_id != VA_INVALID_ID)
-                i965_DestroySurfaces(ctx, &proc_ctx->frame_store[i].surface_id, 1);
+        if (proc_ctx->frame_store[i].is_internal_surface && obj_surface) {
+            VASurfaceID surface_id = obj_surface->base.id;
+            i965_DestroySurfaces(ctx, &surface_id, 1);
         }
-
+        proc_ctx->frame_store[i].obj_surface = NULL;
         proc_ctx->frame_store[i].surface_id = VA_INVALID_ID;
         proc_ctx->frame_store[i].is_internal_surface = 0;
-        proc_ctx->frame_store[i].obj_surface = NULL;
     }
 
     /* dndi state table  */
@@ -1461,7 +1417,6 @@ struct intel_vebox_context * gen75_vebox_context_init(VADriverContextP ctx)
         proc_context->frame_store[i].surface_id = VA_INVALID_ID;
   
     proc_context->filters_mask          = 0;
-    proc_context->frame_order           = -1; /* the first frame */
     proc_context->surface_output_object = NULL;
     proc_context->surface_input_object  = NULL;
     proc_context->surface_input_vebox   = VA_INVALID_ID;
@@ -1479,33 +1434,6 @@ struct intel_vebox_context * gen75_vebox_context_init(VADriverContextP ctx)
 void bdw_veb_state_command(VADriverContextP ctx, struct intel_vebox_context *proc_ctx)
 {
     struct intel_batchbuffer *batch = proc_ctx->batch;
-    unsigned int is_dn_enabled   = !!(proc_ctx->filters_mask & VPP_DNDI_DN);
-    unsigned int is_di_enabled   = !!(proc_ctx->filters_mask & VPP_DNDI_DI);
-    unsigned int is_iecp_enabled = !!(proc_ctx->filters_mask & VPP_IECP_MASK);
-    unsigned int is_first_frame  = !!((proc_ctx->frame_order == -1) &&
-                                      (is_di_enabled ||
-                                       is_dn_enabled));
-    unsigned int di_output_frames_flag = 2; /* Output Current Frame Only */
-
-    if(proc_ctx->fourcc_input != proc_ctx->fourcc_output ||
-       (is_dn_enabled == 0 && is_di_enabled == 0)){
-       is_iecp_enabled = 1;
-    }
-
-    if (is_di_enabled) {
-        VAProcFilterParameterBufferDeinterlacing *di_param =
-            (VAProcFilterParameterBufferDeinterlacing *)proc_ctx->filter_di;
-
-        assert(di_param);
-        
-        if (di_param->algorithm == VAProcDeinterlacingBob)
-            is_first_frame = 1;
-
-        if ((di_param->algorithm == VAProcDeinterlacingMotionAdaptive ||
-            di_param->algorithm == VAProcDeinterlacingMotionCompensated) &&
-            (1||proc_ctx->frame_order != -1))
-            di_output_frames_flag = 0; /* Output both Current Frame and Previous Frame */
-    }
 
     BEGIN_VEB_BATCH(batch, 0xc);
     OUT_VEB_BATCH(batch, VEB_STATE | (0xc - 2));
@@ -1519,13 +1447,13 @@ void bdw_veb_state_command(VADriverContextP ctx, struct intel_vebox_context *pro
                   0 << 12 |       // alpha plane enable
                   0 << 11 |       // vignette enable
                   0 << 10 |       // demosaic enable
-                  di_output_frames_flag << 8  |       // DI output frame
+                  proc_ctx->current_output_type << 8  | // DI output frame
                   1 << 7  |       // 444->422 downsample method
                   1 << 6  |       // 422->420 downsample method
-                  is_first_frame  << 5  |   // DN/DI first frame
-                  is_di_enabled   << 4  |             // DI enable
-                  is_dn_enabled   << 3  |             // DN enable
-                  is_iecp_enabled << 2  |             // global IECP enabled
+                  proc_ctx->is_first_frame  << 5  |   // DN/DI first frame
+                  proc_ctx->is_di_enabled   << 4  |   // DI enable
+                  proc_ctx->is_dn_enabled   << 3  |   // DN enable
+                  proc_ctx->is_iecp_enabled << 2  |   // global IECP enabled
                   0 << 1  |       // ColorGamutCompressionEnable
                   0 ) ;           // ColorGamutExpansionEnable.
 
@@ -1626,17 +1554,22 @@ gen8_vebox_process_picture(VADriverContextP ctx,
     if (status != VA_STATUS_SUCCESS)
         return status;
 
+    status = gen75_vebox_init_filter_params(ctx, proc_ctx);
+    if (status != VA_STATUS_SUCCESS)
+        return status;
+
     hsw_veb_pre_format_convert(ctx, proc_ctx);
-    hsw_veb_surface_reference(ctx, proc_ctx);
 
-    if (proc_ctx->frame_order == -1) {
-        status = gen75_vebox_ensure_surfaces_storage(ctx, proc_ctx);
-        if (status != VA_STATUS_SUCCESS)
-            return status;
-    }
+    status = gen75_vebox_ensure_surfaces(ctx, proc_ctx);
+    if (status != VA_STATUS_SUCCESS)
+        return status;
+
+    status = gen75_vebox_ensure_surfaces_storage(ctx, proc_ctx);
+    if (status != VA_STATUS_SUCCESS)
+        return status;
 
     if (proc_ctx->format_convert_flags & POST_COPY_CONVERT) {
-        assert(proc_ctx->frame_order == 1);
+        assert(proc_ctx->is_second_field);
         /* directly copy the saved frame in the second call */
     } else {
         intel_batchbuffer_start_atomic_veb(proc_ctx->batch, 0x1000);
@@ -1651,9 +1584,6 @@ gen8_vebox_process_picture(VADriverContextP ctx,
     }
 
     hsw_veb_post_format_convert(ctx, proc_ctx);
-    // hsw_veb_surface_unreference(ctx, proc_ctx);
-
-    proc_ctx->frame_order = (proc_ctx->frame_order + 1) % 2;
      
     return VA_STATUS_SUCCESS;
 }
diff --git a/src/gen75_vpp_vebox.h b/src/gen75_vpp_vebox.h
index 4c763e4..35c657d 100644
--- a/src/gen75_vpp_vebox.h
+++ b/src/gen75_vpp_vebox.h
@@ -89,9 +89,9 @@ enum SURFACE_FORMAT{
 };
 
 typedef struct veb_frame_store {
-    VASurfaceID surface_id;
-    unsigned int is_internal_surface;
     struct object_surface *obj_surface;
+    VASurfaceID surface_id; /* always relative to the input surface */
+    unsigned int is_internal_surface;
 } VEBFrameStore;
 
 typedef struct veb_buffer {
@@ -129,8 +129,8 @@ struct intel_vebox_context
     VEBBuffer vertex_state_table;
 
     unsigned int  filters_mask;
-    int frame_order;
     int current_output;
+    int current_output_type; /* 0:Both, 1:Previous, 2:Current */
 
     VAProcPipelineParameterBuffer * pipeline_param;
     void * filter_dn;
@@ -142,6 +142,13 @@ struct intel_vebox_context
 
     unsigned int  filter_iecp_amp_num_elements;
     unsigned char format_convert_flags;
+
+    /* Temporary flags live until the current picture is processed */
+    unsigned int is_iecp_enabled        : 1;
+    unsigned int is_dn_enabled          : 1;
+    unsigned int is_di_enabled          : 1;
+    unsigned int is_first_frame         : 1;
+    unsigned int is_second_field        : 1;
 };
 
 VAStatus gen75_vebox_process_picture(VADriverContextP ctx,

From edc45152d301dbe96d6e27632f8392c2d1329ad5 Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Tue, 12 Aug 2014 15:28:40 +0200
Subject: [PATCH 10/19] vebox: add support for advanced deinterlacing.

Reintegrate Motion Adaptive Deinterlacing (MADI) and Motion Compensated
Deinterlacing (MCDI) support. This is totally reworked so that to allow
for bob-deinterlacing if no previous frame was supplied, improve global
robustness, and ensure that the right surface storage are used.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 101 +++++++++++++++++++++++++++++++++++++++++++-------
 src/gen75_vpp_vebox.h |   4 +-
 2 files changed, 91 insertions(+), 14 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index b060ae2..7e37d9c 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -836,6 +836,25 @@ void hsw_veb_dndi_iecp_command(VADriverContextP ctx, struct intel_vebox_context
     ADVANCE_VEB_BATCH(batch);
 }
 
+static void
+frame_store_reset(VEBFrameStore *fs)
+{
+    fs->obj_surface = NULL;
+    fs->surface_id = VA_INVALID_ID;
+    fs->is_internal_surface = 0;
+    fs->is_scratch_surface = 0;
+}
+
+static void
+frame_store_clear(VEBFrameStore *fs, VADriverContextP ctx)
+{
+    if (fs->obj_surface && fs->is_scratch_surface) {
+        VASurfaceID surface_id = fs->obj_surface->base.id;
+        i965_DestroySurfaces(ctx, &surface_id, 1);
+    }
+    frame_store_reset(fs);
+}
+
 static VAStatus
 gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
     struct intel_vebox_context *proc_ctx)
@@ -935,6 +954,7 @@ gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
 
         proc_ctx->frame_store[i].obj_surface = obj_surface;
         proc_ctx->frame_store[i].is_internal_surface = 1;
+        proc_ctx->frame_store[i].is_scratch_surface = 1;
     }
 
     /* Allocate DNDI state table  */
@@ -980,6 +1000,7 @@ static VAStatus
 gen75_vebox_ensure_surfaces(VADriverContextP ctx,
     struct intel_vebox_context *proc_ctx)
 {
+    struct i965_driver_data * const i965 = i965_driver_data(ctx);
     struct object_surface *obj_surface;
     VEBFrameStore *ifs, *ofs;
     bool is_new_frame = 0;
@@ -990,15 +1011,47 @@ gen75_vebox_ensure_surfaces(VADriverContextP ctx,
 
     is_new_frame = proc_ctx->frame_store[FRAME_IN_CURRENT].surface_id !=
         obj_surface->base.id;
+    if (is_new_frame) {
+        ifs = &proc_ctx->frame_store[FRAME_IN_PREVIOUS];
+        ofs = &proc_ctx->frame_store[proc_ctx->is_dn_enabled ?
+            FRAME_OUT_CURRENT_DN : FRAME_IN_CURRENT];
+        do {
+            const VAProcPipelineParameterBuffer * const pipe =
+                proc_ctx->pipeline_param;
+
+            if (pipe->num_forward_references < 1)
+                break;
+            if (pipe->forward_references[0] == VA_INVALID_ID)
+                break;
+
+            obj_surface = SURFACE(pipe->forward_references[0]);
+            if (!obj_surface || obj_surface->base.id == ifs->surface_id)
+                break;
+
+            frame_store_clear(ifs, ctx);
+            if (obj_surface->base.id == ofs->surface_id) {
+                *ifs = *ofs;
+                frame_store_reset(ofs);
+            }
+            else {
+                ifs->obj_surface = obj_surface;
+                ifs->surface_id = obj_surface->base.id;
+                ifs->is_internal_surface = 0;
+                ifs->is_scratch_surface = 0;
+            }
+        } while (0);
+    }
 
     /* Update the input surface */
     obj_surface = proc_ctx->surface_input_vebox_object ?
         proc_ctx->surface_input_vebox_object : proc_ctx->surface_input_object;
 
     ifs = &proc_ctx->frame_store[FRAME_IN_CURRENT];
+    frame_store_clear(ifs, ctx);
     ifs->obj_surface = obj_surface;
     ifs->surface_id = proc_ctx->surface_input_object->base.id;
     ifs->is_internal_surface = proc_ctx->surface_input_vebox_object != NULL;
+    ifs->is_scratch_surface = 0;
 
     /* Update the Spatial Temporal Motion Measure (STMM) surfaces */
     if (is_new_frame) {
@@ -1011,7 +1064,7 @@ gen75_vebox_ensure_surfaces(VADriverContextP ctx,
     /* Reset the output surfaces to defaults. i.e. clean from user surfaces */
     for (i = FRAME_OUT_CURRENT_DN; i <= FRAME_OUT_PREVIOUS; i++) {
         ofs = &proc_ctx->frame_store[i];
-        if (!ofs->is_internal_surface)
+        if (!ofs->is_scratch_surface)
             ofs->obj_surface = NULL;
         ofs->surface_id = proc_ctx->surface_input_object->base.id;
     }
@@ -1023,12 +1076,19 @@ gen75_vebox_ensure_surfaces(VADriverContextP ctx,
     proc_ctx->current_output_type = 2;
     if (proc_ctx->filters_mask == VPP_DNDI_DN)
         proc_ctx->current_output = FRAME_OUT_CURRENT_DN;
+    else if (proc_ctx->is_di_adv_enabled && !proc_ctx->is_first_frame) {
+        proc_ctx->current_output_type = 0;
+        proc_ctx->current_output = proc_ctx->is_second_field ?
+            FRAME_OUT_CURRENT : FRAME_OUT_PREVIOUS;
+    }
     else
         proc_ctx->current_output = FRAME_OUT_CURRENT;
     ofs = &proc_ctx->frame_store[proc_ctx->current_output];
+    frame_store_clear(ofs, ctx);
     ofs->obj_surface = obj_surface;
     ofs->surface_id = proc_ctx->surface_input_object->base.id;
     ofs->is_internal_surface = proc_ctx->surface_output_vebox_object != NULL;
+    ofs->is_scratch_surface = 0;
 
     return VA_STATUS_SUCCESS;
 }
@@ -1261,6 +1321,7 @@ gen75_vebox_init_filter_params(VADriverContextP ctx,
     proc_ctx->is_iecp_enabled = (proc_ctx->filters_mask & VPP_IECP_MASK) != 0;
     proc_ctx->is_dn_enabled = (proc_ctx->filters_mask & VPP_DNDI_DN) != 0;
     proc_ctx->is_di_enabled = (proc_ctx->filters_mask & VPP_DNDI_DI) != 0;
+    proc_ctx->is_di_adv_enabled = 0;
     proc_ctx->is_first_frame = 0;
     proc_ctx->is_second_field = 0;
 
@@ -1295,6 +1356,30 @@ gen75_vebox_init_filter_params(VADriverContextP ctx,
         case VAProcDeinterlacingBob:
             proc_ctx->is_first_frame = 1;
             break;
+        case VAProcDeinterlacingMotionAdaptive:
+        case VAProcDeinterlacingMotionCompensated:
+            if (proc_ctx->frame_store[FRAME_IN_CURRENT].surface_id == VA_INVALID_ID)
+                proc_ctx->is_first_frame = 1;
+            else if (proc_ctx->is_second_field) {
+                /* At this stage, we have already deinterlaced the
+                   first field successfully. So, the first frame flag
+                   is trigerred if the previous field was deinterlaced
+                   without reference frame */
+                if (proc_ctx->frame_store[FRAME_IN_PREVIOUS].surface_id == VA_INVALID_ID)
+                    proc_ctx->is_first_frame = 1;
+            }
+            else {
+                const VAProcPipelineParameterBuffer * const pipe =
+                    proc_ctx->pipeline_param;
+
+                if (pipe->num_forward_references < 1 ||
+                    pipe->forward_references[0] == VA_INVALID_ID) {
+                    WARN_ONCE("A forward temporal reference is needed for Motion adaptive/compensated deinterlacing !!!\n");
+                    return VA_STATUS_ERROR_INVALID_PARAMETER;
+                }
+            }
+            proc_ctx->is_di_adv_enabled = 1;
+            break;
         default:
             WARN_ONCE("unsupported deinterlacing algorithm (%d)\n",
                       deint_params->algorithm);
@@ -1371,18 +1456,8 @@ void gen75_vebox_context_destroy(VADriverContextP ctx,
        proc_ctx->surface_output_scaled_object = NULL;
      }
 
-    for (i = 0; i < ARRAY_ELEMS(proc_ctx->frame_store); i++) {
-        struct object_surface * const obj_surface =
-            proc_ctx->frame_store[i].obj_surface;
-
-        if (proc_ctx->frame_store[i].is_internal_surface && obj_surface) {
-            VASurfaceID surface_id = obj_surface->base.id;
-            i965_DestroySurfaces(ctx, &surface_id, 1);
-        }
-        proc_ctx->frame_store[i].obj_surface = NULL;
-        proc_ctx->frame_store[i].surface_id = VA_INVALID_ID;
-        proc_ctx->frame_store[i].is_internal_surface = 0;
-    }
+    for (i = 0; i < ARRAY_ELEMS(proc_ctx->frame_store); i++)
+        frame_store_clear(&proc_ctx->frame_store[i], ctx);
 
     /* dndi state table  */
     dri_bo_unreference(proc_ctx->dndi_state_table.bo);
diff --git a/src/gen75_vpp_vebox.h b/src/gen75_vpp_vebox.h
index 35c657d..d857b87 100644
--- a/src/gen75_vpp_vebox.h
+++ b/src/gen75_vpp_vebox.h
@@ -91,7 +91,8 @@ enum SURFACE_FORMAT{
 typedef struct veb_frame_store {
     struct object_surface *obj_surface;
     VASurfaceID surface_id; /* always relative to the input surface */
-    unsigned int is_internal_surface;
+    unsigned int is_internal_surface : 1;
+    unsigned int is_scratch_surface : 1;
 } VEBFrameStore;
 
 typedef struct veb_buffer {
@@ -147,6 +148,7 @@ struct intel_vebox_context
     unsigned int is_iecp_enabled        : 1;
     unsigned int is_dn_enabled          : 1;
     unsigned int is_di_enabled          : 1;
+    unsigned int is_di_adv_enabled      : 1;
     unsigned int is_first_frame         : 1;
     unsigned int is_second_field        : 1;
 };

From 0f77edc715f5488e2b9aa51b1daaf13b4bdf6dba Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Tue, 19 Aug 2014 17:25:17 +0200
Subject: [PATCH 11/19] vebox: use Y-tiling for internal VEBOX surfaces.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index 7e37d9c..9d400d9 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -886,7 +886,7 @@ gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
     else {
         input_fourcc = VA_FOURCC_NV12;
         input_sampling = SUBSAMPLE_YUV420;
-        input_tiling = 0;
+        input_tiling = 1;
         status = i965_check_alloc_surface_bo(ctx, input_obj_surface,
             input_tiling, input_fourcc, input_sampling);
         if (status != VA_STATUS_SUCCESS)
@@ -908,7 +908,7 @@ gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
     else {
         output_fourcc = VA_FOURCC_NV12;
         output_sampling = SUBSAMPLE_YUV420;
-        output_tiling = 0;
+        output_tiling = 1;
         status = i965_check_alloc_surface_bo(ctx, output_obj_surface,
             output_tiling, output_fourcc, output_sampling);
         if (status != VA_STATUS_SUCCESS)

From b22e2fb941aaec13ef47149d85bad4b0f9125155 Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Wed, 20 Aug 2014 16:12:46 +0200
Subject: [PATCH 12/19] vebox: use Y-tiling for output VEBOX surfaces.

FIXUP 0f77edc.

Always prefer tiled surfaces for performance reasons.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_picture_process.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gen75_picture_process.c b/src/gen75_picture_process.c
index 6978d4b..f79ef2c 100644
--- a/src/gen75_picture_process.c
+++ b/src/gen75_picture_process.c
@@ -156,7 +156,7 @@ gen75_proc_picture(VADriverContextP ctx,
     }
 
     if (!obj_dst_surf->bo) {
-        unsigned int is_tiled = 0;
+        unsigned int is_tiled = 1;
         unsigned int fourcc = VA_FOURCC_NV12;
         int sampling = SUBSAMPLE_YUV420;
         i965_check_alloc_surface_bo(ctx, obj_dst_surf, is_tiled, fourcc, sampling);

From 72610c797775a9a3c6711ec4f29bd86a64b6b134 Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Wed, 20 Aug 2014 16:33:25 +0200
Subject: [PATCH 13/19] vebox: fix denoising when IECP is enabled.

If IECP is enabled, for instance when color conversion is performed
or ProcAmp adjustments are applied, the ultimate denoised output with
additional processing operations applied is the Current Output frame,
not the plain Current Denoised Output frame.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index 9d400d9..190eedb 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -1074,7 +1074,7 @@ gen75_vebox_ensure_surfaces(VADriverContextP ctx,
         proc_ctx->surface_output_vebox_object : proc_ctx->surface_output_object;
 
     proc_ctx->current_output_type = 2;
-    if (proc_ctx->filters_mask == VPP_DNDI_DN)
+    if (proc_ctx->filters_mask == VPP_DNDI_DN && !proc_ctx->is_iecp_enabled)
         proc_ctx->current_output = FRAME_OUT_CURRENT_DN;
     else if (proc_ctx->is_di_adv_enabled && !proc_ctx->is_first_frame) {
         proc_ctx->current_output_type = 0;

From 9da94b4a8570454ebc56b56b8e39ea11821f8c3e Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Tue, 26 Aug 2014 17:49:05 +0200
Subject: [PATCH 14/19] vebox: fix memory leak of VEBOX state tables.

Signed-off-by: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
---
 src/gen75_vpp_vebox.c | 14 +++++---------
 1 file changed, 5 insertions(+), 9 deletions(-)

diff --git a/src/gen75_vpp_vebox.c b/src/gen75_vpp_vebox.c
index 190eedb..4668e59 100644
--- a/src/gen75_vpp_vebox.c
+++ b/src/gen75_vpp_vebox.c
@@ -964,7 +964,6 @@ gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
     proc_ctx->dndi_state_table.bo = bo;
     if (!bo)
         return VA_STATUS_ERROR_ALLOCATION_FAILED;
-    drm_intel_bo_reference(proc_ctx->dndi_state_table.bo);
  
     /* Allocate IECP state table  */
     drm_intel_bo_unreference(proc_ctx->iecp_state_table.bo);
@@ -973,7 +972,6 @@ gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
     proc_ctx->iecp_state_table.bo = bo;
     if (!bo)
         return VA_STATUS_ERROR_ALLOCATION_FAILED;
-    drm_intel_bo_reference(proc_ctx->iecp_state_table.bo);
 
     /* Allocate Gamut state table  */
     drm_intel_bo_unreference(proc_ctx->gamut_state_table.bo);
@@ -982,7 +980,6 @@ gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
     proc_ctx->gamut_state_table.bo = bo;
     if (!bo)
         return VA_STATUS_ERROR_ALLOCATION_FAILED;
-    drm_intel_bo_reference(proc_ctx->gamut_state_table.bo);
 
     /* Allocate vertex state table  */
     drm_intel_bo_unreference(proc_ctx->vertex_state_table.bo);
@@ -991,7 +988,6 @@ gen75_vebox_ensure_surfaces_storage(VADriverContextP ctx,
     proc_ctx->vertex_state_table.bo = bo;
     if (!bo)
         return VA_STATUS_ERROR_ALLOCATION_FAILED;
-    drm_intel_bo_reference(proc_ctx->vertex_state_table.bo);
 
     return VA_STATUS_SUCCESS;
 }
@@ -1460,19 +1456,19 @@ void gen75_vebox_context_destroy(VADriverContextP ctx,
         frame_store_clear(&proc_ctx->frame_store[i], ctx);
 
     /* dndi state table  */
-    dri_bo_unreference(proc_ctx->dndi_state_table.bo);
+    drm_intel_bo_unreference(proc_ctx->dndi_state_table.bo);
     proc_ctx->dndi_state_table.bo = NULL;
 
     /* iecp state table  */
-    dri_bo_unreference(proc_ctx->iecp_state_table.bo);
-    proc_ctx->dndi_state_table.bo = NULL;
+    drm_intel_bo_unreference(proc_ctx->iecp_state_table.bo);
+    proc_ctx->iecp_state_table.bo = NULL;
  
     /* gamut statu table */
-    dri_bo_unreference(proc_ctx->gamut_state_table.bo);
+    drm_intel_bo_unreference(proc_ctx->gamut_state_table.bo);
     proc_ctx->gamut_state_table.bo = NULL;
 
     /* vertex state table  */
-    dri_bo_unreference(proc_ctx->vertex_state_table.bo);
+    drm_intel_bo_unreference(proc_ctx->vertex_state_table.bo);
     proc_ctx->vertex_state_table.bo = NULL;
 
     intel_batchbuffer_free(proc_ctx->batch);

From 53f922603aafde5bdcc07abc90e4f394aef0cc58 Mon Sep 17 00:00:00 2001
From: fritsch <fritsch@xbmc.org>
Date: Tue, 12 Aug 2014 20:43:10 +0200
Subject: [PATCH 15/19] Following haihao's suggestion, make gen6 phantom slice
 funcion can be reused by SNB+

---
 src/gen6_mfd.c           | 81 ++----------------------------------------------
 src/i965_decoder_utils.c | 74 +++++++++++++++++++++++++++++++++++++++++++
 src/i965_decoder_utils.h |  7 +++++
 3 files changed, 83 insertions(+), 79 deletions(-)

diff --git a/src/gen6_mfd.c b/src/gen6_mfd.c
index 8128a80..b6d19e8 100755
--- a/src/gen6_mfd.c
+++ b/src/gen6_mfd.c
@@ -596,56 +596,6 @@ gen6_mfd_avc_slice_state(VADriverContextP ctx,
     ADVANCE_BCS_BATCH(batch);
 }
 
-static void
-gen6_mfd_avc_phantom_slice_state(VADriverContextP ctx,
-                                 VAPictureParameterBufferH264 *pic_param,
-                                 VASliceParameterBufferH264 *next_slice_param,
-                                 struct gen6_mfd_context *gen6_mfd_context)
-{
-    struct intel_batchbuffer *batch = gen6_mfd_context->base.batch;
-    int width_in_mbs = pic_param->picture_width_in_mbs_minus1 + 1;
-    int height_in_mbs = pic_param->picture_height_in_mbs_minus1 + 1; /* frame height */
-    int slice_hor_pos, slice_ver_pos, slice_start_mb_num, next_slice_hor_pos, next_slice_ver_pos;
-    int mbaff_picture = (!pic_param->pic_fields.bits.field_pic_flag &&
-                         pic_param->seq_fields.bits.mb_adaptive_frame_field_flag);
-
-    if (next_slice_param) {
-        int first_mb_in_next_slice;
-
-        slice_hor_pos = 0;
-        slice_ver_pos = 0;
-        slice_start_mb_num = 0;
-        first_mb_in_next_slice = next_slice_param->first_mb_in_slice << mbaff_picture;
-        next_slice_hor_pos = first_mb_in_next_slice % width_in_mbs;
-        next_slice_ver_pos = first_mb_in_next_slice / width_in_mbs;
-    } else {
-        slice_hor_pos = 0;
-        slice_ver_pos = height_in_mbs;
-        slice_start_mb_num = width_in_mbs * height_in_mbs / (1 + !!pic_param->pic_fields.bits.field_pic_flag);
-        next_slice_hor_pos = 0;
-        next_slice_ver_pos = 0;
-    }
-
-    BEGIN_BCS_BATCH(batch, 11); /* FIXME: is it 10??? */
-    OUT_BCS_BATCH(batch, MFX_AVC_SLICE_STATE | (11 - 2));
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch,
-                  slice_ver_pos << 24 |
-                  slice_hor_pos << 16 |
-                  slice_start_mb_num << 0);
-    OUT_BCS_BATCH(batch,
-                  next_slice_ver_pos << 16 |
-                  next_slice_hor_pos << 0);
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch, 0);
-    ADVANCE_BCS_BATCH(batch);
-}
-
 static inline void
 gen6_mfd_avc_ref_idx_state(VADriverContextP ctx,
                            VAPictureParameterBufferH264 *pic_param,
@@ -747,39 +697,12 @@ gen6_mfd_avc_bsd_object(VADriverContextP ctx,
 }
 
 static void
-gen6_mfd_avc_phantom_slice_bsd_object(VADriverContextP ctx,
-                                      VAPictureParameterBufferH264 *pic_param,
-                                      struct gen6_mfd_context *gen6_mfd_context)
-{
-    struct intel_batchbuffer *batch = gen6_mfd_context->base.batch;
-
-    BEGIN_BCS_BATCH(batch, 6);
-    OUT_BCS_BATCH(batch, MFD_AVC_BSD_OBJECT | (6 - 2));
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch, 0);
-    OUT_BCS_BATCH(batch, 0);
-    ADVANCE_BCS_BATCH(batch);
-}
-
-static void
-gen6_mfd_avc_phantom_slice(VADriverContextP ctx,
-                           VAPictureParameterBufferH264 *pic_param,
-                           VASliceParameterBufferH264 *next_slice_param,
-                           struct gen6_mfd_context *gen6_mfd_context)
-{
-    gen6_mfd_avc_phantom_slice_state(ctx, pic_param, next_slice_param, gen6_mfd_context);
-    gen6_mfd_avc_phantom_slice_bsd_object(ctx, pic_param, gen6_mfd_context);
-}
-
-static void
 gen6_mfd_avc_phantom_slice_first(VADriverContextP ctx,
                                  VAPictureParameterBufferH264 *pic_param,
                                  VASliceParameterBufferH264 *next_slice_param,
                                  struct gen6_mfd_context *gen6_mfd_context)
 {
-    gen6_mfd_avc_phantom_slice(ctx, pic_param, next_slice_param, gen6_mfd_context);
+    gen6_mfd_avc_phantom_slice(ctx, pic_param, next_slice_param, gen6_mfd_context->base.batch);
 }
 
 static void
@@ -787,7 +710,7 @@ gen6_mfd_avc_phantom_slice_last(VADriverContextP ctx,
                                 VAPictureParameterBufferH264 *pic_param,
                                 struct gen6_mfd_context *gen6_mfd_context)
 {
-    gen6_mfd_avc_phantom_slice(ctx, pic_param, NULL, gen6_mfd_context);
+    gen6_mfd_avc_phantom_slice(ctx, pic_param, NULL, gen6_mfd_context->base.batch);
 }
 
 static void
diff --git a/src/i965_decoder_utils.c b/src/i965_decoder_utils.c
index 546285e..2b4ea75 100644
--- a/src/i965_decoder_utils.c
+++ b/src/i965_decoder_utils.c
@@ -486,6 +486,80 @@ gen6_send_avc_ref_idx_state(
         frame_store
     );
 }
+static void
+gen6_mfd_avc_phantom_slice_state(VADriverContextP ctx,
+                                 VAPictureParameterBufferH264 *pic_param,
+                                 VASliceParameterBufferH264 *next_slice_param,
+                                 struct intel_batchbuffer *batch)
+{
+    int width_in_mbs = pic_param->picture_width_in_mbs_minus1 + 1;
+    int height_in_mbs = pic_param->picture_height_in_mbs_minus1 + 1; /* frame height */
+    int slice_hor_pos, slice_ver_pos, slice_start_mb_num, next_slice_hor_pos, next_slice_ver_pos;
+    int mbaff_picture = (!pic_param->pic_fields.bits.field_pic_flag &&
+                         pic_param->seq_fields.bits.mb_adaptive_frame_field_flag);
+
+    if (next_slice_param) {
+        int first_mb_in_next_slice;
+
+        slice_hor_pos = 0;
+        slice_ver_pos = 0;
+        slice_start_mb_num = 0;
+        first_mb_in_next_slice = next_slice_param->first_mb_in_slice << mbaff_picture;
+        next_slice_hor_pos = first_mb_in_next_slice % width_in_mbs;
+        next_slice_ver_pos = first_mb_in_next_slice / width_in_mbs;
+    } else {
+        slice_hor_pos = 0;
+        slice_ver_pos = height_in_mbs;
+        slice_start_mb_num = width_in_mbs * height_in_mbs / (1 + !!pic_param->pic_fields.bits.field_pic_flag);
+        next_slice_hor_pos = 0;
+        next_slice_ver_pos = 0;
+    }
+
+    BEGIN_BCS_BATCH(batch, 11); /* FIXME: is it 10??? */
+    OUT_BCS_BATCH(batch, MFX_AVC_SLICE_STATE | (11 - 2));
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch,
+                  slice_ver_pos << 24 |
+                  slice_hor_pos << 16 |
+                  slice_start_mb_num << 0);
+    OUT_BCS_BATCH(batch,
+                  next_slice_ver_pos << 16 |
+                  next_slice_hor_pos << 0);
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch, 0);
+    ADVANCE_BCS_BATCH(batch);
+}
+
+static void
+gen6_mfd_avc_phantom_slice_bsd_object(VADriverContextP ctx,
+                                      VAPictureParameterBufferH264 *pic_param,
+                                      struct intel_batchbuffer *batch)
+{
+
+    BEGIN_BCS_BATCH(batch, 6);
+    OUT_BCS_BATCH(batch, MFD_AVC_BSD_OBJECT | (6 - 2));
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch, 0);
+    OUT_BCS_BATCH(batch, 0);
+    ADVANCE_BCS_BATCH(batch);
+}
+
+void
+gen6_mfd_avc_phantom_slice(VADriverContextP ctx,
+                           VAPictureParameterBufferH264 *pic_param,
+                           VASliceParameterBufferH264 *next_slice_param,
+                           struct intel_batchbuffer *batch)
+{
+    gen6_mfd_avc_phantom_slice_state(ctx, pic_param, next_slice_param, batch);
+    gen6_mfd_avc_phantom_slice_bsd_object(ctx, pic_param, batch);
+}
 
 /* Comparison function for sorting out the array of free frame store entries */
 static int
diff --git a/src/i965_decoder_utils.h b/src/i965_decoder_utils.h
index 3d39b21..3e6acdd 100644
--- a/src/i965_decoder_utils.h
+++ b/src/i965_decoder_utils.h
@@ -89,6 +89,13 @@ gen6_send_avc_ref_idx_state(
     const GenFrameStore               frame_store[MAX_GEN_REFERENCE_FRAMES]
 );
 
+void
+gen6_mfd_avc_phantom_slice(VADriverContextP ctx,
+                           VAPictureParameterBufferH264 *pic_param,
+                           VASliceParameterBufferH264 *next_slice_param,
+                           struct intel_batchbuffer *batch
+);
+
 VAStatus
 intel_decoder_sanity_check_input(VADriverContextP ctx,
                                  VAProfile profile,

From 2ee164dcc869f1f48c90ff0e7e314c81638b5ae6 Mon Sep 17 00:00:00 2001
From: fritsch <fritsch@xbmc.org>
Date: Tue, 12 Aug 2014 20:43:57 +0200
Subject: [PATCH 16/19] Add phantom slice support on IVB+

---
 src/gen75_mfd.c | 12 ++++++++++++
 src/gen7_mfd.c  | 12 ++++++++++++
 src/gen8_mfd.c  | 13 +++++++++++++
 3 files changed, 37 insertions(+)

diff --git a/src/gen75_mfd.c b/src/gen75_mfd.c
index a89640d..299f2b5 100644
--- a/src/gen75_mfd.c
+++ b/src/gen75_mfd.c
@@ -812,6 +812,15 @@ gen75_mfd_avc_directmode_state(VADriverContextP ctx,
 }
 
 static void
+gen75_mfd_avc_phantom_slice_first(VADriverContextP ctx,
+                                 VAPictureParameterBufferH264 *pic_param,
+                                 VASliceParameterBufferH264 *next_slice_param,
+                                 struct gen7_mfd_context *gen7_mfd_context)
+{
+    gen6_mfd_avc_phantom_slice(ctx, pic_param, next_slice_param, gen7_mfd_context->base.batch);
+}
+
+static void
 gen75_mfd_avc_slice_state(VADriverContextP ctx,
                          VAPictureParameterBufferH264 *pic_param,
                          VASliceParameterBufferH264 *slice_param,
@@ -1145,6 +1154,9 @@ gen75_mfd_avc_decode_picture(VADriverContextP ctx,
         else
             next_slice_group_param = (VASliceParameterBufferH264 *)decode_state->slice_params[j + 1]->buffer;
 
+        if (j == 0 && slice_param->first_mb_in_slice)
+            gen75_mfd_avc_phantom_slice_first(ctx, pic_param, slice_param, gen7_mfd_context); 
+
         for (i = 0; i < decode_state->slice_params[j]->num_elements; i++) {
             assert(slice_param->slice_data_flag == VA_SLICE_DATA_FLAG_ALL);
             assert((slice_param->slice_type == SLICE_TYPE_I) ||
diff --git a/src/gen7_mfd.c b/src/gen7_mfd.c
index 7ab2955..bfb95bf 100755
--- a/src/gen7_mfd.c
+++ b/src/gen7_mfd.c
@@ -506,6 +506,15 @@ gen7_mfd_avc_directmode_state(VADriverContextP ctx,
 }
 
 static void
+gen7_mfd_avc_phantom_slice_first(VADriverContextP ctx,
+                                 VAPictureParameterBufferH264 *pic_param,
+                                 VASliceParameterBufferH264 *next_slice_param,
+                                 struct gen7_mfd_context *gen7_mfd_context)
+{
+    gen6_mfd_avc_phantom_slice(ctx, pic_param, next_slice_param, gen7_mfd_context->base.batch);
+}
+
+static void
 gen7_mfd_avc_slice_state(VADriverContextP ctx,
                          VAPictureParameterBufferH264 *pic_param,
                          VASliceParameterBufferH264 *slice_param,
@@ -842,6 +851,9 @@ gen7_mfd_avc_decode_picture(VADriverContextP ctx,
         else
             next_slice_group_param = (VASliceParameterBufferH264 *)decode_state->slice_params[j + 1]->buffer;
 
+        if (j == 0 && slice_param->first_mb_in_slice)
+            gen7_mfd_avc_phantom_slice_first(ctx, pic_param, slice_param, gen7_mfd_context); 
+
         for (i = 0; i < decode_state->slice_params[j]->num_elements; i++) {
             assert(slice_param->slice_data_flag == VA_SLICE_DATA_FLAG_ALL);
             assert((slice_param->slice_type == SLICE_TYPE_I) ||
diff --git a/src/gen8_mfd.c b/src/gen8_mfd.c
index 5e1b70b..941c21b 100644
--- a/src/gen8_mfd.c
+++ b/src/gen8_mfd.c
@@ -575,6 +575,15 @@ gen8_mfd_avc_directmode_state(VADriverContextP ctx,
 }
 
 static void
+gen8_mfd_avc_phantom_slice_first(VADriverContextP ctx,
+                                 VAPictureParameterBufferH264 *pic_param,
+                                 VASliceParameterBufferH264 *next_slice_param,
+                                 struct gen7_mfd_context *gen7_mfd_context)
+{
+    gen6_mfd_avc_phantom_slice(ctx, pic_param, next_slice_param, gen7_mfd_context->base.batch);
+}
+
+static void
 gen8_mfd_avc_slice_state(VADriverContextP ctx,
                          VAPictureParameterBufferH264 *pic_param,
                          VASliceParameterBufferH264 *slice_param,
@@ -908,6 +917,10 @@ gen8_mfd_avc_decode_picture(VADriverContextP ctx,
         else
             next_slice_group_param = (VASliceParameterBufferH264 *)decode_state->slice_params[j + 1]->buffer;
 
+        if (j == 0 && slice_param->first_mb_in_slice)
+            gen8_mfd_avc_phantom_slice_first(ctx, pic_param, slice_param, gen7_mfd_context); 
+
+
         for (i = 0; i < decode_state->slice_params[j]->num_elements; i++) {
             assert(slice_param->slice_data_flag == VA_SLICE_DATA_FLAG_ALL);
             assert((slice_param->slice_type == SLICE_TYPE_I) ||

From 67dc775fbae47f45c4e3faebecc0a9391883c728 Mon Sep 17 00:00:00 2001
From: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date: Wed, 18 Jun 2014 13:11:48 +0200
Subject: [PATCH 17/19] decoder: h264: fix RefPicList0/1 without frame in DPB.

---
 src/i965_decoder_utils.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/i965_decoder_utils.c b/src/i965_decoder_utils.c
index 2b4ea75..a6bf679 100644
--- a/src/i965_decoder_utils.c
+++ b/src/i965_decoder_utils.c
@@ -600,6 +600,8 @@ intel_update_avc_frame_store_index(
             continue;
 
         GenAvcSurface * const avc_surface = obj_surface->private_data;
+        if (!avc_surface)
+            continue;
         if (avc_surface->frame_store_id >= 0) {
             GenFrameStore * const fs =
                 &frame_store[avc_surface->frame_store_id];
@@ -633,6 +635,8 @@ intel_update_avc_frame_store_index(
             continue;
 
         GenAvcSurface * const avc_surface = obj_surface->private_data;
+        if (!avc_surface)
+            continue;
         if (n < num_free_refs) {
             GenFrameStore * const fs = free_refs[n++];
             fs->surface_id = obj_surface->base.id;

From 59cbc497a232daa746e5d1e987dedbd032446ebe Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Tue, 19 Aug 2014 20:31:58 +0200
Subject: [PATCH 18/19] Add debian files for ppa packaging thx @wsnipex

---
 debian/README.Debian                            |  48 ++++
 debian/changelog                                | 218 +++++++++++++++++
 debian/clean                                    |   2 +
 debian/compat                                   |   1 +
 debian/control                                  | 139 +++++++++++
 debian/copyright                                | 304 ++++++++++++++++++++++++
 debian/gbp.conf                                 |   2 +
 debian/i965-va-driver.install                   |   1 +
 debian/intel-get-orig-source                    |  65 +++++
 debian/patches/0001-Fix_FTBFS_on_kFreeBSD.patch |  33 +++
 debian/patches/series                           |   1 +
 debian/rules                                    |  16 ++
 debian/source/format                            |   1 +
 debian/source/options                           |   2 +
 debian/watch                                    |   3 +
 15 files changed, 836 insertions(+)
 create mode 100644 debian/README.Debian
 create mode 100644 debian/changelog
 create mode 100644 debian/clean
 create mode 100644 debian/compat
 create mode 100644 debian/control
 create mode 100644 debian/copyright
 create mode 100644 debian/gbp.conf
 create mode 100644 debian/i965-va-driver.install
 create mode 100755 debian/intel-get-orig-source
 create mode 100644 debian/patches/0001-Fix_FTBFS_on_kFreeBSD.patch
 create mode 100644 debian/patches/series
 create mode 100755 debian/rules
 create mode 100644 debian/source/format
 create mode 100644 debian/source/options
 create mode 100644 debian/watch

diff --git a/debian/README.Debian b/debian/README.Debian
new file mode 100644
index 0000000..6c3acab
--- /dev/null
+++ b/debian/README.Debian
@@ -0,0 +1,48 @@
+intel-vaapi-driver for Debian
+-----------------------------
+
+Supported hardware:
+------------------
+
+Sandybridge Intel® HD Graphics 2000/3000
+            (used in 2nd Generation Intel® Core™ i7/i5/i3 processor family)
+HD          Intel® HD Graphics
+            (used in Intel® 2010 Core™ i7/i5/i3 processor family)
+GMA3150     Intel® Graphics Media Accelerator 3150
+            (used in Intel® Atom™ processor N450/D410/D450 family)
+G45         Intel® G45 Express Chipset
+Q45         Intel® Q45 Express Chipset
+G43         Intel® G43 Express Chipset
+Q43         Intel® Q43 Express Chipset
+B43         Intel® B43 Express Chipset
+G41         Intel® G41 Express Chipset
+GM45        Mobile Intel® GM45/GS45/GL40 Express Chipset
+G35         Intel® G35 Express Chipset
+Q35         Intel® Q35 Express Chipset
+Q33         Intel® Q33 Express Chipset
+G33         Intel® G33/G31 Express Chipset
+965GM       Mobile Intel® GM965 Express Chipset
+965G        G965 Integrated Graphics Controller
+965Q        Q963/Q965 Integrated Graphics Controller
+946GZ       946GZ/GL Integrated Graphics Controller
+945G        945G Integrated Graphics Controller
+945GM       Mobile 945GM/GMS/940GML Express Integrated Graphics Controller
+915G        82915G/GV/910GL Express Chipset Family Graphics Controller
+915GM       Mobile 915GM/GMS/910GML Express Graphics Controller
+865G        82865G Integrated Graphics Controller
+855GM       82852/855GM Integrated Graphics Device
+845G        82845G/GL[Brookdale-G]/GE Chipset Integrated Graphics Device
+i830M       82830 Chipset Graphics Controller
+815 82815   Chipset Graphics Controller
+810 82810   Chipset Graphics Controller
+810-DC100   82810-M DC-100 System and Graphics Controller
+
+Codecs:
+------
+
+H.264   D   ILK+
+H.264   E   SNB+
+MPEG-2  D   CTG+
+VC-1    D   SNB+
+
+ -- Matteo F. Vescovi <mfv.debian@gmail.com>  Mon, 09 Jan 2012 10:00:00 +0100
diff --git a/debian/changelog b/debian/changelog
new file mode 100644
index 0000000..1414df0
--- /dev/null
+++ b/debian/changelog
@@ -0,0 +1,218 @@
+intel-vaapi-driver (1.3.3~pre1-3~trusty) trusty; urgency=medium
+
+  * [PATCH] decoder: h264: fix RefPicList0/1 without frame in DPB
+    fixes https://bugs.freedesktop.org/show_bug.cgi?id=82466
+
+ -- wsnipex <wsnipex@a1.net>  Wed, 06 Aug 2014 20:21:41 +0200
+
+intel-vaapi-driver (1.3.3~pre1-2~trusty) trusty; urgency=medium
+
+  * drop [PATCH] Check first_mb_in_slice of the first slice in favor of:
+  * add [PATCH] Add phantom slice support on IVB+ 
+    http://lists.freedesktop.org/archives/libva/2014-August/002565.html
+
+ -- wsnipex <wsnipex@a1.net>  Wed, 06 Aug 2014 20:21:41 +0200
+
+intel-vaapi-driver (1.3.3~pre1~trusty) trusty; urgency=medium
+
+  * updated to 82d2ed8d7da3619c0ea467c06604f5626fc0b901
+  * added [PATCH] Check first_mb_in_slice of the first slice 
+    - fixes upstream #81447
+
+ -- wsnipex <wsnipex@a1.net>  Tue, 05 Aug 2014 18:10:15 +0200
+
+intel-vaapi-driver (1.3.0-1ubuntu1) trusty; urgency=medium
+
+  * control: Re-add the transitional packages, still needed for
+    upgrades from precise.
+
+ -- Timo Aaltonen <tjaalton@ubuntu.com>  Thu, 17 Apr 2014 00:40:51 +0300
+
+intel-vaapi-driver (1.3.0-1) unstable; urgency=medium
+
+  [ Matteo F. Vescovi ]
+  * New upstream release
+    - debian/patches/: patchset refreshed
+      - 0002-Adjust_default_contrast-saturation.patch dropped
+        (applied upstream)
+    - debian/control: libva-dev b-dep version bump 1.2 => 1.3
+
+  [ Sebastian Ramacher ]
+  * debian/copyright:
+    - Add license information for new files.
+    - Update copyright years.
+  * debian/control:
+    - Remove Andres Mejia from Uploaders. Thank you for maintaining
+      intel-vaapi-driver, Andres. (Closes: #743530)
+    - Remove transitional packages which are no longer in the archive.
+    - Add myself to Uploaders.
+    - Remove explicit dependency on libva1. A stricter dependency on libva1
+      will be generated by dh_shlibdeps anyway.
+
+ -- Sebastian Ramacher <sramacher@debian.org>  Sat, 05 Apr 2014 15:36:28 +0200
+
+intel-vaapi-driver (1.2.2-2) unstable; urgency=medium
+
+  * debian/patches/: patchset updated
+    - 0001-Fix_FTBFS_on_kFreeBSD.patch refreshed
+    - 0002-Adjust_default_contrast-saturation.patch added (Closes: #734246)
+
+ -- Matteo F. Vescovi <mfvescovi@gmail.com>  Wed, 15 Jan 2014 18:25:37 +0100
+
+intel-vaapi-driver (1.2.2-1) unstable; urgency=low
+
+  [ Reinhard Tartler ]
+  * Tighten dependency on libdrm (Closes: #732162)
+
+  [ Matteo F. Vescovi ]
+  * New upstream release
+  * debian/control: S-V bump 3.9.4 => 3.9.5 (no changes needed)
+
+ -- Matteo F. Vescovi <mfvescovi@gmail.com>  Fri, 03 Jan 2014 15:06:13 +0100
+
+intel-vaapi-driver (1.2.1-2) unstable; urgency=low
+
+  * Upload to unstable.
+
+ -- Matteo F. Vescovi <mfv.debian@gmail.com>  Thu, 07 Nov 2013 18:00:34 +0100
+
+intel-vaapi-driver (1.2.1-1) experimental; urgency=low
+
+  * New upstream release
+  * debian/patches/: patchset created
+    - 0001-Fix_FTBFS_on_kFreeBSD.patch added (Closes: #722354)
+
+ -- Matteo F. Vescovi <mfv.debian@gmail.com>  Tue, 15 Oct 2013 19:49:05 +0200
+
+intel-vaapi-driver (1.2.0-1) experimental; urgency=low
+
+  [ Matteo F. Vescovi ]
+  * New upstream release
+
+  [ Sebastian Ramacher ]
+  * debian/control: Bump libva-dev in Build-Depends to >= 1.2.
+  * debian/copyright: Complete copyright information. (Closes: #719603)
+    - Update Format URL.
+    - Add missing license for src/shaders/post_processing/gen7/*.g4a.
+    - Add full text of EPL-1.0.
+    - Update copyright years.
+
+ -- Matteo F. Vescovi <mfv.debian@gmail.com>  Sun, 08 Sep 2013 02:04:00 +0200
+
+intel-vaapi-driver (1.0.20-2) unstable; urgency=low
+
+  * Upload to unstable
+  * Enable verbose builds
+
+ -- Reinhard Tartler <siretart@tauware.de>  Thu, 23 May 2013 07:28:04 +0200
+
+intel-vaapi-driver (1.0.20-1) experimental; urgency=low
+
+  [ Matteo F. Vescovi ]
+  * New upstream release
+    - Supports more decoding profiles for older hardware, closes: #670921
+
+  [ Reinhard Tartler ]
+  * Clarify changelog
+
+ -- Reinhard Tartler <siretart@tauware.de>  Fri, 29 Mar 2013 10:12:26 +0100
+
+intel-vaapi-driver (1.0.19-1) experimental; urgency=low
+
+  [ Matteo F. Vescovi ]
+  * New upstream release
+  * debian/control: S-V 3.9.3 => 3.9.4 (no changes needed)
+  * debian/control: Vcs-Git URL updated
+
+  [ Reinhard Tartler ]
+  * bump library dependency on libav-dev (>> 1.0.16)
+    this is stated as such in the upstream's README
+
+ -- Matteo F. Vescovi <mfv.debian@gmail.com>  Tue, 15 Jan 2013 16:23:59 +0100
+
+intel-vaapi-driver (1.0.17-1) unstable; urgency=low
+
+  [ Matteo F. Vescovi ]
+  * New upstream release
+
+ -- Andres Mejia <amejia@debian.org>  Tue, 01 May 2012 22:23:31 -0400
+
+intel-vaapi-driver (1.0.16-4) unstable; urgency=low
+
+  * Rename libva-intel-vaapi-driver package back to i965-va-driver.
+    This is done to match naming sceme picked for other VAAPI modules.
+    The name is picked by looking at the name of the *.so file installed
+    under /usr/lib/<triplet>/dri, and using the first part of the name.
+    In this case, the driver file is named "i965_drv_video.so" and so the
+    package to install the driver is named i965-va-driver.
+
+ -- Andres Mejia <amejia@debian.org>  Tue, 20 Mar 2012 11:16:29 -0400
+
+intel-vaapi-driver (1.0.16-3) unstable; urgency=low
+
+  * Set Architecture field to specific supported architecture fields.
+
+ -- Andres Mejia <amejia@debian.org>  Sat, 17 Mar 2012 10:01:45 -0400
+
+intel-vaapi-driver (1.0.16-2) unstable; urgency=low
+
+  * Make driver build only on i386 and amd64 architectures.
+
+ -- Andres Mejia <amejia@debian.org>  Fri, 16 Mar 2012 23:20:26 -0400
+
+intel-vaapi-driver (1.0.16-1) unstable; urgency=low
+
+  [ Matteo F. Vescovi ]
+  * debian/README.Debian: list of supported hardware (Closes: #623045)
+  * debian/control: list of platform definitions added
+  * debian/control: Standards-Version bumped to 3.9.3
+  * debian/: Multi-Arch support added
+
+  [ Andres Mejia ]
+  * Add options to unapply patches and abort on upstream changes.
+  * Fix Priority fields in packages.
+  * Don't include version depends in Replaces field.
+  * Add Provides on i965-va-driver for libva-intel-vaapi-driver package.
+  * Remove compression option, it is now gz.
+  * Remove some unneeded lines from debian/rules.
+  * Support parallel builds.
+  * Install NEWS file as changelog and don't install README. README is repition
+    of package description.
+  * Fix watch file.
+  * Add myself to uploaders field.
+
+ -- Andres Mejia <amejia@debian.org>  Fri, 16 Mar 2012 12:37:33 -0400
+
+intel-vaapi-driver (1.0.15-1) experimental; urgency=low
+
+  [ Brandon Snider ]
+  * Initial release (Closes: #654567)
+
+  [ Matteo F. Vescovi ]
+  * debian/gbp.conf: config file added
+  * debian/control: massive change
+  * debian/copyright: little re-work
+  * debian/*.install: renaming due to package's new name
+  * debian/README.*: useless (for now) files removed
+  * debian/clean: clean upstream after build
+  * debian/changelog: ITP bug added
+  * debian/control: "Section:" fields updated/removed
+  * debian/*.install: install path corrected
+  * debian/rules: paths corrected
+  * debian/rules: purging useless commented stuff
+
+  [ Reinhard Tartler ]
+  * document that shades are licensed under EPL
+  * build-depend on pkg-config
+  * add myself to uploaders
+  * build-depend on libx11-dev
+  * provide a transition path for the i965-va-driver package
+  * tighten build dependency on libva-dev (Closes: #645359)
+  * normalize fields with wrap-and-sort(1)
+  * add ${misc:Depends} to i965-va-driver
+  * i965-va-driver: Add Priority and Section fields.
+    (Found by lintian)
+  * improve package descriptions
+  * i965-va-driver: Correct Breaks/Replaces field
+
+ -- Reinhard Tartler <siretart@tauware.de>  Thu, 05 Jan 2012 12:59:27 +0100
diff --git a/debian/clean b/debian/clean
new file mode 100644
index 0000000..42a99ab
--- /dev/null
+++ b/debian/clean
@@ -0,0 +1,2 @@
+debian.upstream/changelog
+debian.upstream/control
diff --git a/debian/compat b/debian/compat
new file mode 100644
index 0000000..ec63514
--- /dev/null
+++ b/debian/compat
@@ -0,0 +1 @@
+9
diff --git a/debian/control b/debian/control
new file mode 100644
index 0000000..2613919
--- /dev/null
+++ b/debian/control
@@ -0,0 +1,139 @@
+Source: intel-vaapi-driver
+Section: libs
+Priority: optional
+Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
+XSBC-Original-Maintainer: Debian Multimedia Maintainers <pkg-multimedia-maintainers@lists.alioth.debian.org>
+Uploaders:
+ Brandon Snider <brandonjsnider@gmail.com>,
+ Reinhard Tartler <siretart@tauware.de>,
+ Matteo F. Vescovi <mfvescovi@gmail.com>,
+ Sebastian Ramacher <sramacher@debian.org>
+Build-Depends:
+ debhelper (>= 9),
+ dh-autoreconf,
+ libdrm-dev (>= 2.4.45),
+ libva-dev (>= 1.3),
+ libx11-dev,
+ pkg-config
+Standards-Version: 3.9.5
+Homepage: http://www.freedesktop.org/wiki/Software/vaapi
+Vcs-Git: git://anonscm.debian.org/pkg-multimedia/intel-vaapi-driver.git
+Vcs-Browser: http://anonscm.debian.org/gitweb/?p=pkg-multimedia/intel-vaapi-driver.git
+
+Package: i965-va-driver
+Architecture: amd64 i386 kfreebsd-amd64 kfreebsd-i386
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends:
+ ${misc:Depends},
+ ${shlibs:Depends}
+Breaks:
+ libva-intel-vaapi-driver (<< 1.0.16-4)
+Replaces:
+ libva-intel-vaapi-driver
+Provides:
+ libva-intel-vaapi-driver
+Description: VAAPI driver for Intel G45 & HD Graphics family
+ The VA-API (Video Acceleration API) enables hardware accelerated video
+ decode/encode at various entry-points (VLD, IDCT, Motion Compensation
+ etc.) for the prevailing coding standards today (MPEG-2, MPEG-4
+ ASP/H.263, MPEG-4 AVC/H.264, and VC-1/VMW3). It provides an interface
+ to fully expose the video decode capabilities in today's GPUs.
+ .
+ Platform definitions:
+ CTG: Cantiga, Intel GMA 4500MHD (GM45)
+ ILK: Ironlake, Intel HD Graphics for 2010 Intel Core processor family
+ SNB: Sandybridge, Intel HD Graphics for 2011 Intel Core processor family
+ IVB: Ivybridge
+ .
+ This package contains the video decode & encode driver backend for the
+ Intel G45 chipsets and Intel HD Graphics for Intel Core processor
+ family.
+
+Package: i965-va-driver-dbg
+Section: debug
+Priority: extra
+Architecture: amd64 i386 kfreebsd-amd64 kfreebsd-i386
+Multi-Arch: same
+Breaks:
+ libva-intel-vaapi-driver-dbg (<< 1.0.16-4)
+Replaces:
+ libva-intel-vaapi-driver-dbg
+Provides:
+ libva-intel-vaapi-driver-dbg
+Depends:
+ i965-va-driver (= ${binary:Version}),
+ ${misc:Depends}
+Description: VAAPI driver for Intel G45 & HD Graphics family (debug symbols)
+ Video decode & encode driver for Intel G45 chipsets and Intel HD
+ Graphics for Intel Core processor family.
+ .
+ The VA-API (Video Acceleration API) enables hardware accelerated video
+ decode/encode at various entry-points (VLD, IDCT, Motion Compensation
+ etc.) for the prevailing coding standards today (MPEG-2, MPEG-4
+ ASP/H.263, MPEG-4 AVC/H.264, and VC-1/VMW3). It provides an interface
+ to fully expose the video decode capabilities in today's GPUs.
+ .
+ This package contains the debug files for the video decode & encode
+ driver backend for the Intel G45 chipsets and Intel HD Graphics for
+ Intel Core processor family.
+
+Package: libva-intel-vaapi-driver
+Architecture: all
+Multi-Arch: foreign
+Depends:
+ i965-va-driver,
+ ${misc:Depends}
+Section: oldlibs
+Priority: extra
+Description: VAAPI driver for Intel G45 & HD Graphics family (transitional package)
+ The VA-API (Video Acceleration API) enables hardware accelerated video
+ decode/encode at various entry-points (VLD, IDCT, Motion Compensation
+ etc.) for the prevailing coding standards today (MPEG-2, MPEG-4
+ ASP/H.263, MPEG-4 AVC/H.264, and VC-1/VMW3). It provides an interface
+ to fully expose the video decode capabilities in today's GPUs.
+ .
+ Platform definitions:
+ CTG: Cantiga, Intel GMA 4500MHD (GM45)
+ ILK: Ironlake, Intel HD Graphics for 2010 Intel Core processor family
+ SNB: Sandybridge, Intel HD Graphics for 2011 Intel Core processor family
+ IVB: Ivybridge
+ .
+ This package installs the video decode & encode driver backend for the
+ Intel G45 chipsets and Intel HD Graphics for Intel Core processor
+ family.
+ .
+ This package ensures a smooth upgrades from previous versions of Debian.
+ It can safely be removed if no other packages depend on it.
+
+Package: libva-intel-vaapi-driver-dbg
+Architecture: all
+Multi-Arch: foreign
+Depends:
+ i965-va-driver-dbg,
+ ${misc:Depends}
+Section: oldlibs
+Priority: extra
+Description: VAAPI driver for Intel G45 & HD Graphics family (dbg transitional package)
+ The VA-API (Video Acceleration API) enables hardware accelerated video
+ decode/encode at various entry-points (VLD, IDCT, Motion Compensation
+ etc.) for the prevailing coding standards today (MPEG-2, MPEG-4
+ ASP/H.263, MPEG-4 AVC/H.264, and VC-1/VMW3). It provides an interface
+ to fully expose the video decode capabilities in today's GPUs.
+ .
+ Platform definitions:
+ CTG: Cantiga, Intel GMA 4500MHD (GM45)
+ ILK: Ironlake, Intel HD Graphics for 2010 Intel Core processor family
+ SNB: Sandybridge, Intel HD Graphics for 2011 Intel Core processor family
+ IVB: Ivybridge
+ .
+ This package installs the video decode & encode driver backend for the
+ Intel G45 chipsets and Intel HD Graphics for Intel Core processor
+ family.
+ .
+ This package contains the debug files for the video decode & encode
+ driver backend for the Intel G45 chipsets and Intel HD Graphics for
+ Intel Core processor family.
+ .
+ This package ensures a smooth upgrades from previous versions of Debian.
+ It can safely be removed if no other packages depend on it.
diff --git a/debian/copyright b/debian/copyright
new file mode 100644
index 0000000..f162a41
--- /dev/null
+++ b/debian/copyright
@@ -0,0 +1,304 @@
+Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
+Upstream-Name: i965-va-driver
+Upstream-Contact: Chang Zhou
+                  Gwenole Beauchesne
+                  Haihao Xiang (primary author)
+                  Nanhai Zou
+Source: http://www.freedesktop.org/wiki/Software/vaapi
+
+Files: *
+Copyright: 2006-2014, Intel Corportation
+           2009, Splitted-Desktop Systems
+License: Expat
+
+Files: src/shaders/*
+Copyright: 2006,2008-2013, Intel Corportation
+License: EPL-1.0
+ THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE
+ PUBLIC LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DISTRIBUTION
+ OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
+ .
+ 1. DEFINITIONS
+ .
+ "Contribution" means:
+ .
+    a) in the case of the initial Contributor, the initial code and
+       documentation distributed under this Agreement, and
+    b) in the case of each subsequent Contributor:
+       i) changes to the Program, and
+       ii) additions to the Program;
+       where such changes and/or additions to the Program originate
+       from and are distributed by that particular Contributor. A
+       Contribution 'originates' from a Contributor if it was added to
+       the Program by such Contributor itself or anyone acting on such
+       Contributor's behalf. Contributions do not include additions to
+       the Program which: (i) are separate modules of software
+       distributed in conjunction with the Program under their own
+       license agreement, and (ii) are not derivative works of the
+       Program.
+ .
+ "Contributor" means any person or entity that distributes the
+ Program.
+ .
+ "Licensed Patents" mean patent claims licensable by a Contributor
+ which are necessarily infringed by the use or sale of its
+ Contribution alone or when combined with the Program.
+ .
+ "Program" means the Contributions distributed in accordance with this
+ Agreement.
+ .
+ "Recipient" means anyone who receives the Program under this
+ Agreement, including all Contributors.
+ .
+ 2. GRANT OF RIGHTS
+ .
+    a) Subject to the terms of this Agreement, each Contributor hereby
+       grants Recipient a non-exclusive, worldwide, royalty-free
+       copyright license to reproduce, prepare derivative works of,
+       publicly display, publicly perform, distribute and sublicense
+       the Contribution of such Contributor, if any, and such
+       derivative works, in source code and object code form.
+    b) Subject to the terms of this Agreement, each Contributor hereby
+       grants Recipient a non-exclusive, worldwide, royalty-free
+       patent license under Licensed Patents to make, use, sell, offer
+       to sell, import and otherwise transfer the Contribution of such
+       Contributor, if any, in source code and object code form. This
+       patent license shall apply to the combination of the
+       Contribution and the Program if, at the time the Contribution
+       is added by the Contributor, such addition of the Contribution
+       causes such combination to be covered by the Licensed
+       Patents. The patent license shall not apply to any other
+       combinations which include the Contribution. No hardware per se
+       is licensed hereunder.
+    c) Recipient understands that although each Contributor grants the
+       licenses to its Contributions set forth herein, no assurances
+       are provided by any Contributor that the Program does not
+       infringe the patent or other intellectual property rights of
+       any other entity. Each Contributor disclaims any liability to
+       Recipient for claims brought by any other entity based on
+       infringement of intellectual property rights or otherwise. As a
+       condition to exercising the rights and licenses granted
+       hereunder, each Recipient hereby assumes sole responsibility to
+       secure any other intellectual property rights needed, if
+       any. For example, if a third party patent license is required
+       to allow Recipient to distribute the Program, it is Recipient's
+       responsibility to acquire that license before distributing the
+       Program.
+    d) Each Contributor represents that to its knowledge it has
+       sufficient copyright rights in its Contribution, if any, to
+       grant the copyright license set forth in this Agreement.
+ .
+ 3. REQUIREMENTS
+ .
+ A Contributor may choose to distribute the Program in object code
+ form under its own license agreement, provided that:
+ .
+    a) it complies with the terms and conditions of this Agreement;
+       and
+    b) its license agreement:
+       i) effectively disclaims on behalf of all Contributors all
+          warranties and conditions, express and implied, including
+          warranties or conditions of title and non-infringement, and
+          implied warranties or conditions of merchantability and
+          fitness for a particular purpose;
+       ii) effectively excludes on behalf of all Contributors all
+          liability for damages, including direct, indirect, special,
+          incidental and consequential damages, such as lost profits;
+       iii) states that any provisions which differ from this
+          Agreement are offered by that Contributor alone and not by
+          any other party; and
+       iv) states that source code for the Program is available from
+          such Contributor, and informs licensees how to obtain it in
+          a reasonable manner on or through a medium customarily used
+          for software exchange.
+ .
+ When the Program is made available in source code form:
+ .
+    a) it must be made available under this Agreement; and
+    b) a copy of this Agreement must be included with each copy of the Program.
+ .
+ Contributors may not remove or alter any copyright notices contained
+ within the Program.
+ .
+ Each Contributor must identify itself as the originator of its
+ Contribution, if any, in a manner that reasonably allows subsequent
+ Recipients to identify the originator of the Contribution.
+ .
+ 4. COMMERCIAL DISTRIBUTION
+ .
+ Commercial distributors of software may accept certain
+ responsibilities with respect to end users, business partners and the
+ like. While this license is intended to facilitate the commercial use
+ of the Program, the Contributor who includes the Program in a
+ commercial product offering should do so in a manner which does not
+ create potential liability for other Contributors. Therefore, if a
+ Contributor includes the Program in a commercial product offering,
+ such Contributor ("Commercial Contributor") hereby agrees to defend
+ and indemnify every other Contributor ("Indemnified Contributor")
+ against any losses, damages and costs (collectively "Losses") arising
+ from claims, lawsuits and other legal actions brought by a third
+ party against the Indemnified Contributor to the extent caused by the
+ acts or omissions of such Commercial Contributor in connection with
+ its distribution of the Program in a commercial product offering. The
+ obligations in this section do not apply to any claims or Losses
+ relating to any actual or alleged intellectual property
+ infringement. In order to qualify, an Indemnified Contributor must:
+ a) promptly notify the Commercial Contributor in writing of such
+ claim, and b) allow the Commercial Contributor to control, and
+ cooperate with the Commercial Contributor in, the defense and any
+ related settlement negotiations. The Indemnified Contributor may
+ participate in any such claim at its own expense.
+ .
+ For example, a Contributor might include the Program in a commercial
+ product offering, Product X. That Contributor is then a Commercial
+ Contributor. If that Commercial Contributor then makes performance
+ claims, or offers warranties related to Product X, those performance
+ claims and warranties are such Commercial Contributor's
+ responsibility alone. Under this section, the Commercial Contributor
+ would have to defend claims against the other Contributors related to
+ those performance claims and warranties, and if a court requires any
+ other Contributor to pay any damages as a result, the Commercial
+ Contributor must pay those damages.
+ .
+ 5. NO WARRANTY
+ .
+ EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS
+ PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY
+ WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY
+ OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is solely
+ responsible for determining the appropriateness of using and
+ distributing the Program and assumes all risks associated with its
+ exercise of rights under this Agreement , including but not limited
+ to the risks and costs of program errors, compliance with applicable
+ laws, damage to or loss of data, programs or equipment, and
+ unavailability or interruption of operations.
+ .
+ 6. DISCLAIMER OF LIABILITY
+ .
+ EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT
+ NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON
+ ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+ THE USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS
+ GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ DAMAGES.
+ .
+ 7. GENERAL
+ .
+ If any provision of this Agreement is invalid or unenforceable under
+ applicable law, it shall not affect the validity or enforceability of
+ the remainder of the terms of this Agreement, and without further
+ action by the parties hereto, such provision shall be reformed to the
+ minimum extent necessary to make such provision valid and
+ enforceable.
+ .
+ If Recipient institutes patent litigation against any entity
+ (including a cross-claim or counterclaim in a lawsuit) alleging that
+ the Program itself (excluding combinations of the Program with other
+ software or hardware) infringes such Recipient's patent(s), then such
+ Recipient's rights granted under Section 2(b) shall terminate as of
+ the date such litigation is filed.
+ .
+ All Recipient's rights under this Agreement shall terminate if it
+ fails to comply with any of the material terms or conditions of this
+ Agreement and does not cure such failure in a reasonable period of
+ time after becoming aware of such noncompliance. If all Recipient's
+ rights under this Agreement terminate, Recipient agrees to cease use
+ and distribution of the Program as soon as reasonably
+ practicable. However, Recipient's obligations under this Agreement
+ and any licenses granted by Recipient relating to the Program shall
+ continue and survive.
+ .
+ Everyone is permitted to copy and distribute copies of this
+ Agreement, but in order to avoid inconsistency the Agreement is
+ copyrighted and may only be modified in the following manner. The
+ Agreement Steward reserves the right to publish new versions
+ (including revisions) of this Agreement from time to time. No one
+ other than the Agreement Steward has the right to modify this
+ Agreement. The Eclipse Foundation is the initial Agreement
+ Steward. The Eclipse Foundation may assign the responsibility to
+ serve as the Agreement Steward to a suitable separate entity. Each
+ new version of the Agreement will be given a distinguishing version
+ number. The Program (including Contributions) may always be
+ distributed subject to the version of the Agreement under which it
+ was received. In addition, after a new version of the Agreement is
+ published, Contributor may elect to distribute the Program (including
+ its Contributions) under the new version. Except as expressly stated
+ in Sections 2(a) and 2(b) above, Recipient receives no rights or
+ licenses to the intellectual property of any Contributor under this
+ Agreement, whether expressly, by implication, estoppel or
+ otherwise. All rights in the Program not expressly granted under this
+ Agreement are reserved.
+ .
+ This Agreement is governed by the laws of the State of New York and
+ the intellectual property laws of the United States of America. No
+ party to this Agreement will bring a legal action under this
+ Agreement more than one year after the cause of action arose. Each
+ party waives its rights to a jury trial in any resulting litigation.
+
+Files: src/shaders/post_processing/gen7/*.g4a
+       src/shaders/post_processing/gen8/*.g8a
+Copyright: 2000-2012, Intel Corportation
+License: Apache-2.0
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+ .
+ http://www.apache.org/licenses/LICENSE-2.0
+ .
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ .
+ On a Debian system, the complete text of the Apache License, Version 2.0 can be
+ found in "/usr/share/common-licenses/Apache-2.0".
+
+Files: src/shaders/render/*.g8a
+Copyright: 2013, Intel Corporation
+License: Expat
+
+Files: debian/*
+Copyright: 2011 Brandon Snider <brandonjsnider@gmail.com>
+License: GPL-2+
+ This package is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ .
+ This package is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+Comment:
+ You should have received a copy of the GNU General Public License
+ along with this program. If not, see <http://www.gnu.org/licenses/>
+ .
+ On Debian systems, the complete text of the GNU General
+ Public License version 2 can be found in "/usr/share/common-licenses/GPL-2".
+
+License: Expat
+ Permission is hereby granted, free of charge, to any person obtaining a
+ copy of this software and associated documentation files (the
+ "Software"), to deal in the Software without restriction, including
+ without limitation the rights to use, copy, modify, merge, publish,
+ distribute, sub license, and/or sell copies of the Software, and to
+ permit persons to whom the Software is furnished to do so, subject to
+ the following conditions:
+ .
+ The above copyright notice and this permission notice (including the
+ next paragraph) shall be included in all copies or substantial portions
+ of the Software.
+ .
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
diff --git a/debian/gbp.conf b/debian/gbp.conf
new file mode 100644
index 0000000..cec628c
--- /dev/null
+++ b/debian/gbp.conf
@@ -0,0 +1,2 @@
+[DEFAULT]
+pristine-tar = True
diff --git a/debian/i965-va-driver.install b/debian/i965-va-driver.install
new file mode 100644
index 0000000..6deaf51
--- /dev/null
+++ b/debian/i965-va-driver.install
@@ -0,0 +1 @@
+usr/lib/*/dri/*.so
diff --git a/debian/intel-get-orig-source b/debian/intel-get-orig-source
new file mode 100755
index 0000000..71dad1d
--- /dev/null
+++ b/debian/intel-get-orig-source
@@ -0,0 +1,65 @@
+#!/bin/sh
+
+# This script is used to download the upstream source for libva and
+# generate it into an orig source tarball for Debian.
+
+# Common variables used to ease maintenance of this script
+I965_VERSION="1.0.15"
+I965_TARBALL="intel-driver-$I965_VERSION.tar.gz"
+I965_ORIG_TARBALL="intel-driver_$I965_VERSION.orig.tar.gz"
+USAGE="\n\
+This script is used to generate the orig tarball used in building\n\
+Debian packages for intel-driver-$I965_VERSION.\n\
+Usage: i965-get-orig-source [OPTION]\n\
+\n\
+ -h, --help                 Display this help message.\n"
+
+while [ "$#" -gt "0" ]
+do
+    case "$1" in
+        -h|--help|*)
+            echo "${USAGE}"
+            exit 1
+            ;;
+    esac
+done
+
+make_current_tarball() {
+    # Download the tarball if it's not available in the current directory
+    [ -f $I965_TARBALL ] || \
+        wget -c http://cgit.freedesktop.org/vaapi/intel-driver/snapshot/$I965_TARBALL
+
+    # Extract tarball and run 'autoreconf -vif'
+    echo "Extracting tarball and running 'autoreconf -vif'"
+    tar -zxf $I965_TARBALL
+    cd intel-driver-$I965_VERSION
+    autoreconf -vif
+    cd ..
+
+    # Remove temp files and other cruft from source tarball
+    # The find command snippet here was taken from debhelper's dh_clean command
+    # with some modification to delete more unneeded files.
+    echo "Removing temp files and other cruft from source tarball"
+    find intel-driver-$I965_VERSION \( \( -type f -a \
+        \( -name '#*#' -o -name '.*~' -o -name '*~' -o -name DEADJOE \
+        -o -name '*.orig' -o -name '*.rej' -o -name '*.bak' \
+        -o -name '.*.orig' -o -name .*.rej -o -name '.SUMS' \
+        -o -name TAGS -o \( -path '*/.deps/*' -a -name '*.P' \) \
+        -o -name config.status -o -name config.cache -o -name config.log \
+        \) -exec rm -f "{}" \; \) -o \
+        \( -type d -a -name autom4te.cache -prune -exec rm -rf "{}" \; \) \)
+    rm intel-driver-$I965_VERSION/.gitignore
+    rm intel-driver-$I965_VERSION/.cvsignore
+    rm -rf intel-driver-$I965_VERSION/debian.upstream
+    rm -rf intel-driver-$I965_VERSION/debian
+
+    # Remove empty directories
+    echo "Removing empty directories"
+    find intel-driver-$I965_VERSION -type d -empty -delete
+
+    # Repack tarball to final orig tarball
+    echo "Creating orig tarball"
+    tar --exclude-vcs -zcf "$I965_ORIG_TARBALL" "intel-driver-$I965_VERSION/"
+}
+
+make_current_tarball
diff --git a/debian/patches/0001-Fix_FTBFS_on_kFreeBSD.patch b/debian/patches/0001-Fix_FTBFS_on_kFreeBSD.patch
new file mode 100644
index 0000000..972326d
--- /dev/null
+++ b/debian/patches/0001-Fix_FTBFS_on_kFreeBSD.patch
@@ -0,0 +1,33 @@
+From: "Matteo F. Vescovi" <mfv.debian@gmail.com>
+Date: Fri, 27 Sep 2013 09:49:05 +0200
+Subject: Fix_FTBFS_on_kFreeBSD
+
+---
+ src/intel_driver.h | 1 +
+ src/intel_memman.c | 1 +
+ 2 files changed, 2 insertions(+)
+
+diff --git a/src/intel_driver.h b/src/intel_driver.h
+index 8f44274..7f83eb6 100644
+--- a/src/intel_driver.h
++++ b/src/intel_driver.h
+@@ -5,6 +5,7 @@
+ #include <pthread.h>
+ #include <signal.h>
+ #include <stdbool.h>
++#include <stdint.h>
+ 
+ #include <drm.h>
+ #include <i915_drm.h>
+diff --git a/src/intel_memman.c b/src/intel_memman.c
+index 7d56e96..bacad73 100644
+--- a/src/intel_memman.c
++++ b/src/intel_memman.c
+@@ -28,6 +28,7 @@
+  */
+ 
+ #include <assert.h>
++#include <stdint.h>
+ 
+ #include "intel_driver.h"
+ 
diff --git a/debian/patches/series b/debian/patches/series
new file mode 100644
index 0000000..f1f963d
--- /dev/null
+++ b/debian/patches/series
@@ -0,0 +1 @@
+0001-Fix_FTBFS_on_kFreeBSD.patch
diff --git a/debian/rules b/debian/rules
new file mode 100755
index 0000000..832597e
--- /dev/null
+++ b/debian/rules
@@ -0,0 +1,16 @@
+#!/usr/bin/make -f
+
+%:
+	dh $@ --parallel --with autoreconf
+
+override_dh_strip:
+	dh_strip --dbg-package=i965-va-driver-dbg
+
+override_dh_installchangelogs:
+	dh_installchangelogs NEWS
+
+override_dh_auto_build:
+	dh_auto_build -- V=1
+
+get-orig-source:
+	$(dir $_)intel-get-orig-source
diff --git a/debian/source/format b/debian/source/format
new file mode 100644
index 0000000..89ae9db
--- /dev/null
+++ b/debian/source/format
@@ -0,0 +1 @@
+3.0 (native)
diff --git a/debian/source/options b/debian/source/options
new file mode 100644
index 0000000..9cdfca9
--- /dev/null
+++ b/debian/source/options
@@ -0,0 +1,2 @@
+unapply-patches
+abort-on-upstream-changes
diff --git a/debian/watch b/debian/watch
new file mode 100644
index 0000000..4505187
--- /dev/null
+++ b/debian/watch
@@ -0,0 +1,3 @@
+version=3
+# we look for urls like http://cgit.freedesktop.org/vaapi/intel-driver/snapshot/intel-driver-1.0.5.tar.bz2
+http://cgit.freedesktop.org/vaapi/intel-driver/ /vaapi/intel-driver/snapshot/intel-driver-([\d+\.]+)\.tar\.gz

From a18dd39d59af6b765670b0ca91057813241bd7a0 Mon Sep 17 00:00:00 2001
From: fritsch <Peter.Fruehberger@gmail.com>
Date: Tue, 19 Aug 2014 20:34:00 +0200
Subject: [PATCH 19/19] Bump version to 1.3.3~pre4-1~trusty

---
 debian/changelog | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/debian/changelog b/debian/changelog
index 1414df0..b457b0d 100644
--- a/debian/changelog
+++ b/debian/changelog
@@ -1,3 +1,15 @@
+intel-vaapi-driver (1.3.3~pre4-1~trusty) trusty; urgency=medium
+
+  * Fix memory leak with state table (fixes advanced deinterlacing)
+
+ -- wsnipex <wsnipex@a1.net>  Wed, 26 Aug 2014 18:22:31 +0200
+
+intel-vaapi-driver (1.3.3~pre2-1~trusty) trusty; urgency=medium
+
+  * Base on gwenoles vebox rewrite
+
+ -- wsnipex <wsnipex@a1.net>  Wed, 19 Aug 2014 20:32:37 +0200
+
 intel-vaapi-driver (1.3.3~pre1-3~trusty) trusty; urgency=medium
 
   * [PATCH] decoder: h264: fix RefPicList0/1 without frame in DPB
