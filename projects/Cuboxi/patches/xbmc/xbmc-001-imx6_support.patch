diff -Naur xbmc-gotham-latest.test/configure.in xbmc-wolfgar-imx-wip.test/configure.in
--- xbmc-gotham-latest.test/configure.in	2014-02-09 01:41:42.290169158 +0100
+++ xbmc-wolfgar-imx-wip.test/configure.in	2014-02-09 01:40:43.539103171 +0100
@@ -555,7 +555,7 @@
 
 AC_ARG_ENABLE([codec],
   [AS_HELP_STRING([--enable-codec],
-  [enable additional codecs from a list of comma separated names, (default is none, choices are amcodec, libstagefright)])],
+  [enable additional codecs from a list of comma separated names, (default is none, choices are amcodec, libstagefright and imxvpu)])],
   [add_codecs=$enableval],
   [add_codecs=no])
 
@@ -1985,6 +1985,17 @@
     *libstagefright*)
         XB_ADD_CODEC([LIBSTAGEFRIGHT], [libstagefright], [$codecs])
         ;;
+    *imxvpu*)
+      AC_CHECK_HEADER([imx-mm/vpu/vpu_wrapper.h],, AC_MSG_ERROR($missing_headers))
+      AC_CHECK_LIB([vpu], main, LIBS="$LIBS -lfslvpuwrap -lvpu", AC_MSG_ERROR($missing_library))
+      XB_ADD_CODEC([IMXVPU], [imxvpu], [$codecs])
+      CXXFLAGS="$CXXFLAGS -Wno-psabi -DLINUX "
+      CFLAGS="$CFLAGS -DLINUX"
+      if test "$use_x11" = "no"; then
+        CXXFLAGS="$CXXFLAGS -DEGL_API_FB"
+        CFLAGS="$CFLAGS -DEGL_API_FB"
+      fi
+      ;;     
     *)
   esac
 done
@@ -2663,6 +2674,7 @@
 AC_SUBST(GNUTLS_ALL_LIBS)
 AC_SUBST(VORBISENC_ALL_LIBS)
 
+
 # pushd and popd are not available in other shells besides bash, so implement
 # our own pushd/popd functions
 XB_DIRSTACK="$PWD"
diff -Naur xbmc-gotham-latest.test/lib/ffmpeg/libavcodec/arm/dca.h xbmc-wolfgar-imx-wip.test/lib/ffmpeg/libavcodec/arm/dca.h
--- xbmc-gotham-latest.test/lib/ffmpeg/libavcodec/arm/dca.h	2014-02-09 01:41:27.311152362 +0100
+++ xbmc-wolfgar-imx-wip.test/lib/ffmpeg/libavcodec/arm/dca.h	2014-02-09 01:40:36.140094843 +0100
@@ -30,9 +30,9 @@
 
 #define decode_blockcodes decode_blockcodes
 static inline int decode_blockcodes(int code1, int code2, int levels,
-                                    int *values)
+                                    int32_t *values)
 {
-    int v0, v1, v2, v3, v4, v5;
+    int32_t v0, v1, v2, v3, v4, v5;
 
     __asm__ ("smmul   %0,  %6,  %10           \n"
              "smmul   %3,  %7,  %10           \n"
@@ -101,3 +101,4 @@
 #endif
 
 #endif /* AVCODEC_ARM_DCA_H */
+
diff -Naur xbmc-gotham-latest.test/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp xbmc-wolfgar-imx-wip.test/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
--- xbmc-gotham-latest.test/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp	2014-02-09 01:41:15.200138764 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp	2014-02-09 01:40:26.161083601 +0100
@@ -714,7 +714,10 @@
    * will automatically add "@" instead to enable surroundXX mangling.
    * We don't want to do that if "default" can handle multichannel
    * itself (e.g. in case of a pulseaudio server). */
-  EnumerateDevice(list, "default", "", config);
+
+  /* For Wandboard, we do not enurate default device as it will be grabbed
+   * as one of the sysdefault devices... */
+
 
   void **hints;
 
@@ -765,8 +768,8 @@
        * found by the enumeration process. Skip them as well ("hw", "dmix",
        * "plughw", "dsnoop"). */
 
+      /* For wandboard all devices are prefixed by sysdefault so do not ignore them */
       else if (baseName != "default"
-            && baseName != "sysdefault"
             && baseName != "surround40"
             && baseName != "surround41"
             && baseName != "surround50"
@@ -875,6 +878,22 @@
 
 AEDeviceType CAESinkALSA::AEDeviceTypeFromName(const std::string &name)
 {
+  std::size_t found;
+
+  /* Hack : Check for specific wandboard sound device names */
+  found = name.find("imxspdif");
+  if (found!=std::string::npos)
+    return AE_DEVTYPE_IEC958;
+
+  found = name.find("imxhdmisoc");
+  if (found!=std::string::npos)
+    return AE_DEVTYPE_HDMI;
+
+  found = name.find("sgtl5000audio");
+  if (found!=std::string::npos)
+    return AE_DEVTYPE_PCM;
+
+
   if (name.substr(0, 4) == "hdmi")
     return AE_DEVTYPE_HDMI;
   else if (name.substr(0, 6) == "iec958" || name.substr(0, 5) == "spdif")
diff -Naur xbmc-gotham-latest.test/xbmc/cores/AudioEngine/Utils/AEConvert.cpp xbmc-wolfgar-imx-wip.test/xbmc/cores/AudioEngine/Utils/AEConvert.cpp
--- xbmc-gotham-latest.test/xbmc/cores/AudioEngine/Utils/AEConvert.cpp	2014-02-09 01:41:15.237138806 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/AudioEngine/Utils/AEConvert.cpp	2014-02-09 01:40:26.223083671 +0100
@@ -841,7 +841,7 @@
   _mm_empty();
   #else /* no SSE2 */
   for (uint32_t i = 0; i < samples; ++i)
-    *dst++ = (safeRound(*data++ * ((float)INT24_MAX+.5f)) & 0xFFFFFF) << 8;
+    *dst++ = safeRound(*data++ * ((float)INT24_MAX+.5f)) & 0x00FFFFFF;
   #endif
 
   return samples << 2;
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2014-02-09 01:41:14.964138497 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2014-02-09 01:40:25.777083169 +0100
@@ -35,6 +35,9 @@
 #include "Video/DVDVideoCodecFFmpeg.h"
 #include "Video/DVDVideoCodecOpenMax.h"
 #include "Video/DVDVideoCodecLibMpeg2.h"
+#if defined(HAS_IMXVPU)
+#include "Video/DVDVideoCodecIMX.h"
+#endif
 #include "Video/DVDVideoCodecStageFright.h"
 #if defined(HAVE_LIBCRYSTALHD)
 #include "Video/DVDVideoCodecCrystalHD.h"
@@ -194,7 +197,11 @@
 #elif defined(TARGET_POSIX) && !defined(TARGET_DARWIN)
   hwSupport += "VAAPI:no ";
 #endif
-
+#if defined(HAS_IMXVPU)
+  hwSupport += "iMXVPU:yes ";
+#else
+  hwSupport += "iMXVPU:no ";
+#endif  
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 #if defined(HAS_LIBAMCODEC)
   // amcodec can handle dvd playback.
@@ -208,6 +215,15 @@
     }
   }
 
+/*#endif*/
+  
+#if defined(HAS_IMXVPU)
+  if (!hint.software)
+  {
+    if ( (pCodec = OpenCodec(new CDVDVideoCodecIMX(), hint, options)) ) return pCodec;
+  }
+#endif
+  
 #if defined(TARGET_DARWIN_OSX)
   if (!hint.software && CSettings::Get().GetBool("videoplayer.usevda"))
   {
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2014-02-09 01:41:14.980138516 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2014-02-09 01:40:25.834083233 +0100
@@ -38,7 +38,9 @@
 class COpenMax;
 class COpenMaxVideo;
 struct OpenMaxVideoBuffer;
+class CIMXOutputFrame;
 class CDVDVideoCodecStageFright;
+
 class CDVDMediaCodecInfo;
 typedef void* EGLImageKHR;
 
@@ -64,17 +66,19 @@
     struct {
       VAAPI::CHolder* vaapi;
     };
-
     struct {
       COpenMax *openMax;
       OpenMaxVideoBuffer *openMaxBuffer;
     };
-
     struct {
       struct __CVBuffer *cvBufferRef;
     };
 
     struct {
+      CIMXOutputFrame *imxOutputFrame;
+    };
+
+    struct {
       CDVDVideoCodecStageFright* stf;
       EGLImageKHR eglimg;
     };
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp	2014-02-09 01:40:25.852083253 +0100
@@ -0,0 +1,1745 @@
+/*
+ *      Copyright (C) 2013 Stephan Rafin
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/mxcfb.h>
+#include "DVDVideoCodecIMX.h"
+
+#include <linux/mxc_v4l2.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "DVDClock.h"
+#include "mfw_gst_ts.h"
+#include "threads/Atomics.h"
+
+//#define NO_V4L_RENDERING
+
+#ifdef IMX_PROFILE
+static unsigned long long render_ts[30];
+static unsigned long long get_time()
+{
+  struct timespec ts;
+  unsigned long long now;
+
+  clock_gettime(CLOCK_MONOTONIC, &ts);
+  now = (((unsigned long long)ts.tv_sec) * 1000000000ULL) +
+           ((unsigned long long)ts.tv_nsec);
+
+  return now;
+}
+#endif
+
+void CIMXOutputFrame::Render(struct v4l2_crop &crop)
+{
+  CIMXRenderingFrames& renderingFrames = CIMXRenderingFrames::GetInstance();
+  renderingFrames.Queue(this, crop);
+}
+
+/* video device on which the video will be rendered (/dev/video17 => /dev/fb1) */
+const char *CIMXRenderingFrames::m_v4lDeviceName = "/dev/video17";
+static long sg_singleton_lock_variable = 0;
+CIMXRenderingFrames* CIMXRenderingFrames::m_instance = 0;
+
+CIMXRenderingFrames&
+CIMXRenderingFrames::GetInstance()
+{
+  CAtomicSpinLock lock(sg_singleton_lock_variable);
+  if( ! m_instance )
+  {
+    m_instance = new CIMXRenderingFrames();
+  }
+  return *m_instance;
+}
+
+CIMXRenderingFrames::CIMXRenderingFrames()
+{
+  m_ready = false;
+  m_v4lfd = -1;
+  m_virtAddr = NULL;
+  m_v4lBuffers = NULL;
+  memset(&m_crop, 0, sizeof(m_crop));
+  m_crop.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+  m_motionCtrl = -1;
+}
+
+bool CIMXRenderingFrames::AllocateBuffers(const struct v4l2_format *format, int nbBuffers)
+{
+  int ret, i;
+  struct v4l2_requestbuffers bufReq;
+  struct v4l2_format fmt;
+  struct v4l2_buffer v4lBuf;
+  struct v4l2_control ctrl;
+
+  CSingleLock lock(m_renderingFramesLock);
+  if (m_ready)
+  {
+    CLog::Log(LOGERROR, "%s - Try to re-allocate buffers while previous buffers were not freed.\n", __FUNCTION__);
+    return false;
+  }
+
+  m_v4lfd = open(m_v4lDeviceName, O_RDWR|O_NONBLOCK, 0);
+  if (m_v4lfd < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while trying to open %s.\n", __FUNCTION__, m_v4lDeviceName);
+    __ReleaseBuffers();
+    return false;
+  }
+
+  ret = ioctl(m_v4lfd, VIDIOC_S_FMT, format);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while setting V4L format (ret %d : %s).\n", __FUNCTION__, ret, strerror(errno));
+    __ReleaseBuffers();
+    return false;
+  }
+
+  if (format->fmt.pix.field != V4L2_FIELD_NONE)
+  {
+    char * motion_entry;
+    motion_entry =  getenv("IMX_DEINT_MOTION");
+    if (motion_entry != NULL)
+    {
+      errno = 0;
+      m_motionCtrl = strtol(motion_entry, NULL, 10);
+      if (errno != 0)
+        m_motionCtrl = -1;
+    }
+    if (m_motionCtrl == -1)
+      m_motionCtrl = 2; /* Default value : 2 stands for high motion */
+
+    if ((m_motionCtrl >= 0) && (m_motionCtrl <=2))
+    {
+      ctrl.id = V4L2_CID_MXC_MOTION;
+      ctrl.value = m_motionCtrl;
+      ret = ioctl (m_v4lfd, VIDIOC_S_CTRL, &ctrl);
+      if (ret < 0)
+      {
+        CLog::Log(LOGERROR, "%s - Error while setting V4L motion (ret %d : %s).\n", __FUNCTION__, ret, strerror(errno));
+      }
+    }
+    else
+    {
+      CLog::Log(LOGNOTICE, "%s - IMX_DEINT_MOTION set to %d. Disabling deinterlacing.\n", __FUNCTION__, m_motionCtrl);
+      m_motionCtrl = -2;
+    }
+  }
+
+  fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+  ret = ioctl(m_v4lfd, VIDIOC_G_FMT, &fmt);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while getting V4L format (ret %d : %s).\n", __FUNCTION__, ret, strerror(errno));
+    __ReleaseBuffers();
+    return false;
+  }
+
+  m_bufferNum = nbBuffers;
+  /* Alloc V4L2 buffers */
+  memset(&bufReq, 0, sizeof(bufReq));
+  bufReq.count =  m_bufferNum;
+  bufReq.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+  bufReq.memory = V4L2_MEMORY_MMAP;
+  ret = ioctl(m_v4lfd, VIDIOC_REQBUFS, &bufReq);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s - %d Hw buffer allocation error (%d)\n", __FUNCTION__, bufReq.count, ret);
+    __ReleaseBuffers();
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s - %d Hw buffer of %d bytes allocated\n", __FUNCTION__, bufReq.count, fmt.fmt.pix.sizeimage);
+
+  m_virtAddr = new void*[m_bufferNum];
+  if (m_virtAddr == NULL)
+  {
+    CLog::Log(LOGERROR, "%s - Allocation failure (m_virtAddr table of %d elements)\n", __FUNCTION__, m_bufferNum);
+    __ReleaseBuffers();
+    return false;
+  }
+  m_v4lBuffers = new v4l2_buffer[m_bufferNum];
+  if (m_v4lBuffers == NULL)
+  {
+    CLog::Log(LOGERROR, "%s - Allocation failure (m_v4lBuffers table of %d elements)\n", __FUNCTION__, m_bufferNum);
+    __ReleaseBuffers();
+    return false;
+  }
+
+  for (i = 0 ; i < m_bufferNum; i++)
+  {
+    memset(&v4lBuf, 0, sizeof(v4lBuf));
+    v4lBuf.index = i;
+    v4lBuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+    v4lBuf.memory = V4L2_MEMORY_MMAP;
+    ret = ioctl (m_v4lfd, VIDIOC_QUERYBUF, &v4lBuf);
+    if (ret < 0)
+    {
+      CLog::Log(LOGERROR, "%s - Error during 1st query of V4L buffer (ret %d : %s)\n", __FUNCTION__, ret, strerror(errno));
+      return false;
+    }
+    m_v4lBuffers[i] = v4lBuf;
+    m_virtAddr[i] = NULL;
+  }
+  memset(&m_crop, 0, sizeof(m_crop));
+  m_crop.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+  m_pushedFrames = 0;
+  m_streamOn = false;
+  m_ready = true;
+  return true;
+}
+
+void *CIMXRenderingFrames::GetVirtAddr(int idx)
+{
+  struct v4l2_buffer v4lBuf;
+  int ret;
+
+  CSingleLock lock(m_renderingFramesLock);
+  if (!m_ready)
+    return NULL;
+  if ((idx < 0) || (idx >= m_bufferNum))
+    return NULL;
+
+  if (m_virtAddr[idx] == NULL)
+  {
+    v4lBuf = m_v4lBuffers[idx];
+    m_virtAddr[idx] = mmap(NULL, v4lBuf.length, PROT_READ | PROT_WRITE, MAP_SHARED, m_v4lfd, v4lBuf.m.offset);
+
+    /* 2nd query to retrieve real Physical address after mmap (iMX6 bug) */
+    ret = ioctl (m_v4lfd, VIDIOC_QUERYBUF, &v4lBuf);
+    if (ret < 0)
+    {
+      CLog::Log(LOGERROR, "%s - Error during 2nd query of V4L buffer (ret %d : %s)\n", __FUNCTION__, ret, strerror(errno));
+    }
+    m_v4lBuffers[idx] = v4lBuf;
+  }
+  return m_virtAddr[idx];
+}
+
+void *CIMXRenderingFrames::GetPhyAddr(int idx)
+{
+
+  CSingleLock lock(m_renderingFramesLock);
+  if (!m_ready)
+    return NULL;
+  if ((idx < 0) || (idx >= m_bufferNum))
+    return NULL;
+
+  return (void *)m_v4lBuffers[idx].m.offset;
+}
+
+int CIMXRenderingFrames::FindBuffer(void *phyAddr)
+{
+  int i;
+
+  CSingleLock lock(m_renderingFramesLock);
+  if (!m_ready)
+    return -1;
+
+  for (i = 0; i < m_bufferNum; i++)
+  {
+    if (m_v4lBuffers[i].m.offset == (unsigned int)phyAddr)
+    {
+      // CLog::Log(LOGNOTICE, "%s - found buffer OK %d!\n", __FUNCTION__, i);
+      return i;
+    }
+  }
+  return -1;
+}
+
+int CIMXRenderingFrames::DeQueue(bool wait)
+{
+  int ret;
+  int status;
+  struct v4l2_buffer buf;
+
+  CSingleLock lock(m_renderingFramesLock);
+  if (!m_ready)
+  {
+    CLog::Log(LOGNOTICE, "%s - Cannot dequeue frame as buffers were released !\n",
+              __FUNCTION__);
+    return -1;
+  }
+  if (!m_streamOn)
+  {
+    return -1;
+  }
+
+  if (wait)
+  {
+    status = fcntl(m_v4lfd, F_GETFL);
+    fcntl(m_v4lfd, F_SETFL, status & (~O_NONBLOCK));
+  }
+  buf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+  buf.memory = V4L2_MEMORY_MMAP;
+  ret = ioctl(m_v4lfd, VIDIOC_DQBUF, &buf);
+  if (wait)
+  {
+    fcntl(m_v4lfd, F_SETFL, status | O_NONBLOCK);
+  }
+  if (ret != 0)
+  {
+    if (errno != EAGAIN)
+      CLog::Log(LOGERROR, "%s - Dequeue buffer error (ret %d : %s)\n",
+              __FUNCTION__, ret, strerror(errno));
+    return -1;
+  }
+
+#ifdef IMX_PROFILE
+          CLog::Log(LOGDEBUG, "%s - Time render to dequeue (%d) %llu\n",
+              __FUNCTION__, buf.index, get_time() - render_ts[buf.index]);
+#endif
+//  CLog::Log(LOGERROR, "%s dequeued retuns (%d)\n", __FUNCTION__, buf.index);
+
+  return buf.index;
+}
+
+void CIMXRenderingFrames::Queue(CIMXOutputFrame *picture, struct v4l2_crop &destRect)
+{
+  /* Warning : called from renderer thread
+   * Especially do not call any VPU functions as they are not thread safe
+   */
+
+  int ret, type;
+  struct timeval queue_ts;
+  int stream_trigger;
+  bool crop_update = false;
+
+  CSingleLock lock(m_renderingFramesLock);
+  if (!m_ready)
+  {
+    CLog::Log(LOGNOTICE, "%s - Cannot queue frame as buffers were released !\n",
+              __FUNCTION__);
+    return;
+  }
+
+  /*CLog::Log(LOGDEBUG, "%s - queuing frame %d - picture adress : %p\n",
+              __FUNCTION__, picture->v4l2BufferIdx, picture);*/
+
+  if ((picture->v4l2BufferIdx < 0) || (picture->v4l2BufferIdx >= m_bufferNum))
+  {
+    CLog::Log(LOGERROR, "%s - Invalid buffer index : %d - picture address : %p\n",
+              __FUNCTION__, picture->v4l2BufferIdx, picture);
+    return;
+  }
+
+  /* Set field type for each buffer otherwise the mxc_vout driver reverts to progressive */
+  switch (picture->field)
+  {
+  case VPU_FIELD_TB:
+    m_v4lBuffers[picture->v4l2BufferIdx].field = V4L2_FIELD_INTERLACED_TB;
+    break;
+  case VPU_FIELD_BT:
+    m_v4lBuffers[picture->v4l2BufferIdx].field= V4L2_FIELD_INTERLACED_BT;
+    break;
+  case VPU_FIELD_NONE:
+  default:
+    m_v4lBuffers[picture->v4l2BufferIdx].field = V4L2_FIELD_NONE;
+    break;
+  }
+  /* In case deinterlacing is forced to disabled */
+  if (m_motionCtrl == -2)
+    m_v4lBuffers[picture->v4l2BufferIdx].field = V4L2_FIELD_NONE;
+
+  /* mxc_vout driver does not display immediatly
+   * if timestamp is set to 0
+   * (instead this driver expects a 30fps rate)
+   * So we explicitly set current time for immediate display
+   */
+  gettimeofday (&queue_ts, NULL);
+  m_v4lBuffers[picture->v4l2BufferIdx].timestamp = queue_ts;
+
+#ifndef NO_V4L_RENDERING
+  ret = ioctl(m_v4lfd, VIDIOC_QBUF, &m_v4lBuffers[picture->v4l2BufferIdx]);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "%s - V4L Queue buffer failed (ret %d : %s)\n",
+              __FUNCTION__, ret, strerror(errno));
+    /* If it fails odds are very high picture is invalid so just exit now */
+    return;
+  }
+  else
+  {
+    m_pushedFrames++;
+  }
+
+  /* Force cropping dimensions to be aligned */
+  destRect.c.top    &= 0xFFFFFFF8;
+  destRect.c.left   &= 0xFFFFFFF8;
+  destRect.c.width  &= 0xFFFFFFF8;
+  destRect.c.height &= 0xFFFFFFF8;
+  if ((m_crop.c.top != destRect.c.top) ||
+      (m_crop.c.left != destRect.c.left) ||
+      (m_crop.c.width != destRect.c.width) ||
+      (m_crop.c.height !=  destRect.c.height))
+  {
+    CLog::Log(LOGNOTICE, "%s - Newcrop : %d % d %d %d\n",
+              __FUNCTION__, destRect.c.top, destRect.c.left, destRect.c.width, destRect.c.height);
+    m_crop.c = destRect.c;
+    crop_update = true;
+  }
+
+  if (!m_streamOn)
+  {
+    if (picture->field == VPU_FIELD_NONE)
+      stream_trigger = 1;
+    else {
+      if (m_motionCtrl < 2)
+        stream_trigger = 3;
+      else
+        stream_trigger = 2;
+    }
+
+    if (m_pushedFrames >= stream_trigger) {
+      CLog::Log(LOGDEBUG, "%s - Motion control is : %d - Number of required frames before streaming : %d\n",
+                __FUNCTION__, m_motionCtrl, stream_trigger);
+
+      type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+      ret = ioctl(m_v4lfd, VIDIOC_STREAMON, &type);
+      if (ret < 0)
+      {
+        CLog::Log(LOGERROR, "%s - V4L Stream ON failed (ret %d : %s)\n",
+                __FUNCTION__, ret, strerror(errno));
+      }
+      else
+      {
+        CLog::Log(LOGDEBUG, "%s - V4L Stream ON OK\n",
+                __FUNCTION__);
+        m_streamOn = true;
+      }
+      /* We have to repeat crop command after streamon for some vids
+      * FIXME : Check why in drivers...
+      */
+      ret = ioctl(m_v4lfd, VIDIOC_S_CROP, &m_crop);
+      if (ret < 0)
+      {
+        CLog::Log(LOGERROR, "%s - S_CROP failed (ret %d : %s)\n",
+                __FUNCTION__, ret, strerror(errno));
+      }
+    }
+  }
+  else
+  {
+    if (crop_update)
+    {
+      ret = ioctl(m_v4lfd, VIDIOC_S_CROP, &m_crop);
+      if (ret < 0)
+      {
+        CLog::Log(LOGERROR, "%s - S_CROP failed (ret %d : %s)\n",
+                __FUNCTION__, ret, strerror(errno));
+      }
+    }
+  }
+#endif
+
+#ifdef IMX_PROFILE
+  render_ts[picture->v4l2BufferIdx] = get_time();
+  CLog::Log(LOGDEBUG, "%s - Time push to render (%d) %llu\n",
+              __FUNCTION__, picture->v4l2BufferIdx, render_ts[picture->v4l2BufferIdx] - picture->pushTS);
+#endif
+}
+
+void CIMXRenderingFrames::ReleaseBuffers()
+{
+  CSingleLock lock(m_renderingFramesLock);
+  if (!m_ready)
+  {
+      CLog::Log(LOGERROR, "%s - AllocateBuffers was not previously called\n", __FUNCTION__);
+      return;
+  }
+  __ReleaseBuffers();
+}
+
+/* Note : Has to be called with m_renderingFramesLock held */
+void CIMXRenderingFrames::__ReleaseBuffers()
+{
+  int type, i;
+
+  if (m_v4lfd >= 0)
+  {
+    /* stream off */
+    type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+    ioctl (m_v4lfd, VIDIOC_STREAMOFF, &type);
+    m_streamOn = false;
+  }
+
+  if (m_virtAddr != NULL)
+  {
+    for (i = 0; i < m_bufferNum; i++)
+    {
+      if (m_virtAddr[i] != NULL)
+        munmap (m_virtAddr[i], m_v4lBuffers[i].length);
+    }
+    delete m_virtAddr;
+    m_virtAddr = NULL;
+  }
+
+  if (m_v4lfd >= 0)
+  {
+    /* Close V4L2 device */
+    close(m_v4lfd);
+    m_v4lfd = -1;
+  }
+
+  if (m_v4lBuffers != NULL)
+  {
+    delete m_v4lBuffers;
+    m_v4lBuffers = NULL;
+  }
+  m_bufferNum = 0;
+  m_pushedFrames = 0;
+  m_ready = false;
+  m_motionCtrl = -1;
+}
+
+/* FIXME get rid of these defines properly */
+#define FRAME_ALIGN 16
+#define MEDIAINFO 1
+#define _4CC(c1,c2,c3,c4) (((uint32_t)(c4)<<24)|((uint32_t)(c3)<<16)|((uint32_t)(c2)<<8)|(uint32_t)(c1))
+#define Align(ptr,align)  (((unsigned int)ptr + (align) - 1)/(align)*(align))
+#define min(a, b) (a<b)?a:b
+
+#define IMX_MAX_QUEUE_SIZE 1
+/* Experiments show that we need at least one more (+1) V4L buffer than the min value returned by the VPU */
+const int CDVDVideoCodecIMX::m_extraVpuBuffers = IMX_MAX_QUEUE_SIZE + 6;
+
+static double GetPlayerPtsSeconds()
+{
+  double clock_pts = 0.0;
+  CDVDClock *playerclock = CDVDClock::GetMasterClock();
+  if (playerclock)
+    clock_pts = playerclock->GetClock() / DVD_TIME_BASE;
+
+  return clock_pts;
+}
+
+void CDVDVideoCodecIMX::FlushDecodedFrames(void)
+{
+  DVDVideoPicture DVDFrame;
+  while (m_decodedFrames.size() > 0)
+  {
+    DVDFrame = m_decodedFrames.front();
+    VpuReleaseBufferV4L(DVDFrame.imxOutputFrame->v4l2BufferIdx);
+    m_decodedFrames.pop();
+  }
+}
+
+bool CDVDVideoCodecIMX::VpuAllocBuffers(VpuMemInfo *pMemBlock)
+{
+  int i, size;
+  unsigned char * ptr;
+  VpuMemDesc vpuMem;
+  VpuDecRetCode ret;
+
+  for(i=0; i<pMemBlock->nSubBlockNum; i++)
+  {
+    size = pMemBlock->MemSubBlock[i].nAlignment + pMemBlock->MemSubBlock[i].nSize;
+    if (pMemBlock->MemSubBlock[i].MemType == VPU_MEM_VIRT)
+    { // Allocate standard virtual memory
+      ptr = (unsigned char *)malloc(size);
+      if(ptr == NULL)
+      {
+        CLog::Log(LOGERROR, "%s - Unable to malloc %d bytes.\n", __FUNCTION__, size);
+        goto AllocFailure;
+      }
+      pMemBlock->MemSubBlock[i].pVirtAddr = (unsigned char*)Align(ptr, pMemBlock->MemSubBlock[i].nAlignment);
+
+      m_decMemInfo.virtMem[m_decMemInfo.nVirtNum] = (unsigned int)ptr;
+      m_decMemInfo.nVirtNum++;
+    }
+    else
+    { // Allocate contigous mem for DMA
+      vpuMem.nSize = size;
+      ret = VPU_DecGetMem(&vpuMem);
+      if(ret != VPU_DEC_RET_SUCCESS)
+      {
+        CLog::Log(LOGERROR, "%s - Unable alloc %d bytes of physical memory (%d).\n", __FUNCTION__, size, ret);
+        goto AllocFailure;
+      }
+      pMemBlock->MemSubBlock[i].pVirtAddr = (unsigned char*)Align(vpuMem.nVirtAddr, pMemBlock->MemSubBlock[i].nAlignment);
+      pMemBlock->MemSubBlock[i].pPhyAddr = (unsigned char*)Align(vpuMem.nPhyAddr, pMemBlock->MemSubBlock[i].nAlignment);
+
+      m_decMemInfo.phyMem_phyAddr[m_decMemInfo.nPhyNum] = (unsigned int)vpuMem.nPhyAddr;
+      m_decMemInfo.phyMem_virtAddr[m_decMemInfo.nPhyNum] = (unsigned int)vpuMem.nVirtAddr;
+      m_decMemInfo.phyMem_cpuAddr[m_decMemInfo.nPhyNum] = (unsigned int)vpuMem.nCpuAddr;
+      m_decMemInfo.phyMem_size[m_decMemInfo.nPhyNum] = size;
+      m_decMemInfo.nPhyNum++;
+    }
+  }
+
+  return true;
+
+AllocFailure:
+        VpuFreeBuffers();
+        return false;
+}
+
+bool CDVDVideoCodecIMX::VpuFreeBuffers(void)
+{
+  int i;
+  VpuMemDesc vpuMem;
+  VpuDecRetCode vpuRet;
+  bool ret = true;
+
+  //free virtual mem
+  for(i=0; i<m_decMemInfo.nVirtNum; i++)
+  {
+    if (m_decMemInfo.virtMem[i])
+      free((void*)m_decMemInfo.virtMem[i]);
+  }
+  m_decMemInfo.nVirtNum = 0;
+
+  //free physical mem
+  for(i=0; i<m_decMemInfo.nPhyNum; i++)
+  {
+    vpuMem.nPhyAddr = m_decMemInfo.phyMem_phyAddr[i];
+    vpuMem.nVirtAddr = m_decMemInfo.phyMem_virtAddr[i];
+    vpuMem.nCpuAddr = m_decMemInfo.phyMem_cpuAddr[i];
+    vpuMem.nSize = m_decMemInfo.phyMem_size[i];
+    vpuRet = VPU_DecFreeMem(&vpuMem);
+    if(vpuRet != VPU_DEC_RET_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s - Errror while trying to free physical memory (%d).\n", __FUNCTION__, ret);
+      ret = false;
+    }
+  }
+  m_decMemInfo.nPhyNum = 0;
+
+  return ret;
+}
+
+
+bool CDVDVideoCodecIMX::VpuOpen(void)
+{
+  VpuDecRetCode  ret;
+  VpuVersionInfo vpuVersion;
+  VpuMemInfo     memInfo;
+  VpuDecConfig config;
+  int param;
+
+  memset(&memInfo, 0, sizeof(VpuMemInfo));
+  ret = VPU_DecLoad();
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s - VPU load failed with error code %d.\n", __FUNCTION__, ret);
+    goto VpuOpenError;
+  }
+
+  ret = VPU_DecGetVersionInfo(&vpuVersion);
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s - VPU version cannot be read (%d).\n", __FUNCTION__, ret);
+    goto VpuOpenError;
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "VPU Lib version : major.minor.rel=%d.%d.%d.\n", vpuVersion.nLibMajor, vpuVersion.nLibMinor, vpuVersion.nLibRelease);
+  }
+
+  ret = VPU_DecQueryMem(&memInfo);
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+          CLog::Log(LOGERROR, "%s - iMX VPU query mem error (%d).\n", __FUNCTION__, ret);
+          goto VpuOpenError;
+  }
+  VpuAllocBuffers(&memInfo);
+
+  m_decOpenParam.nReorderEnable = 1;
+  m_decOpenParam.nChromaInterleave = 0;
+  m_decOpenParam.nMapType = 0;
+  m_decOpenParam.nTiled2LinearEnable = 0;
+  m_decOpenParam.nEnableFileMode = 0;
+
+  ret = VPU_DecOpen(&m_vpuHandle, &m_decOpenParam, &memInfo);
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s - iMX VPU open failed (%d).\n", __FUNCTION__, ret);
+    goto VpuOpenError;
+  }
+
+  config = VPU_DEC_CONF_SKIPMODE;
+  param = VPU_DEC_SKIPNONE;
+  ret = VPU_DecConfig(m_vpuHandle, config, &param);
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s - iMX VPU set skip mode failed  (%d).\n", __FUNCTION__, ret);
+    goto VpuOpenError;
+  }
+
+  /* Initialize ts manager */
+  m_tsm = createTSManager(0);
+  setTSManagerFrameRate(m_tsm, m_hints.fpsrate, m_hints.fpsscale);
+
+  return true;
+
+VpuOpenError:
+  Dispose();
+  return false;
+}
+
+void CDVDVideoCodecIMX::InitFB(void)
+{
+  struct mxcfb_gbl_alpha alpha;
+  struct mxcfb_color_key colorKey;
+  int fd;
+
+  fd = open("/dev/fb0",O_RDWR);
+  /* set FG/BG semi opaque */
+  alpha.alpha = 235;
+  alpha.enable = 1;
+  ioctl(fd, MXCFB_SET_GBL_ALPHA, &alpha);
+  /* Enable color keying */
+  colorKey.enable = 1;
+  colorKey.color_key = (16 << 16) | (8 << 8) | 16;
+  if (ioctl(fd, MXCFB_SET_CLR_KEY, &colorKey) < 0)
+    CLog::Log(LOGERROR, "%s - Error while trying to enable color keying %s.\n", __FUNCTION__, strerror(errno));
+  close(fd);
+}
+
+void CDVDVideoCodecIMX::RestoreFB(void)
+{
+  struct mxcfb_gbl_alpha alpha;
+  struct mxcfb_color_key colorKey;
+  int fd;
+
+  fd = open("/dev/fb0",O_RDWR);
+  /* set FG as opaque */
+  alpha.alpha = 255;
+  alpha.enable = 1;
+  ioctl(fd, MXCFB_SET_GBL_ALPHA, &alpha);
+  /* Disable color keying */
+  colorKey.enable = 0;
+  colorKey.color_key = 0;
+  if (ioctl(fd, MXCFB_SET_CLR_KEY, &colorKey) < 0)
+    CLog::Log(LOGERROR, "%s - Error while trying to disable color keying %s.\n", __FUNCTION__, strerror(errno));
+  close(fd);
+}
+
+bool CDVDVideoCodecIMX::VpuAllocFrameBuffers(void)
+{
+  /* Alloc frame buffers from V4L2 for efficient rendering through V4L streaming */
+  struct v4l2_format fmt;
+  struct v4l2_rect rect;
+  int i, j;
+  int ySize, cSize;
+  VpuDecRetCode vpuRet;
+
+  InitFB();
+
+  /* Set V4L2 Format */
+  memset(&fmt, 0, sizeof(fmt));
+  fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+  fmt.fmt.pix.width = Align( m_initInfo.nPicWidth, FRAME_ALIGN);
+  fmt.fmt.pix.height = Align(m_initInfo.nPicHeight, FRAME_ALIGN);
+  fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;
+  /* Take into account cropping from decoded video (for input picture) */
+  rect.left =  m_initInfo.PicCropRect.nLeft;
+  rect.top =  m_initInfo.PicCropRect.nTop;
+  rect.width = m_initInfo.PicCropRect.nRight - m_initInfo.PicCropRect.nLeft;
+  rect.height = m_initInfo.PicCropRect.nBottom - m_initInfo.PicCropRect.nTop;
+  fmt.fmt.pix.priv = (unsigned int)&rect;
+
+  m_vpuFrameBufferNum =  m_initInfo.nMinFrameBufferCount + m_extraVpuBuffers;
+  if (m_initInfo.nInterlace)
+    fmt.fmt.pix.field = V4L2_FIELD_INTERLACED_TB;
+  else
+    fmt.fmt.pix.field = V4L2_FIELD_NONE;
+  if (!m_renderingFrames.AllocateBuffers(&fmt, m_vpuFrameBufferNum))
+  {
+    return false;
+  }
+
+  m_outputBuffers = new VpuV4LFrameBuffer[m_vpuFrameBufferNum];
+  m_vpuFrameBuffers = new VpuFrameBuffer[m_vpuFrameBufferNum];
+  m_extraMem = new VpuMemDesc[m_vpuFrameBufferNum];
+  ySize = fmt.fmt.pix.width * fmt.fmt.pix.height;
+  cSize = ySize / 4;
+  for (i = 0 ; i < m_vpuFrameBufferNum; i++)
+  {
+    m_vpuFrameBuffers[i].pbufVirtY = (unsigned char *)m_renderingFrames.GetVirtAddr(i);
+    m_vpuFrameBuffers[i].nStrideY = fmt.fmt.pix.width;
+    m_vpuFrameBuffers[i].nStrideC = m_vpuFrameBuffers[i].nStrideY / 2;
+    m_vpuFrameBuffers[i].pbufY = (unsigned char *)m_renderingFrames.GetPhyAddr(i);
+    m_vpuFrameBuffers[i].pbufCb = m_vpuFrameBuffers[i].pbufY + ySize;
+    m_vpuFrameBuffers[i].pbufCr = m_vpuFrameBuffers[i].pbufCb + cSize;
+    m_vpuFrameBuffers[i].pbufVirtCb = m_vpuFrameBuffers[i].pbufVirtY + ySize;
+    m_vpuFrameBuffers[i].pbufVirtCr = m_vpuFrameBuffers[i].pbufVirtCb + cSize;
+    /* Dont care about tile */
+    m_vpuFrameBuffers[i].pbufY_tilebot = 0;
+    m_vpuFrameBuffers[i].pbufCb_tilebot = 0;
+    m_vpuFrameBuffers[i].pbufVirtY_tilebot = 0;
+    m_vpuFrameBuffers[i].pbufVirtCb_tilebot = 0;
+    m_outputBuffers[i].clear();
+  }
+
+  /* Allocate physical extra memory */
+  for (i = 0 ; i < m_vpuFrameBufferNum; i++)
+  {
+    m_extraMem[i].nSize = cSize;
+    vpuRet = VPU_DecGetMem(&m_extraMem[i]);
+    if (vpuRet != VPU_DEC_RET_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s - Extra memory (%d bytes) allocation failure (%d).\n",
+               __FUNCTION__, m_extraMem[i].nSize , vpuRet);
+      for (j=i ; j<m_vpuFrameBufferNum; j++)
+        m_extraMem[j].nSize = 0;
+      return false;
+    }
+    m_vpuFrameBuffers[i].pbufMvCol = (unsigned char *)m_extraMem[i].nPhyAddr;
+    m_vpuFrameBuffers[i].pbufVirtMvCol = (unsigned char *)m_extraMem[i].nVirtAddr;
+  }
+
+  return true;
+}
+
+bool CDVDVideoCodecIMX::VpuPushFrame(VpuDecOutFrameInfo *frameInfo)
+{
+  #ifdef IMX_PROFILE
+  static unsigned long long previous_ts;
+  #endif
+  VpuFrameBuffer *frameBuffer = frameInfo->pDisplayFrameBuf;
+  CIMXOutputFrame *outputFrame;
+  int i;
+  double pts;
+  DVDVideoPicture DVDFrame;
+
+  // FIXME pts = (double)TSManagerSend2(m_tsm, frameBuffer) / (double)1000.0;
+  pts = (double)TSManagerSend(m_tsm) / (double)1000.0;
+  /* Find Frame given physical address */
+  i = m_renderingFrames.FindBuffer(frameBuffer->pbufY);
+  if (i == -1)
+  {
+    CLog::Log(LOGERROR, "%s - V4L buffer not found\n", __FUNCTION__);
+    return false;
+  }
+  if (m_outputBuffers[i].used())
+  {
+    CLog::Log(LOGERROR, "%s - Try to reuse buffer which was not dequeued !\n", __FUNCTION__);
+    return false;
+  }
+
+  /* Store the pointer to be able to invoke VPU_DecOutFrameDisplayed when the buffer will be dequeued */
+  m_outputBuffers[i].store(frameBuffer, m_frameCounter++);
+
+  outputFrame = &m_outputBuffers[i].outputFrame;
+  outputFrame->v4l2BufferIdx = i;
+  outputFrame->field = frameInfo->eFieldType;
+  outputFrame->picCrop = frameInfo->pExtInfo->FrmCropRect;
+  outputFrame->nQ16ShiftWidthDivHeightRatio = frameInfo->pExtInfo->nQ16ShiftWidthDivHeightRatio;
+  DVDFrame.imxOutputFrame = outputFrame;
+
+  DVDFrame.pts = pts;
+  DVDFrame.dts = DVD_NOPTS_VALUE;
+  /*
+  m_outputFrame.iWidth = frameInfo->pExtInfo->nFrmWidth;
+  m_outputFrame.iHeight  = frameInfo->pExtInfo->nFrmHeight;
+  */
+  DVDFrame.iWidth  = frameInfo->pExtInfo->FrmCropRect.nRight - frameInfo->pExtInfo->FrmCropRect.nLeft;
+  DVDFrame.iHeight = frameInfo->pExtInfo->FrmCropRect.nBottom - frameInfo->pExtInfo->FrmCropRect.nTop;
+  DVDFrame.format = RENDER_FMT_IMX;
+
+  m_decodedFrames.push(DVDFrame);
+  if (m_decodedFrames.size() > IMX_MAX_QUEUE_SIZE)
+  {
+      CLog::Log(LOGERROR, "%s - Too many enqueued decoded frames : %d (Max %d)\n", __FUNCTION__, m_decodedFrames.size(), IMX_MAX_QUEUE_SIZE);
+  }
+
+#ifdef IMX_PROFILE
+  DVDFrame.imxOutputFrame->pushTS = get_time();
+  CLog::Log(LOGDEBUG, "%s - push (%i) Time between push %llu\n",
+              __FUNCTION__,  i, DVDFrame.imxOutputFrame->pushTS - previous_ts);
+  previous_ts =DVDFrame.imxOutputFrame->pushTS;
+#endif
+
+  return true;
+}
+
+int CDVDVideoCodecIMX::GetAvailableBufferNb(void)
+{
+  int i, nb;
+
+  nb = 0;
+  for (i = 0; i < m_vpuFrameBufferNum; i++)
+  {
+    if (!m_outputBuffers[i].used())
+      nb++;
+  }
+  return nb;
+}
+
+bool CDVDVideoCodecIMX::VpuReleaseBufferV4L(int idx)
+{
+  if (idx < 0 || idx >= m_vpuFrameBufferNum)
+  {
+    CLog::Log(LOGERROR, "%s - Invalid index - idx : %d\n", __FUNCTION__, idx);
+    return false;
+  }
+
+  /*CLog::Log(LOGDEBUG, "%s - idx : %d - frame : %d\n", __FUNCTION__,
+            idx, m_outputBuffers[idx].frameNo);*/
+
+  VPU_DecOutFrameDisplayed(m_vpuHandle, m_outputBuffers[idx].buffer);
+  m_outputBuffers[idx].clear();
+  return true;
+}
+
+/* Dequeue queued frames and free the corresponding VPU buffers */
+bool CDVDVideoCodecIMX::VpuDeQueueFrame(bool wait)
+{
+  int idx, i, frameNo;
+
+  idx = m_renderingFrames.DeQueue(wait);
+  if (idx != -1)
+  {
+    if (!m_outputBuffers[idx].used())
+    {
+      CLog::Log(LOGERROR, "%s - WTF : associated buffer does not exist anymore\n",
+                __FUNCTION__);
+      return true;
+    }
+    else
+    {
+      frameNo = m_outputBuffers[idx].frameNo();
+      VpuReleaseBufferV4L(idx);
+      if (frameNo > 0)
+      {
+        /* Release buffers which are not used anymore and were
+         * queued before the idx buffer that has just been dequeued*/
+        for (i = 0; i < m_vpuFrameBufferNum; ++i)
+        {
+          if (m_outputBuffers[i].expired(frameNo))
+          {
+            CLog::Log(LOGNOTICE, "%s - Release expired buffer - idx : %d\n", __FUNCTION__, i);
+            VpuReleaseBufferV4L(i);
+          }
+        }
+      }
+      return true;
+    }
+  }
+  else
+  {
+#ifdef NO_V4L_RENDERING
+    int i;
+    for (i = 0; i < m_vpuFrameBufferNum; i++)
+    {
+      if (m_outputBuffers[i].used())
+      {
+        VpuReleaseBufferV4L(idx);
+      }
+    }
+#endif
+    return false;
+  }
+}
+
+CDVDVideoCodecIMX::CDVDVideoCodecIMX() : m_renderingFrames(CIMXRenderingFrames::GetInstance())
+{
+  m_pFormatName = "iMX-xxx";
+  memset(&m_decMemInfo, 0, sizeof(DecMemInfo));
+  m_vpuHandle = 0;
+  m_vpuFrameBuffers = NULL;
+  m_outputBuffers = NULL;
+  m_extraMem = NULL;
+  m_vpuFrameBufferNum = 0;
+  m_tsSyncRequired = true;
+  m_dropState = false;
+  m_tsm = NULL;
+  m_convert_bitstream = false;
+  m_frameCounter = 0;
+  m_usePTS = true;
+  if (getenv("IMX_NOPTS") != NULL)
+  {
+    m_usePTS = false;
+  }
+}
+
+CDVDVideoCodecIMX::~CDVDVideoCodecIMX()
+{
+  Dispose();
+}
+
+bool CDVDVideoCodecIMX::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  if (hints.software)
+  {
+    CLog::Log(LOGNOTICE, "iMX VPU : software decoding requested.\n");
+    return false;
+  }
+
+  m_hints = hints;
+  CLog::Log(LOGDEBUG, "Let's decode with iMX VPU\n");
+
+#ifdef MEDIAINFO
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: fpsrate %d / fpsscale %d\n", m_hints.fpsrate, m_hints.fpsscale);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: CodecID %d \n", m_hints.codec);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: StreamType %d \n", m_hints.type);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Level %d \n", m_hints.level);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Profile %d \n", m_hints.profile);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: PTS_invalid %d \n", m_hints.ptsinvalid);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Tag %d \n", m_hints.codec_tag);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: %dx%d \n", m_hints.width,  m_hints.height);
+  { uint8_t *pb = (uint8_t*)&m_hints.codec_tag;
+    if (isalnum(pb[0]) && isalnum(pb[1]) && isalnum(pb[2]) && isalnum(pb[3]))
+      CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Tag fourcc %c%c%c%c\n", pb[0], pb[1], pb[2], pb[3]);
+  }
+  if (m_hints.extrasize)
+  {
+    unsigned int  i;
+    char buf[4096];
+
+    for (i = 0; i < m_hints.extrasize; i++)
+      sprintf(buf+i*2, "%02x", ((uint8_t*)m_hints.extradata)[i]);
+    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: extradata %d %s\n", m_hints.extrasize, buf);
+  }
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: %d / %d \n", m_hints.width,  m_hints.height);
+  CLog::Log(LOGDEBUG, "Decode: aspect %f - forced aspect %d\n", m_hints.aspect, m_hints.forced_aspect);
+#endif
+
+  m_convert_bitstream = false;
+  switch(m_hints.codec)
+  {
+  case CODEC_ID_MPEG2VIDEO:
+  case CODEC_ID_MPEG2VIDEO_XVMC:
+    m_decOpenParam.CodecFormat = VPU_V_MPEG2;
+    m_pFormatName = "iMX-mpeg2";
+    break;
+  case CODEC_ID_H263:
+    m_decOpenParam.CodecFormat = VPU_V_H263;
+    m_pFormatName = "iMX-h263";
+    break;
+  case CODEC_ID_H264:
+    m_decOpenParam.CodecFormat = VPU_V_AVC;
+    m_pFormatName = "iMX-h264";
+    if (hints.extradata)
+    {
+    if ( *(char*)hints.extradata == 1 )
+      m_convert_bitstream = bitstream_convert_init(hints.extradata,hints.extrasize);
+    }
+    break;
+  case CODEC_ID_VC1:
+    m_decOpenParam.CodecFormat = VPU_V_VC1_AP;
+    m_pFormatName = "iMX-vc1";
+    break;
+/* FIXME TODO
+ * => for this type we have to set height, width, nChromaInterleave and nMapType
+  case CODEC_ID_MJPEG:
+    m_decOpenParam.CodecFormat = VPU_V_MJPG;
+    m_pFormatName = "iMX-mjpg";
+    break;*/
+  case CODEC_ID_CAVS:
+  case CODEC_ID_AVS:
+    m_decOpenParam.CodecFormat = VPU_V_AVS;
+    m_pFormatName = "iMX-AVS";
+    break;
+  case CODEC_ID_RV10:
+  case CODEC_ID_RV20:
+  case CODEC_ID_RV30:
+  case CODEC_ID_RV40:
+    m_decOpenParam.CodecFormat = VPU_V_RV;
+    m_pFormatName = "iMX-RV";
+    break;
+  case CODEC_ID_KMVC:
+    m_decOpenParam.CodecFormat = VPU_V_AVC_MVC;
+    m_pFormatName = "iMX-MVC";
+    break;
+  case CODEC_ID_VP8:
+    m_decOpenParam.CodecFormat = VPU_V_VP8;
+    m_pFormatName = "iMX-vp8";
+    break;
+  case CODEC_ID_MSMPEG4V3:
+    m_decOpenParam.CodecFormat = VPU_V_XVID; /* VPU_V_DIVX3 */
+    m_pFormatName = "iMX-divx3";
+    break;
+  case CODEC_ID_MPEG4:
+    switch(m_hints.codec_tag)
+    {
+    case _4CC('D','I','V','X'):
+      m_decOpenParam.CodecFormat = VPU_V_XVID; /* VPU_V_DIVX4 */
+      m_pFormatName = "iMX-divx4";
+      break;
+    case _4CC('D','X','5','0'):
+    case _4CC('D','I','V','5'):
+      m_decOpenParam.CodecFormat = VPU_V_XVID; /* VPU_V_DIVX56 */
+      m_pFormatName = "iMX-divx5";
+      break;
+    case _4CC('X','V','I','D'):
+    case _4CC('M','P','4','V'):
+    case _4CC('P','M','P','4'):
+    case _4CC('F','M','P','4'):
+      m_decOpenParam.CodecFormat = VPU_V_XVID;
+      m_pFormatName = "iMX-xvid";
+      break;
+    default:
+      CLog::Log(LOGERROR, "iMX VPU : MPEG4 codec tag %d is not (yet) handled.\n", m_hints.codec_tag);
+      return false;
+    }
+    break;
+  default:
+    CLog::Log(LOGERROR, "iMX VPU : codecid %d is not (yet) handled.\n", m_hints.codec);
+    return false;
+  }
+
+  return true;
+}
+
+void CDVDVideoCodecIMX::Dispose(void)
+{
+  VpuDecRetCode  ret;
+  int i;
+  bool VPU_loaded = m_vpuHandle;
+
+  FlushDecodedFrames();
+  if (m_vpuHandle)
+  {
+    ret = VPU_DecFlushAll(m_vpuHandle);
+    if (ret != VPU_DEC_RET_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s - VPU flush failed with error code %d.\n", __FUNCTION__, ret);
+    }
+    ret = VPU_DecClose(m_vpuHandle);
+    if (ret != VPU_DEC_RET_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s - VPU close failed with error code %d.\n", __FUNCTION__, ret);
+    }
+    m_vpuHandle = 0;
+  }
+
+  VpuFreeBuffers();
+
+  if (m_outputBuffers != NULL)
+  {
+    while (VpuDeQueueFrame(false));
+    m_renderingFrames.ReleaseBuffers();
+    RestoreFB();
+    delete m_outputBuffers;
+    m_outputBuffers = NULL;
+  }
+
+  /* Free extramem */
+  if (m_extraMem != NULL)
+  {
+    for (i = 0; i < m_vpuFrameBufferNum; i++)
+    {
+      if (m_extraMem[i].nSize > 0)
+      {
+        ret = VPU_DecFreeMem(&m_extraMem[i]);
+        if (ret != VPU_DEC_RET_SUCCESS)
+        {
+          CLog::Log(LOGERROR, "%s - Release extra mem failed with error code %d.\n", __FUNCTION__, ret);
+        }
+        m_extraMem[i].nSize = 0;
+      }
+    }
+    delete m_extraMem;
+    m_extraMem = NULL;
+  }
+  m_vpuFrameBufferNum = 0;
+
+  if (m_vpuFrameBuffers != NULL)
+  {
+    delete m_vpuFrameBuffers;
+    m_vpuFrameBuffers = NULL;
+  }
+
+  if (VPU_loaded)
+  {
+    ret = VPU_DecUnLoad();
+    if (ret != VPU_DEC_RET_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s - VPU unload failed with error code %d.\n", __FUNCTION__, ret);
+    }
+  }
+
+  if (m_tsm != NULL)
+  {
+    destroyTSManager(m_tsm);
+    m_tsm = NULL;
+  }
+
+  if (m_convert_bitstream)
+  {
+    if (m_sps_pps_context.sps_pps_data)
+    {
+      free(m_sps_pps_context.sps_pps_data);
+      m_sps_pps_context.sps_pps_data = NULL;
+    }
+  }
+  return;
+}
+
+int CDVDVideoCodecIMX::Decode(BYTE *pData, int iSize, double dts, double pts)
+{
+  VpuDecFrameLengthInfo frameLengthInfo;
+  VpuBufferNode inData;
+  VpuDecRetCode  ret;
+  VpuDecOutFrameInfo frameInfo;
+  int decRet = 0;
+  int retStatus = 0;
+  int demuxer_bytes = iSize;
+  uint8_t *demuxer_content = pData;
+  bool bitstream_convered  = false;
+  bool retry = false;
+  bool frameConsumed = false;
+
+#ifdef IMX_PROFILE
+  static unsigned long long previous, current;
+  unsigned long long before_dec;
+#endif
+
+  if (!m_vpuHandle)
+  {
+    VpuOpen();
+    if (!m_vpuHandle)
+      return VC_ERROR;
+  }
+
+#ifdef IMX_PROFILE
+  current = get_time();
+  CLog::Log(LOGDEBUG, "%s - delta time decode : %llu - demux size : %d  dts : %f - pts : %f\n", __FUNCTION__, current - previous, iSize, dts, pts);
+  previous = current;
+#endif
+
+/* FIXME tests
+  CLog::Log(LOGDEBUG, "%s - demux size : %d  dts : %f - pts : %f - %x %x %x %x\n", __FUNCTION__, iSize, dts, pts, ((unsigned int *)pData)[0], ((unsigned int *)pData)[1], ((unsigned int *)pData)[2], ((unsigned int *)pData)[3]);
+  ((unsigned int *)pData)[0] = htonl(iSize-4);
+*/
+
+  while (VpuDeQueueFrame(false));
+
+  if (pData && iSize)
+  {
+    if (m_convert_bitstream)
+    {
+      // convert demuxer packet from bitstream to bytestream (AnnexB)
+      int bytestream_size = 0;
+      uint8_t *bytestream_buff = NULL;
+
+      if (!bitstream_convert(demuxer_content, demuxer_bytes, &bytestream_buff, &bytestream_size))
+      {
+        CLog::Log(LOGERROR, "%s - bitstream convert error...\n", __FUNCTION__);
+        return  VC_ERROR;
+      }
+
+      if (bytestream_buff && (bytestream_size > 0))
+      {
+        bitstream_convered = true;
+        demuxer_bytes = bytestream_size;
+        demuxer_content = bytestream_buff;
+      }
+    }
+
+    inData.nSize = demuxer_bytes;
+    inData.pPhyAddr = NULL;
+    inData.pVirAddr = demuxer_content;
+    /* FIXME TODO VP8 & DivX3 require specific sCodecData values */
+    if ((m_decOpenParam.CodecFormat == VPU_V_MPEG2) ||
+        (m_decOpenParam.CodecFormat == VPU_V_VC1_AP)||
+        (m_decOpenParam.CodecFormat == VPU_V_XVID))
+    {
+      inData.sCodecData.pData = (unsigned char *)m_hints.extradata;
+      inData.sCodecData.nSize = m_hints.extrasize;
+    }
+    else
+    {
+      inData.sCodecData.pData = NULL;
+      inData.sCodecData.nSize = 0;
+    }
+
+    do // Decode as long as the VPU consumes data
+    {
+      retry = false;
+#ifdef IMX_PROFILE
+      before_dec = get_time();
+#endif
+      ret = VPU_DecDecodeBuf(m_vpuHandle, &inData, &decRet);
+#ifdef IMX_PROFILE
+        CLog::Log(LOGDEBUG, "%s - VPU dec 0x%x decode takes : %lld\n\n", __FUNCTION__, decRet,  get_time() - before_dec);
+#endif
+
+      if (ret != VPU_DEC_RET_SUCCESS)
+      {
+        CLog::Log(LOGERROR, "%s - VPU decode failed with error code %d.\n", __FUNCTION__, ret);
+        goto out_error;
+      }
+
+      if (decRet & VPU_DEC_INIT_OK)
+      /* VPU decoding init OK : We can retrieve stream info */
+      {
+        ret = VPU_DecGetInitialInfo(m_vpuHandle, &m_initInfo);
+        if (ret == VPU_DEC_RET_SUCCESS)
+        {
+          CLog::Log(LOGDEBUG, "%s - VPU Init Stream Info : %dx%d (interlaced : %d - Minframe : %d)"\
+                    " - Align : %d bytes - crop : %d %d %d %d - Q16Ratio : %x\n", __FUNCTION__,
+            m_initInfo.nPicWidth, m_initInfo.nPicHeight, m_initInfo.nInterlace, m_initInfo.nMinFrameBufferCount,
+            m_initInfo.nAddressAlignment, m_initInfo.PicCropRect.nLeft, m_initInfo.PicCropRect.nTop,
+            m_initInfo.PicCropRect.nRight, m_initInfo.PicCropRect.nBottom, m_initInfo.nQ16ShiftWidthDivHeightRatio);
+          if (VpuAllocFrameBuffers())
+          {
+            ret = VPU_DecRegisterFrameBuffer(m_vpuHandle, m_vpuFrameBuffers, m_vpuFrameBufferNum);
+            if (ret != VPU_DEC_RET_SUCCESS)
+            {
+              CLog::Log(LOGERROR, "%s - VPU error while registering frame buffers (%d).\n", __FUNCTION__, ret);
+              goto out_error;
+            }
+          }
+          else
+          {
+            goto out_error;
+          }
+        }
+        else
+        {
+          CLog::Log(LOGERROR, "%s - VPU get initial info failed (%d).\n", __FUNCTION__, ret);
+          goto out_error;
+        }
+      }//VPU_DEC_INIT_OK
+
+      if (decRet & VPU_DEC_ONE_FRM_CONSUMED)
+      {
+        ret = VPU_DecGetConsumedFrameInfo(m_vpuHandle, &frameLengthInfo);
+        if (ret != VPU_DEC_RET_SUCCESS)
+        {
+          CLog::Log(LOGERROR, "%s - VPU error retireving info about consummed frame (%d).\n", __FUNCTION__, ret);
+        }
+        frameConsumed = true;
+        // FIXME TSManagerValid2(m_tsm, frameLengthInfo.nFrameLength + frameLengthInfo.nStuffLength, frameLengthInfo.pFrame);
+        //CLog::Log(LOGDEBUG, "%s - size : %d - key consummed : %x\n",  __FUNCTION__, frameLengthInfo.nFrameLength + frameLengthInfo.nStuffLength, frameLengthInfo.pFrame);
+      }//VPU_DEC_ONE_FRM_CONSUMED
+
+      if ((decRet & VPU_DEC_OUTPUT_DIS) ||
+          (decRet & VPU_DEC_OUTPUT_MOSAIC_DIS))
+      /* Frame ready to be displayed */
+      {
+        if (retStatus & VC_PICTURE)
+            CLog::Log(LOGERROR, "%s - Second picture in the same decode call !\n", __FUNCTION__);
+
+        ret = VPU_DecGetOutputFrame(m_vpuHandle, &frameInfo);
+        if(ret != VPU_DEC_RET_SUCCESS)
+        {
+          CLog::Log(LOGERROR, "%s - VPU Cannot get output frame(%d).\n", __FUNCTION__, ret);
+          goto out_error;
+        }
+        if (VpuPushFrame(&frameInfo))
+        {
+          retStatus |= VC_PICTURE;
+        }
+      } //VPU_DEC_OUTPUT_DIS
+
+      if (decRet & VPU_DEC_OUTPUT_REPEAT)
+      {
+        TSManagerSend(m_tsm);
+        CLog::Log(LOGDEBUG, "%s - Frame repeat.\n", __FUNCTION__);
+      }
+      if (decRet & VPU_DEC_OUTPUT_DROPPED)
+      {
+        TSManagerSend(m_tsm);
+        CLog::Log(LOGDEBUG, "%s - Frame dropped.\n", __FUNCTION__);
+      }
+      if (decRet & VPU_DEC_NO_ENOUGH_BUF)
+      {
+          CLog::Log(LOGERROR, "%s - No frame buffer available.\n", __FUNCTION__);
+      }
+      if (decRet & VPU_DEC_SKIP)
+      {
+        TSManagerSend(m_tsm);
+        CLog::Log(LOGDEBUG, "%s - Frame skipped.\n", __FUNCTION__);
+      }
+      if (decRet & VPU_DEC_FLUSH)
+      {
+        CLog::Log(LOGNOTICE, "%s - VPU requires a flush.\n", __FUNCTION__);
+        ret = VPU_DecFlushAll(m_vpuHandle);
+        if (ret != VPU_DEC_RET_SUCCESS)
+        {
+          CLog::Log(LOGERROR, "%s - VPU flush failed(%d).\n", __FUNCTION__, ret);
+        }
+        retStatus = VC_FLUSHED;
+      }
+      if (decRet & VPU_DEC_OUTPUT_EOS)
+      {
+        CLog::Log(LOGNOTICE, "%s - EOS encountered.\n", __FUNCTION__);
+      }
+      if (decRet & VPU_DEC_NO_ENOUGH_INBUF)
+      {
+        // We are done with VPU decoder that time
+        break;
+      }
+      if (!(decRet & VPU_DEC_INPUT_USED))
+      {
+        CLog::Log(LOGERROR, "%s - input not used : addr %p  size :%d!\n", __FUNCTION__, inData.pVirAddr, inData.nSize);
+        TSManagerSend(m_tsm);
+      }
+
+
+      if (!(decRet & VPU_DEC_OUTPUT_DIS)  &&
+           (inData.nSize != 0))
+      {
+        /* Let's process again as VPU_DEC_NO_ENOUGH_INBUF was not set
+         * and we don't have an image ready if we reach that point
+         */
+        inData.pVirAddr = NULL;
+        inData.nSize = 0;
+        retry = true;
+      }
+
+    } while (retry == true);
+
+    /* Push ts only if a frame was consumed by the VPU
+     * as it will produce an output in future for sure */
+    if (frameConsumed)
+    {
+      if (pts != DVD_NOPTS_VALUE)
+      {
+        if (m_tsSyncRequired)
+        {
+          m_tsSyncRequired = false;
+          resyncTSManager(m_tsm, llrint(pts) * 1000, MODE_AI);
+        }
+        //TSManagerReceive2(m_tsm, llrint(pts) * 1000, iSize);
+        TSManagerReceive(m_tsm, llrint(pts) * 1000);
+      }
+      else
+      {
+        //If no pts but dts available (AVI container for instance) then use this one
+        if (dts !=  DVD_NOPTS_VALUE)
+        {
+          if (m_tsSyncRequired)
+          {
+            m_tsSyncRequired = false;
+            resyncTSManager(m_tsm, llrint(dts) * 1000, MODE_AI);
+          }
+          //TSManagerReceive2(m_tsm, llrint(dts) * 1000, iSize);
+          TSManagerReceive(m_tsm, llrint(dts) * 1000);
+        }
+      }
+    }
+
+  } //(pData && iSize)
+
+  if (GetAvailableBufferNb() >  (m_vpuFrameBufferNum - m_extraVpuBuffers))
+  {
+    retStatus |= VC_BUFFER;
+  }
+  else
+  {
+    if (retStatus == 0) {
+      /* No Picture ready and Not enough VPU buffers. It should NOT happen so log dedicated error */
+      CLog::Log(LOGERROR, "%s - Not hw buffer available. Waiting for 2ms\n", __FUNCTION__);
+      /* Lets wait for the IPU to free a buffer. Anyway we have several decoded frames ready */
+      usleep(2000);
+    }
+  }
+
+  if (bitstream_convered)
+      free(demuxer_content);
+
+  retStatus &= (~VC_PICTURE);
+  if (m_decodedFrames.size() >= IMX_MAX_QUEUE_SIZE)
+    retStatus |= VC_PICTURE;
+
+#ifdef IMX_PROFILE
+  CLog::Log(LOGDEBUG, "%s - returns %x - duration %lld\n", __FUNCTION__, retStatus, get_time() - previous);
+#endif
+  return retStatus;
+
+out_error:
+  if (bitstream_convered)
+    free(demuxer_content);
+  return VC_ERROR;
+}
+
+void CDVDVideoCodecIMX::Reset()
+{
+  int ret;
+
+  CLog::Log(LOGDEBUG, "%s - called\n", __FUNCTION__);
+
+  /* We have to resync timestamp manager */
+  m_tsSyncRequired = true;
+
+  /* Flush decoded frames */
+  FlushDecodedFrames();
+
+  /* Flush VPU */
+  ret = VPU_DecFlushAll(m_vpuHandle);
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s - VPU flush failed with error code %d.\n", __FUNCTION__, ret);
+  }
+
+}
+
+unsigned CDVDVideoCodecIMX::GetAllowedReferences()
+{
+  // Note : It is useless if CLinuxRendererGLES::GetProcessorSize returns 0 for RENDER_FMT_IMX
+  return min(3, m_extraVpuBuffers / 2);
+}
+
+
+bool CDVDVideoCodecIMX::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  double currentPlayerPts;
+  double ts = DVD_NOPTS_VALUE;
+  DVDVideoPicture DVDFrame;
+
+  if (m_decodedFrames.size() == 0)
+  {
+    CLog::Log(LOGERROR, "%s called while no picture ready\n", __FUNCTION__);
+    return false;
+  }
+
+  /* Retrieve oldest decoded frame */
+  DVDFrame = m_decodedFrames.front();
+  m_decodedFrames.pop();
+  //CLog::Log(LOGNOTICE, "%s - buffer(%d)\n", __FUNCTION__, DVDFrame.imxOutputFrame->v4l2BufferIdx);
+
+  pDvdVideoPicture->iFlags &= DVP_FLAG_DROPPED;
+  if ((pDvdVideoPicture->iFlags != 0) || (m_dropState))
+  {
+    CLog::Log(LOGNOTICE, "%s - Flushing video picture\n", __FUNCTION__);
+    pDvdVideoPicture->iFlags = DVP_FLAG_DROPPED;
+    VpuReleaseBufferV4L(DVDFrame.imxOutputFrame->v4l2BufferIdx);
+    DVDFrame.imxOutputFrame = NULL;
+  }
+  else
+  {
+    ts = DVDFrame.pts;
+    currentPlayerPts = GetPlayerPtsSeconds() * (double)DVD_TIME_BASE;
+    if (currentPlayerPts > ts)
+    {
+        CLog::Log(LOGERROR, "%s - player is ahead of time (%f)\n", __FUNCTION__, currentPlayerPts - ts);
+    }
+    //CLog::Log(LOGINFO, "%s - idx : %d - delta call %f - delta ts %f \n", __FUNCTION__, outputFrame.v4l2_buffer->index,ts - previous, ts - currentPlayerPts);
+  }
+
+#ifdef NO_V4L_RENDERING
+  if (!m_dropState)
+  {
+    VpuReleaseBufferV4L(DVDFrame.imxOutputFrame->v4l2BufferIdx);
+  }
+#endif
+
+  pDvdVideoPicture->pts = DVDFrame.pts;
+  if (!m_usePTS)
+  {
+    pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
+  }
+  pDvdVideoPicture->dts = DVDFrame.dts;
+  pDvdVideoPicture->iWidth = DVDFrame.iWidth;
+  pDvdVideoPicture->iHeight = DVDFrame.iHeight;
+  if (m_dropState)
+  {
+    pDvdVideoPicture->iDisplayWidth = DVDFrame.iWidth;
+    pDvdVideoPicture->iDisplayHeight = DVDFrame.iHeight;
+  }
+  else
+  {
+    pDvdVideoPicture->iDisplayWidth = ((pDvdVideoPicture->iWidth * DVDFrame.imxOutputFrame->nQ16ShiftWidthDivHeightRatio) + 32767) >> 16;
+    pDvdVideoPicture->iDisplayHeight = pDvdVideoPicture->iHeight;
+  }
+  pDvdVideoPicture->format = DVDFrame.format;
+  pDvdVideoPicture->imxOutputFrame = DVDFrame.imxOutputFrame;
+
+#ifdef V4L_OUTPUT_PROFILE
+  CLog::Log(LOGDEBUG, "%s - QF : %d  -  HWfre : %d/%d/%d\n",
+            (int)m_decodedFrames.size(), GetAvailableBufferNb(),
+            m_extraVpuBuffers, m_vpuFrameBufferNum);
+#endif
+  return true;
+}
+
+void CDVDVideoCodecIMX::SetDropState(bool bDrop)
+{
+
+  /* We are fast enough to continue to really decode every frames
+   * and avoid artefacts...
+   * (Of course these frames won't be rendered but only decoded !)
+   */
+  if (m_dropState != bDrop)
+  {
+    m_dropState = bDrop;
+    CLog::Log(LOGNOTICE, "%s : %d\n", __FUNCTION__, bDrop);
+  }
+}
+
+/* bitstream convert : Shameless copy from openmax */
+/* TODO : Have a look at it as  the malloc/copy/free strategy is obviously not the most efficient one */
+
+bool CDVDVideoCodecIMX::bitstream_convert_init(void *in_extradata, int in_extrasize)
+{
+  // based on h264_mp4toannexb_bsf.c (ffmpeg)
+  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
+  // and Licensed GPL 2.1 or greater
+
+  m_sps_pps_size = 0;
+  m_sps_pps_context.sps_pps_data = NULL;
+
+  // nothing to filter
+  if (!in_extradata || in_extrasize < 6)
+    return false;
+
+  uint16_t unit_size;
+  uint32_t total_size = 0;
+  uint8_t *out = NULL, unit_nb, sps_done = 0;
+  const uint8_t *extradata = (uint8_t*)in_extradata + 4;
+  static const uint8_t nalu_header[4] = {0, 0, 0, 1};
+
+  // retrieve length coded size
+  m_sps_pps_context.length_size = (*extradata++ & 0x3) + 1;
+  if (m_sps_pps_context.length_size == 3)
+    return false;
+
+  // retrieve sps and pps unit(s)
+  unit_nb = *extradata++ & 0x1f;  // number of sps unit(s)
+  if (!unit_nb)
+  {
+    unit_nb = *extradata++;       // number of pps unit(s)
+    sps_done++;
+  }
+  while (unit_nb--)
+  {
+    unit_size = extradata[0] << 8 | extradata[1];
+    total_size += unit_size + 4;
+    if ( (extradata + 2 + unit_size) > ((uint8_t*)in_extradata + in_extrasize) )
+    {
+      free(out);
+      return false;
+    }
+    uint8_t* new_out = (uint8_t*)realloc(out, total_size);
+    if (new_out)
+    {
+      out = new_out;
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "bitstream_convert_init failed - %s : could not realloc the buffer out",  __FUNCTION__);
+      free(out);
+      return false;
+    }
+
+    memcpy(out + total_size - unit_size - 4, nalu_header, 4);
+    memcpy(out + total_size - unit_size, extradata + 2, unit_size);
+    extradata += 2 + unit_size;
+
+    if (!unit_nb && !sps_done++)
+      unit_nb = *extradata++;     // number of pps unit(s)
+  }
+
+  m_sps_pps_context.sps_pps_data = out;
+  m_sps_pps_context.size = total_size;
+  m_sps_pps_context.first_idr = 1;
+
+  return true;
+}
+
+bool CDVDVideoCodecIMX::bitstream_convert(BYTE* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
+{
+  // based on h264_mp4toannexb_bsf.c (ffmpeg)
+  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
+  // and Licensed GPL 2.1 or greater
+
+  uint8_t *buf = pData;
+  uint32_t buf_size = iSize;
+  uint8_t  unit_type;
+  int32_t  nal_size;
+  uint32_t cumul_size = 0;
+  const uint8_t *buf_end = buf + buf_size;
+
+  do
+  {
+    if (buf + m_sps_pps_context.length_size > buf_end)
+      goto fail;
+
+    if (m_sps_pps_context.length_size == 1)
+      nal_size = buf[0];
+    else if (m_sps_pps_context.length_size == 2)
+      nal_size = buf[0] << 8 | buf[1];
+    else
+      nal_size = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];
+
+    // FIXME CLog::Log(LOGERROR, "%s - nal_size : %d \n", __FUNCTION__, nal_size);
+    buf += m_sps_pps_context.length_size;
+    unit_type = *buf & 0x1f;
+
+    if (buf + nal_size > buf_end || nal_size < 0)
+      goto fail;
+
+    // prepend only to the first type 5 NAL unit of an IDR picture
+    if (m_sps_pps_context.first_idr && unit_type == 5)
+    {
+      bitstream_alloc_and_copy(poutbuf, poutbuf_size,
+        m_sps_pps_context.sps_pps_data, m_sps_pps_context.size, buf, nal_size);
+      m_sps_pps_context.first_idr = 0;
+    }
+    else
+    {
+      bitstream_alloc_and_copy(poutbuf, poutbuf_size, NULL, 0, buf, nal_size);
+      if (!m_sps_pps_context.first_idr && unit_type == 1)
+          m_sps_pps_context.first_idr = 1;
+    }
+
+    buf += nal_size;
+    cumul_size += nal_size + m_sps_pps_context.length_size;
+  } while (cumul_size < buf_size);
+
+  return true;
+
+fail:
+  free(*poutbuf);
+  *poutbuf = NULL;
+  *poutbuf_size = 0;
+  return false;
+}
+
+void CDVDVideoCodecIMX::bitstream_alloc_and_copy(
+  uint8_t **poutbuf,      int *poutbuf_size,
+  const uint8_t *sps_pps, uint32_t sps_pps_size,
+  const uint8_t *in,      uint32_t in_size)
+{
+  // based on h264_mp4toannexb_bsf.c (ffmpeg)
+  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
+  // and Licensed GPL 2.1 or greater
+
+  #define CHD_WB32(p, d) { \
+    ((uint8_t*)(p))[3] = (d); \
+    ((uint8_t*)(p))[2] = (d) >> 8; \
+    ((uint8_t*)(p))[1] = (d) >> 16; \
+    ((uint8_t*)(p))[0] = (d) >> 24; }
+
+  uint32_t offset = *poutbuf_size;
+  uint8_t nal_header_size = offset ? 3 : 4;
+
+  *poutbuf_size += sps_pps_size + in_size + nal_header_size;
+  *poutbuf = (uint8_t*)realloc(*poutbuf, *poutbuf_size);
+  if (sps_pps)
+    memcpy(*poutbuf + offset, sps_pps, sps_pps_size);
+
+  memcpy(*poutbuf + sps_pps_size + nal_header_size + offset, in, in_size);
+  if (!offset)
+  {
+    CHD_WB32(*poutbuf + sps_pps_size, 1);
+  }
+  else
+  {
+    (*poutbuf + offset + sps_pps_size)[0] = 0;
+    (*poutbuf + offset + sps_pps_size)[1] = 0;
+    (*poutbuf + offset + sps_pps_size)[2] = 1;
+  }
+}
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h	2014-02-09 01:40:25.878083282 +0100
@@ -0,0 +1,191 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <queue>
+#include <linux/videodev2.h>
+#include <imx-mm/vpu/vpu_wrapper.h>
+#include "DVDVideoCodec.h"
+#include "DVDStreamInfo.h"
+#include "threads/CriticalSection.h"
+
+
+//#define IMX_PROFILE
+
+/* FIXME TODO Develop real proper CVPUBuffer class */
+#define VPU_DEC_MAX_NUM_MEM_NUM 20
+typedef struct
+{
+  //virtual mem info
+  int nVirtNum;
+  unsigned int virtMem[VPU_DEC_MAX_NUM_MEM_NUM];
+
+  //phy mem info
+  int nPhyNum;
+  unsigned int phyMem_virtAddr[VPU_DEC_MAX_NUM_MEM_NUM];
+  unsigned int phyMem_phyAddr[VPU_DEC_MAX_NUM_MEM_NUM];
+  unsigned int phyMem_cpuAddr[VPU_DEC_MAX_NUM_MEM_NUM];
+  unsigned int phyMem_size[VPU_DEC_MAX_NUM_MEM_NUM];
+} DecMemInfo;
+
+/* Output frame properties */
+struct CIMXOutputFrame {
+  // Render a picture. Calls RenderingFrames.Queue
+  void Render(struct v4l2_crop &);
+  // Clear a picture by settings the frameNo to "expired"
+  void Release() { frameNo = 0; }
+
+  int v4l2BufferIdx;
+  VpuFieldType field;
+  VpuRect picCrop;
+  unsigned int nQ16ShiftWidthDivHeightRatio;
+  int frameNo;
+#ifdef IMX_PROFILE
+  unsigned long long pushTS;
+#endif
+};
+
+class CIMXRenderingFrames
+{
+public:
+  static CIMXRenderingFrames& GetInstance();
+  bool AllocateBuffers(const struct v4l2_format *, int);
+  void *GetVirtAddr(int idx);
+  void *GetPhyAddr(int idx);
+  void ReleaseBuffers();
+  int  FindBuffer(void *);
+  int  DeQueue(bool wait);
+  void Queue(CIMXOutputFrame *, struct v4l2_crop &);
+
+private:
+  CIMXRenderingFrames();
+  void __ReleaseBuffers();
+
+  static const char  *m_v4lDeviceName;     // V4L2 device Name
+  static CIMXRenderingFrames* m_instance;  // Unique instance of the class
+
+  CCriticalSection    m_renderingFramesLock; // Lock to ensure multithreading safety for class fields
+  bool                m_ready;             // Buffers are allocated and frames can be Queued/Dequeue
+  int                 m_v4lfd;             // fd on V4L2 device
+  struct v4l2_buffer *m_v4lBuffers;        // Table of V4L buffer info (as returned by VIDIOC_QUERYBUF)
+  int                 m_bufferNum;         // Number of allocated V4L2 buffers
+  struct v4l2_crop    m_crop;              // Current cropping properties
+  bool                m_streamOn;          // Flag that indicates whether streaming in on (from V4L point of view)
+  int                 m_pushedFrames;      // Number of frames queued in V4L2
+  void              **m_virtAddr;          // Table holding virtual adresses of mmaped V4L2 buffers
+  int                 m_motionCtrl;        // Current motion control algo
+};
+
+class CDVDVideoCodecIMX : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecIMX();
+  virtual ~CDVDVideoCodecIMX();
+
+  // Methods from CDVDVideoCodec which require overrides
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose(void);
+  virtual int  Decode(BYTE *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+  virtual unsigned GetAllowedReferences();
+
+protected:
+
+  bool VpuOpen(void);
+  bool VpuAllocBuffers(VpuMemInfo *);
+  bool VpuFreeBuffers(void);
+  bool VpuAllocFrameBuffers(void);
+  bool VpuPushFrame(VpuDecOutFrameInfo*);
+  bool VpuDeQueueFrame(bool);
+  int GetAvailableBufferNb(void);
+  void InitFB(void);
+  void RestoreFB(void);
+  void FlushDecodedFrames(void);
+  bool VpuReleaseBufferV4L(int);
+
+  /* Helper structure which holds a queued output frame
+   * and its associated decoder frame buffer.*/
+  struct VpuV4LFrameBuffer
+  {
+    // Returns whether the buffer is currently used (associated)
+    bool used() const { return buffer != NULL; }
+    int frameNo() const { return outputFrame.frameNo; }
+    bool expired(int frameNo) const
+    { return (buffer != NULL) && (outputFrame.frameNo < frameNo); }
+    // Associate a VPU frame buffer
+    void store(VpuFrameBuffer *b, int frameNo) {
+      buffer = b;
+      outputFrame.frameNo = frameNo;
+    }
+    // Reset the state
+    void clear() { store(NULL, 0); }
+
+    VpuFrameBuffer *buffer;
+    CIMXOutputFrame outputFrame;
+  };
+
+  static const int    m_extraVpuBuffers;   // Number of additional buffers for VPU
+
+  CIMXRenderingFrames&m_renderingFrames;   // The global RenderingFrames instance
+  CDVDStreamInfo      m_hints;             // Hints from demuxer at stream opening
+  const char         *m_pFormatName;       // Current decoder format name
+  VpuDecOpenParam     m_decOpenParam;      // Parameters required to call VPU_DecOpen
+  DecMemInfo          m_decMemInfo;        // VPU dedicated memory description
+  VpuDecHandle        m_vpuHandle;         // Handle for VPU library calls
+  VpuDecInitInfo      m_initInfo;          // Initial info returned from VPU at decoding start
+  void               *m_tsm;               // fsl Timestamp manager (from gstreamer implementation)
+  bool                m_tsSyncRequired;    // state whether timestamp manager has to be sync'ed
+  bool                m_dropState;         // Current drop state
+  int                 m_vpuFrameBufferNum; // Total number of allocated frame buffers
+  VpuFrameBuffer     *m_vpuFrameBuffers;   // Table of VPU frame buffers description
+  VpuMemDesc         *m_extraMem;          // Table of allocated extra Memory
+  VpuV4LFrameBuffer  *m_outputBuffers;     // Table of V4L buffers out of VPU (index is V4L buf index) (used to call properly VPU_DecOutFrameDisplayed)
+  std::queue <DVDVideoPicture> m_decodedFrames;   // Decoded Frames ready to be retrieved by GetPicture
+  int                 m_frameCounter;      // Decoded frames counter
+  bool                m_usePTS;            // State whether pts out of decoding process should be used
+
+  /* FIXME : Rework is still required for fields below this line */
+
+  /* create a real class and share with openmax ? */
+  // bitstream to bytestream (Annex B) conversion support.
+  bool bitstream_convert_init(void *in_extradata, int in_extrasize);
+  bool bitstream_convert(BYTE* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size);
+  static void bitstream_alloc_and_copy( uint8_t **poutbuf, int *poutbuf_size,
+  const uint8_t *sps_pps, uint32_t sps_pps_size, const uint8_t *in, uint32_t in_size);
+  typedef struct omx_bitstream_ctx {
+      uint8_t  length_size;
+      uint8_t  first_idr;
+      uint8_t *sps_pps_data;
+      uint32_t size;
+      omx_bitstream_ctx()
+      {
+        length_size = 0;
+        first_idr = 0;
+        sps_pps_data = NULL;
+        size = 0;
+      }
+  } omx_bitstream_ctx;
+  uint32_t          m_sps_pps_size;
+  omx_bitstream_ctx m_sps_pps_context;
+  bool m_convert_bitstream;
+
+};
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in	2014-02-09 01:41:14.966138502 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in	2014-02-09 01:40:25.810083206 +0100
@@ -23,6 +23,22 @@
 SRCS += OpenMaxVideo.cpp
 SRCS += DVDVideoCodecOpenMax.cpp
 endif
+ifeq (@USE_IMXVPU@,1)
+SRCS += DVDVideoCodecIMX.cpp mfw_gst_ts.c
+endif
+
+ifeq (@USE_LIBSTAGEFRIGHT@,1)
+SRCS += StageFrightVideo.cpp
+SRCS += StageFrightVideoPrivate.cpp
+SRCS += DVDVideoCodecStageFright.cpp
+INCLUDES += -I${prefix}/opt/android-source/frameworks/base/include
+INCLUDES += -I${prefix}/opt/android-source/frameworks/base/native/include
+INCLUDES += -I${prefix}/opt/android-source/frameworks/base/include/media/stagefright
+INCLUDES += -I${prefix}/opt/android-source/frameworks/base/include/media/stagefright/openmax
+INCLUDES += -I${prefix}/opt/android-source/system/core/include
+INCLUDES += -I${prefix}/opt/android-source/libhardware/include
+endif
+
 ifeq (@USE_LIBAMCODEC@,1)
 SRCS += AMLCodec.cpp
 SRCS += DVDVideoCodecAmlogic.cpp
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/mfw_gst_ts.c xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/mfw_gst_ts.c
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/mfw_gst_ts.c	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/mfw_gst_ts.c	2014-02-09 01:40:25.855083256 +0100
@@ -0,0 +1,752 @@
+/*
+ * Copyright (c) 2010-2012, Freescale Semiconductor, Inc. All rights reserved.
+ *
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Module Name:    TimeStamp.c
+ *
+ * Description:    include TimeStamp stratege for VPU / SW video decoder plugin
+ *
+ * Portability:    This code is written for Linux OS and Gstreamer
+ */
+
+/*
+ * Changelog:
+  11/2/2010        draft version       Lyon Wang
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "mfw_gst_ts.h"
+
+
+const char *debug_env = "ME_DEBUG";
+char *debug = NULL;
+int debug_level = 0;
+
+
+enum
+{
+  DEBUG_LEVEL_ERROR = 1,
+  DEBUG_LEVEL_WARNING,
+  DEBUG_LEVEL_LOG,
+  DEBUG_LEVEL_VERBOSE,
+};
+
+
+#define TSM_MESSAGE(level, fmt, ...)\
+  do{\
+    if (debug_level>=(level)){\
+      printf("TSM:"fmt, ##__VA_ARGS__);\
+    }\
+  }while(0)
+
+#define TSM_ERROR(...) TSM_MESSAGE(DEBUG_LEVEL_ERROR, ##__VA_ARGS__)
+#define TSM_WARNING(...) TSM_MESSAGE(DEBUG_LEVEL_WARNING, ##__VA_ARGS__)
+#define TSM_LOG(...) TSM_MESSAGE(DEBUG_LEVEL_LOG, ##__VA_ARGS__)
+#define TSM_VERBOSE(...) TSM_MESSAGE(DEBUG_LEVEL_VERBOSE, ##__VA_ARGS__)
+
+#define TSM_HISTORY_POWER 5
+#define TSM_HISTORY_SIZE (1<<TSM_HISTORY_POWER)
+#define TSM_ADAPTIVE_INTERVAL(tsm) \
+    (tsm->dur_history_total>>TSM_HISTORY_POWER)
+
+#define TSM_SECOND ((TSM_TIMESTAMP)1000000000)
+#define TSM_DEFAULT_INTERVAL (TSM_SECOND/30)
+#define TSM_DEFAULT_TS_BUFFER_SIZE (128)
+
+#define TSM_TS_IS_VALID(ts)	\
+    ((ts) != TSM_TIMESTAMP_NONE)
+
+#define TSM_KEY_IS_VALID(key) \
+    ((key) != TSM_KEY_NONE)
+
+#define TSM_DISTANCE(tsm)\
+    (((tsm->rx)>=(tsm->tx))?((tsm->rx)-(tsm->tx)):(tsm->ts_buf_size-(tsm->tx)+(tsm->rx)))
+
+#define TSM_PLUS_AGE(tsm)\
+    (TSM_DISTANCE(tsm)+tsm->invalid_ts_count+2)
+
+#define TSM_ABS(ts0, ts1)\
+    (((ts0)>(ts1))?((ts0)-(ts1)):((ts1)-(ts0)))
+
+#define TSM_TIME_FORMAT "u:%02u:%02u.%09u"
+
+#define TSM_TIME_ARGS(t) \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) (((TSM_TIMESTAMP)(t)) / (TSM_SECOND * 60 * 60)) : 99, \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) ((((TSM_TIMESTAMP)(t)) / (TSM_SECOND * 60)) % 60) : 99, \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) ((((TSM_TIMESTAMP)(t)) / TSM_SECOND) % 60) : 99, \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) (((TSM_TIMESTAMP)(t)) % TSM_SECOND) : 999999999
+
+#define TSM_BUFFER_SET(buf, value, size) \
+    do {\
+        int i;\
+        for (i=0;i<(size);i++){\
+            (buf)[i] = (value);\
+        }\
+    }while(0)
+
+#define TSM_RECEIVED_NUNBER 512
+
+
+typedef struct
+{
+  TSM_TIMESTAMP ts;
+  unsigned long long age;
+  void *key;
+} TSMControl;
+
+typedef struct _TSMReceivedEntry
+{
+  TSM_TIMESTAMP ts;
+  struct _TSMReceivedEntry *next;
+  unsigned int used:1;
+  unsigned int subentry:1;
+  int size;
+} TSMReceivedEntry;
+
+typedef struct _TSMReceivedEntryMemory
+{
+  struct _TSMReceivedEntryMemory *next;
+  TSMReceivedEntry entrys[TSM_RECEIVED_NUNBER];
+} TSMReceivedEntryMemory;
+
+typedef struct
+{
+  TSMReceivedEntry *head;
+  TSMReceivedEntry *tail;
+  TSMReceivedEntry *free;
+  TSMReceivedEntryMemory *memory;
+  int cnt;
+} TSMRecivedCtl;
+
+typedef struct _TSManager
+{
+  int first_tx;
+  int first_rx;
+  int rx;                       //timestamps received
+  int tx;                       //timestamps transfered
+  TSM_TIMESTAMP last_ts_sent;   //last time stamp sent
+  TSM_TIMESTAMP last_ts_received;
+  TSM_TIMESTAMP suspicious_ts;
+
+  TSM_TIMESTAMP discont_threshold;
+
+  unsigned int invalid_ts_count;
+  TSMGR_MODE mode;
+  int ts_buf_size;
+  int dur_history_tx;
+  TSM_TIMESTAMP dur_history_total;
+  TSM_TIMESTAMP dur_history_buf[TSM_HISTORY_SIZE];
+  TSMControl *ts_buf;
+  unsigned long long age;
+  int tx_cnt;
+  int rx_cnt;
+  int cnt;
+  int valid_ts_received:1;
+  int big_cnt;
+
+  TSMRecivedCtl rctl;
+} TSManager;
+
+
+static void
+tsm_free_received_entry (TSMRecivedCtl * rctl, TSMReceivedEntry * entry)
+{
+  entry->next = rctl->free;
+  rctl->free = entry;
+}
+
+
+static TSMReceivedEntry *
+tsm_new_received_entry (TSMRecivedCtl * rctl)
+{
+  TSMReceivedEntry *ret = NULL;
+  if (rctl->free) {
+    ret = rctl->free;
+    rctl->free = ret->next;
+  } else {
+    TSMReceivedEntryMemory *p = malloc (sizeof (TSMReceivedEntryMemory));
+    if (p) {
+      int i;
+      for (i = 1; i < TSM_RECEIVED_NUNBER; i++) {
+        TSMReceivedEntry *e = &p->entrys[i];
+        tsm_free_received_entry (rctl, e);
+      };
+
+      p->next = rctl->memory;
+      rctl->memory = p;
+
+      ret = p->entrys;
+    }
+  }
+  return ret;
+}
+
+
+void
+TSManagerReceive2 (void *handle, TSM_TIMESTAMP timestamp, int size)
+{
+#define CLEAR_TSM_RENTRY(entry)\
+  do { \
+    (entry)->used = 0; \
+    (entry)->subentry = 0; \
+    (entry)->next = NULL; \
+  } while (0)
+  TSManager *tsm = (TSManager *) handle;
+
+  TSM_VERBOSE ("receive2 %" TSM_TIME_FORMAT " size %d\n",
+      TSM_TIME_ARGS (timestamp), size);
+
+  if (tsm) {
+    if (size > 0) {
+      TSMRecivedCtl *rctl = &tsm->rctl;
+      TSMReceivedEntry *e = tsm_new_received_entry (rctl);
+      if (e) {
+        CLEAR_TSM_RENTRY (e);
+        if ((rctl->tail) && (rctl->tail->ts == timestamp)) {
+          e->subentry = 1;
+        }
+        e->ts = timestamp;
+        e->size = size;
+        if (rctl->tail) {
+          rctl->tail->next = e;
+          rctl->tail = e;
+        } else {
+          rctl->head = rctl->tail = e;
+        }
+      }
+      rctl->cnt++;
+    } else {
+      TSManagerReceive (handle, timestamp);
+    }
+  }
+}
+
+
+static TSM_TIMESTAMP
+TSManagerGetLastTimeStamp (TSMRecivedCtl * rctl, int size, int use)
+{
+  TSM_TIMESTAMP ts = TSM_TIMESTAMP_NONE;
+  TSMReceivedEntry *e;
+  while ((size > 0) && (e = rctl->head)) {
+    ts = ((e->used) ? (TSM_TIMESTAMP_NONE) : (e->ts));
+    if (use)
+      e->used = 1;
+    if (size >= e->size) {
+      rctl->head = e->next;
+      if (rctl->head == NULL) {
+        rctl->tail = NULL;
+      } else {
+        if (rctl->head->subentry) {
+          rctl->head->used = e->used;
+        }
+      }
+      size -= e->size;
+      rctl->cnt--;
+      tsm_free_received_entry (rctl, e);
+    } else {
+      e->size -= size;
+      size = 0;
+    }
+  }
+  return ts;
+}
+
+
+void
+TSManagerFlush2 (void *handle, int size)
+{
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    TSManagerGetLastTimeStamp (&tsm->rctl, size, 0);
+  }
+
+}
+
+
+/*======================================================================================
+FUNCTION:           mfw_gst_receive_ts
+
+DESCRIPTION:        Check timestamp and do frame dropping if enabled
+
+ARGUMENTS PASSED:   pTimeStamp_Object  - TimeStamp Manager to handle related timestamp
+                    timestamp - time stamp of the input buffer which has video data.
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=======================================================================================*/
+static void
+_TSManagerReceive (void *handle, TSM_TIMESTAMP timestamp, void *key)
+{
+  TSManager *tsm = (TSManager *) handle;
+
+  if (tsm) {
+    if (TSM_TS_IS_VALID (timestamp) && (tsm->rx_cnt))
+      tsm->valid_ts_received = 1;
+    tsm->rx_cnt++;
+    if (tsm->cnt < tsm->ts_buf_size - 1) {
+      tsm->cnt++;
+      if (tsm->mode == MODE_AI) {
+
+        if (TSM_TS_IS_VALID (timestamp)) {
+          if (tsm->first_rx) {
+            tsm->last_ts_received = timestamp;
+            tsm->first_rx = 0;
+          } else {
+            if (tsm->suspicious_ts) {
+              if (timestamp >= tsm->suspicious_ts) {
+                tsm->last_ts_received = timestamp;
+              }
+              tsm->suspicious_ts = 0;
+            }
+            if ((timestamp > tsm->last_ts_received)
+                && (timestamp - tsm->last_ts_received > tsm->discont_threshold)) {
+              tsm->suspicious_ts = timestamp;
+              timestamp = TSM_TIMESTAMP_NONE;
+            }
+          }
+        }
+
+        if (TSM_TS_IS_VALID (timestamp))        // && (TSM_ABS(timestamp, tsm->last_ts_sent)<TSM_SECOND*10))
+        {
+          tsm->ts_buf[tsm->rx].ts = timestamp;
+          tsm->ts_buf[tsm->rx].age = tsm->age + TSM_PLUS_AGE (tsm);
+          tsm->ts_buf[tsm->rx].key = key;
+          tsm->last_ts_received = timestamp;
+#ifdef DEBUG
+          //printf("age should %lld %lld\n", tsm->age, tsm->ts_buf[tsm->rx].age);
+          //printf("++++++ distance = %d  tx=%d, rx=%d, invalid count=%d\n", TSM_DISTANCE(tsm), tsm->tx, tsm->rx,tsm->invalid_ts_count);
+#endif
+          tsm->rx = ((tsm->rx + 1) % tsm->ts_buf_size);
+        } else {
+          tsm->invalid_ts_count++;
+        }
+      } else if (tsm->mode == MODE_FIFO) {
+        tsm->ts_buf[tsm->rx].ts = timestamp;
+        tsm->rx = ((tsm->rx + 1) % tsm->ts_buf_size);
+      }
+      TSM_LOG ("++Receive %d:%" TSM_TIME_FORMAT
+          ", invalid:%d, size:%d key %p\n", tsm->rx_cnt,
+          TSM_TIME_ARGS (timestamp), tsm->invalid_ts_count, tsm->cnt, key);
+    } else {
+      TSM_ERROR ("Too many timestamps recieved!! (cnt=%d)\n", tsm->cnt);
+    }
+  }
+}
+
+
+void
+TSManagerValid2 (void *handle, int size, void *key)
+{
+  TSManager *tsm = (TSManager *) handle;
+
+  TSM_VERBOSE ("valid2 size %d\n", size);
+
+  if (tsm) {
+    TSM_TIMESTAMP ts;
+    ts = TSManagerGetLastTimeStamp (&tsm->rctl, size, 1);
+    _TSManagerReceive (tsm, ts, key);
+  }
+}
+
+
+void
+TSManagerReceive (void *handle, TSM_TIMESTAMP timestamp)
+{
+  _TSManagerReceive (handle, timestamp, TSM_KEY_NONE);
+}
+
+
+/*======================================================================================
+FUNCTION:           TSManagerSend
+
+DESCRIPTION:        Check timestamp and do frame dropping if enabled
+
+ARGUMENTS PASSED:   pTimeStamp_Object  - TimeStamp Manager to handle related timestamp
+                    ptimestamp - returned timestamp to use at render
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=======================================================================================*/
+static TSM_TIMESTAMP
+_TSManagerSend2 (void *handle, void *key, int send)
+{
+  TSManager *tsm = (TSManager *) handle;
+  int i = tsm->tx;
+  int index = -1;
+  TSM_TIMESTAMP ts0 = 0, tstmp = TSM_TIMESTAMP_NONE;
+  unsigned long long age = 0;
+  TSM_TIMESTAMP half_interval = TSM_ADAPTIVE_INTERVAL (tsm) >> 1;
+
+  if (tsm) {
+    if (send) {
+      tsm->tx_cnt++;
+    } else {
+      tsm->cnt++;
+      tsm->invalid_ts_count++;
+    }
+    if (tsm->cnt > 0) {
+      if (send) {
+        tsm->cnt--;
+      }
+      if (tsm->mode == MODE_AI) {
+
+        if (tsm->first_tx == 0) {
+          tstmp = tsm->last_ts_sent + TSM_ADAPTIVE_INTERVAL (tsm);
+        } else {
+          tstmp = tsm->last_ts_sent;
+        }
+
+        while (i != tsm->rx) {
+          if (index >= 0) {
+            if (tsm->ts_buf[i].ts < ts0) {
+              ts0 = tsm->ts_buf[i].ts;
+              age = tsm->ts_buf[i].age;
+              index = i;
+            }
+          } else {
+            ts0 = tsm->ts_buf[i].ts;
+            age = tsm->ts_buf[i].age;
+            index = i;
+          }
+          if ((TSM_KEY_IS_VALID (key)) && (key == tsm->ts_buf[i].key))
+            break;
+          i = ((i + 1) % tsm->ts_buf_size);
+        }
+        if (index >= 0) {
+          if ((tsm->invalid_ts_count) && (ts0 >= ((tstmp) + half_interval))
+              && (age > tsm->age)) {
+            /* use calculated ts0 */
+            if (send) {
+              tsm->invalid_ts_count--;
+            }
+          } else {
+
+            if (send) {
+              if (index != tsm->tx) {
+                tsm->ts_buf[index] = tsm->ts_buf[tsm->tx];
+              }
+              tsm->tx = ((tsm->tx + 1) % tsm->ts_buf_size);
+
+            }
+#if 0
+            if (ts0 >= ((tstmp) + half_interval))
+              tstmp = tstmp;
+            else
+              tstmp = ts0;
+#else
+            tstmp = ts0;
+#endif
+          }
+
+        } else {
+          if (send) {
+            tsm->invalid_ts_count--;
+          }
+        }
+
+        if (tsm->first_tx == 0) {
+
+          if (tstmp > tsm->last_ts_sent) {
+            ts0 = (tstmp - tsm->last_ts_sent);
+          } else {
+            ts0 = 0;
+            tstmp = tsm->last_ts_sent;
+          }
+
+          if (ts0 > TSM_ADAPTIVE_INTERVAL (tsm) * 3 / 2) {
+            TSM_WARNING ("Jitter1:%" TSM_TIME_FORMAT " %" TSM_TIME_FORMAT "\n",
+                TSM_TIME_ARGS (ts0),
+                TSM_TIME_ARGS (TSM_ADAPTIVE_INTERVAL (tsm) * 3 / 2));
+          } else if (ts0 == 0) {
+            TSM_WARNING ("Jitter:%" TSM_TIME_FORMAT "\n", TSM_TIME_ARGS (ts0));
+          }
+
+          if (send) {
+            if ((ts0 < TSM_ADAPTIVE_INTERVAL (tsm) * 2) || (tsm->big_cnt > 3)) {
+              tsm->big_cnt = 0;
+              tsm->dur_history_total -=
+                  tsm->dur_history_buf[tsm->dur_history_tx];
+              tsm->dur_history_buf[tsm->dur_history_tx] = ts0;
+              tsm->dur_history_tx =
+                  ((tsm->dur_history_tx + 1) % TSM_HISTORY_SIZE);
+              tsm->dur_history_total += ts0;
+            } else {
+              tsm->big_cnt++;
+            }
+          }
+        }
+
+        if (send) {
+          tsm->last_ts_sent = tstmp;
+          tsm->age++;
+          tsm->first_tx = 0;
+        }
+
+      } else if (tsm->mode == MODE_FIFO) {
+        tstmp = tsm->ts_buf[tsm->tx].ts;
+        if (send) {
+          tsm->tx = ((tsm->tx + 1) % tsm->ts_buf_size);
+        }
+        ts0 = tstmp - tsm->last_ts_sent;
+        if (send) {
+          tsm->last_ts_sent = tstmp;
+        }
+      }
+
+      if (send) {
+        TSM_LOG ("--Send %d:%" TSM_TIME_FORMAT ", int:%" TSM_TIME_FORMAT
+            ", avg:%" TSM_TIME_FORMAT " inkey %p\n", tsm->tx_cnt,
+            TSM_TIME_ARGS (tstmp), TSM_TIME_ARGS (ts0),
+            TSM_TIME_ARGS (TSM_ADAPTIVE_INTERVAL (tsm)), key);
+      }
+
+    } else {
+      if (tsm->valid_ts_received == 0) {
+        if (tsm->first_tx) {
+          tstmp = tsm->last_ts_sent;
+        } else {
+          tstmp = tsm->last_ts_sent + TSM_ADAPTIVE_INTERVAL (tsm);
+        }
+        if (send) {
+          tsm->first_tx = 0;
+          tsm->last_ts_sent = tstmp;
+        }
+      }
+      TSM_ERROR ("Too many timestamps send!!\n");
+    }
+
+    if (send == 0) {
+      tsm->cnt--;
+      tsm->invalid_ts_count--;
+    }
+
+  }
+
+  return tstmp;
+}
+
+
+TSM_TIMESTAMP
+TSManagerSend2 (void *handle, void *key)
+{
+  return _TSManagerSend2 (handle, key, 1);
+}
+
+
+TSM_TIMESTAMP
+TSManagerQuery2 (void *handle, void *key)
+{
+  return _TSManagerSend2 (handle, key, 0);
+}
+
+
+TSM_TIMESTAMP
+TSManagerSend (void *handle)
+{
+  return TSManagerSend2 (handle, TSM_KEY_NONE);
+}
+
+
+TSM_TIMESTAMP
+TSManagerQuery (void *handle)
+{
+  return TSManagerQuery2 (handle, TSM_KEY_NONE);
+}
+
+
+void
+resyncTSManager (void *handle, TSM_TIMESTAMP synctime, TSMGR_MODE mode)
+{
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    TSMRecivedCtl *rctl = &tsm->rctl;
+    TSMReceivedEntry *e = rctl->head;
+
+    while ((e = rctl->head)) {
+      rctl->head = e->next;
+      tsm_free_received_entry (rctl, e);
+    };
+    rctl->cnt = 0;
+
+    rctl->tail = NULL;
+
+    tsm->first_tx = 1;
+    tsm->first_rx = 1;
+    tsm->suspicious_ts = 0;
+
+    if (TSM_TS_IS_VALID (synctime))
+      tsm->last_ts_sent = synctime;
+
+    tsm->tx = tsm->rx = 0;
+    tsm->invalid_ts_count = 0;
+    tsm->mode = mode;
+    tsm->age = 0;
+    tsm->rx_cnt = tsm->tx_cnt = tsm->cnt = 0;
+    tsm->valid_ts_received = 0;
+
+    tsm->big_cnt = 0;
+  }
+}
+
+
+/*======================================================================================
+FUNCTION:           mfw_gst_init_ts
+
+DESCRIPTION:        malloc and initialize timestamp strcture
+
+ARGUMENTS PASSED:   ppTimeStamp_Object  - pointer of TimeStamp Manager to handle related timestamp
+
+RETURN VALUE:       TimeStamp structure pointer
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=======================================================================================*/
+void *
+createTSManager (int ts_buf_size)
+{
+  TSManager *tsm = (TSManager *) malloc (sizeof (TSManager));
+  debug = getenv (debug_env);
+  if (debug) {
+    debug_level = atoi (debug);
+  }
+  // printf("debug = %s \n ++++++++++++++++++++++++++++",debug);
+  if (tsm) {
+    memset (tsm, 0, sizeof (TSManager));
+    if (ts_buf_size <= 0) {
+      ts_buf_size = TSM_DEFAULT_TS_BUFFER_SIZE;
+    }
+    tsm->ts_buf_size = ts_buf_size;
+    tsm->ts_buf = malloc (sizeof (TSMControl) * ts_buf_size);
+
+    if (tsm->ts_buf == NULL) {
+      goto fail;
+    }
+
+    resyncTSManager (tsm, (TSM_TIMESTAMP) 0, MODE_AI);
+
+    tsm->dur_history_tx = 0;
+    TSM_BUFFER_SET (tsm->dur_history_buf, TSM_DEFAULT_INTERVAL,
+        TSM_HISTORY_SIZE);
+    tsm->dur_history_total = TSM_DEFAULT_INTERVAL << TSM_HISTORY_POWER;
+
+    tsm->discont_threshold = 10000000000LL;     // 10s
+  }
+  return tsm;
+fail:
+  if (tsm) {
+    if (tsm->ts_buf) {
+      free (tsm->ts_buf);
+    }
+    free (tsm);
+    tsm = NULL;
+  }
+  return tsm;
+}
+
+
+void
+destroyTSManager (void *handle)
+{
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    TSMRecivedCtl *rctl = &tsm->rctl;
+    TSMReceivedEntryMemory *rmem;
+    if (tsm->ts_buf) {
+      free (tsm->ts_buf);
+    }
+
+    while ((rmem = rctl->memory)) {
+      rctl->memory = rmem->next;
+      free (rmem);
+    }
+    free (tsm);
+    tsm = NULL;
+  }
+}
+
+
+void
+setTSManagerFrameRate (void *handle, int fps_n, int fps_d)
+//void setTSManagerFrameRate(void * handle, float framerate)
+{
+  TSManager *tsm = (TSManager *) handle;
+  TSM_TIMESTAMP ts;
+  if ((fps_n > 0) && (fps_d > 0) && (fps_n / fps_d <= 80))
+    ts = TSM_SECOND * fps_d / fps_n;
+  else
+    ts = TSM_DEFAULT_INTERVAL;
+  // TSM_TIMESTAMP ts = TSM_SECOND / framerate;
+
+  if (tsm) {
+    TSM_BUFFER_SET (tsm->dur_history_buf, ts, TSM_HISTORY_SIZE);
+    tsm->dur_history_total = (ts << TSM_HISTORY_POWER);
+    if (debug)
+      TSM_LOG ("Set frame intrval:%" TSM_TIME_FORMAT "\n", TSM_TIME_ARGS (ts));
+  }
+}
+
+
+TSM_TIMESTAMP
+getTSManagerFrameInterval (void *handle)
+{
+  TSManager *tsm = (TSManager *) handle;
+  TSM_TIMESTAMP ts = 0;
+  if (tsm) {
+    ts = TSM_ADAPTIVE_INTERVAL (tsm);
+  }
+  return ts;
+}
+
+
+TSM_TIMESTAMP
+getTSManagerPosition (void *handle)
+{
+  TSManager *tsm = (TSManager *) handle;
+  TSM_TIMESTAMP ts = 0;
+  if (tsm) {
+    ts = tsm->last_ts_sent;
+  }
+  return ts;
+}
+
+
+int
+getTSManagerPreBufferCnt (void *handle)
+{
+  int i = 0;
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    i = tsm->rctl.cnt;
+  }
+  return i;
+}
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/mfw_gst_ts.h xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/mfw_gst_ts.h
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/mfw_gst_ts.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDCodecs/Video/mfw_gst_ts.h	2014-02-09 01:40:25.830083229 +0100
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2010-2012, Freescale Semiconductor, Inc. All rights reserved.
+ *
+ */
+
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * Module Name:    TimeStamp.h
+ *
+ * Description:    include TimeStamp stratege for VPU / SW video decoder plugin
+ *
+ * Portability:    This code is written for Linux OS and Gstreamer
+ */
+
+/*
+ * Changelog:
+  11/2/2010        draft version       Lyon Wang
+ *
+ */
+
+#ifndef _TIMESTAMP_H_
+#define _TIMESTAMP_H_
+
+
+/**
+ * GST_CLOCK_TIME_NONE:
+ *
+ * Constant to define an undefined clock time.
+ */
+
+typedef long long TSM_TIMESTAMP;
+
+typedef enum
+{
+  MODE_AI,
+  MODE_FIFO,
+} TSMGR_MODE;
+
+#define TSM_TIMESTAMP_NONE ((long long)(-1))
+#define TSM_KEY_NONE ((void *)0)
+
+/**
+ * GST_CLOCK_TIME_IS_VALID:
+ * @time: clock time to validate
+ *
+ * Tests if a given #GstClockTime represents a valid defined time.
+ */
+
+#ifdef __cplusplus
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*!
+ * This function receive timestamp into timestamp manager.
+ *
+ * @param	handle		handle of timestamp manager.
+ *
+ * @param	timestamp	timestamp received
+ *
+ * @return	
+ */
+  EXTERN void TSManagerReceive (void *handle, TSM_TIMESTAMP timestamp);
+
+  EXTERN void TSManagerReceive2 (void *handle, TSM_TIMESTAMP timestamp,
+      int size);
+
+  EXTERN void TSManagerFlush2 (void *handle, int size);
+
+  EXTERN void TSManagerValid2 (void *handle, int size, void *key);
+
+/*!
+ * This function send the timestamp for next output frame.
+ *
+ * @param	handle		handle of timestamp manager.
+ *
+ * @return	timestamp for next output frame.
+ */
+  EXTERN TSM_TIMESTAMP TSManagerSend (void *handle);
+
+  EXTERN TSM_TIMESTAMP TSManagerSend2 (void *handle, void *key);
+
+  EXTERN TSM_TIMESTAMP TSManagerQuery2 (void *handle, void *key);
+
+  EXTERN TSM_TIMESTAMP TSManagerQuery (void *handle);
+/*!
+ * This function resync timestamp handler when reset and seek
+ *
+ * @param	handle		handle of timestamp manager.
+ *
+ * @param	synctime    the postion time needed to set, if value invalid, position keeps original
+ * 
+ * @param	mode		playing mode (AI or FIFO)
+ *
+ * @return	
+ */
+  EXTERN void resyncTSManager (void *handle, TSM_TIMESTAMP synctime,
+      TSMGR_MODE mode);
+/*!
+ * This function create and reset timestamp handler
+ *
+ * @param	ts_buf_size	 time stamp queue buffer size 
+ * 
+ * @return	
+ */
+  EXTERN void *createTSManager (int ts_buf_size);
+/*!
+ * This function destory timestamp handler
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @return	
+ */
+  EXTERN void destroyTSManager (void *handle);
+/*!
+ * This function set  history buffer frame interval by fps_n and fps_d 
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @param	framerate       the framerate to be set
+ * 
+ * @return	
+ */
+  EXTERN void setTSManagerFrameRate (void *handle, int fps_n, int fps_d);
+//EXTERN void setTSManagerFrameRate(void * handle, float framerate);
+/*!
+ * This function set the current calculated Frame Interval
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @return	
+ */
+  EXTERN TSM_TIMESTAMP getTSManagerFrameInterval (void *handle);
+/*!
+ * This function get  the current time stamp postion
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @return	
+ */
+  EXTERN TSM_TIMESTAMP getTSManagerPosition (void *handle);
+  EXTERN int getTSManagerPreBufferCnt (void *handle);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_TIMESTAMP_H_ */
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2014-02-09 01:41:15.126138681 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2014-02-09 01:40:26.047083473 +0100
@@ -994,6 +994,7 @@
     case RENDER_FMT_CVBREF:    return "BGRA";
     case RENDER_FMT_EGLIMG:    return "EGLIMG";
     case RENDER_FMT_BYPASS:    return "BYPASS";
+    case RENDER_FMT_IMX:       return "IMX";
     case RENDER_FMT_MEDIACODEC:return "MEDIACODEC";
     case RENDER_FMT_NONE:      return "NONE";
   }
diff -Naur xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp xbmc-wolfgar-imx-wip.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
--- xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2014-02-09 01:41:14.829138348 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2014-02-09 01:40:25.675083053 +0100
@@ -20,6 +20,10 @@
 
 //#define DEBUG_VERBOSE 1
 
+#ifdef HAS_IMXVPU
+#include <linux/mxcfb.h>
+#endif
+
 #include "system.h"
 #if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
   #include "config.h"
@@ -63,6 +67,11 @@
 #ifdef TARGET_DARWIN_IOS
 #include "osx/DarwinUtils.h"
 #endif
+
+#ifdef HAS_IMXVPU
+#include "DVDCodecs/Video/DVDVideoCodecIMX.h"
+#endif
+
 #if defined(HAS_LIBSTAGEFRIGHT)
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
@@ -100,6 +109,10 @@
 #if defined(TARGET_ANDROID)
   mediacodec = NULL;
 #endif
+#ifdef HAS_IMXVPU
+  imxOutputFrame = NULL;
+#endif
+
 }
 
 CLinuxRendererGLES::YUVBUFFER::~YUVBUFFER()
@@ -110,6 +123,23 @@
 {
   m_textureTarget = GL_TEXTURE_2D;
 
+    /* FIXME a verifier */
+#if 0
+
+  for (int i = 0; i < NUM_BUFFERS; i++)
+  {
+#if defined(HAVE_LIBOPENMAX)
+    m_buffers[i].openMaxBuffer = 0;
+#endif
+#ifdef HAVE_VIDEOTOOLBOXDECODER
+    m_buffers[i].cvBufferRef = NULL;
+#endif
+#ifdef HAS_IMXVPU
+    m_buffers[i].imx = NULL;
+#endif
+  }
+#endif
+
   m_renderMethod = RENDER_GLSL;
   m_oldRenderMethod = m_renderMethod;
   m_renderQuality = RQ_SINGLEPASS;
@@ -491,6 +521,8 @@
 
   if (m_renderMethod & RENDER_BYPASS)
   {
+
+
     ManageDisplay();
     // if running bypass, then the player might need the src/dst rects
     // for sizing video playback on a layer other than the gles layer.
@@ -498,18 +530,53 @@
       (*m_RenderUpdateCallBackFn)(m_RenderUpdateCallBackCtx, m_sourceRect, m_destRect);
 
     CRect old = g_graphicsContext.GetScissors();
+    RESOLUTION res = GetResolution();
+    int iWidth = CDisplaySettings::Get().GetResolutionInfo(res).iWidth;
+    int iHeight = CDisplaySettings::Get().GetResolutionInfo(res).iHeight;
 
     g_graphicsContext.BeginPaint();
+    if (clear)
+    {
+      glScissor(0,
+                0,
+                iWidth,
+                iHeight);
+      glClearColor(GLfloat(0.0), GLfloat(0.0), GLfloat(0.0), 0);
+      glClear(GL_COLOR_BUFFER_BIT);
+    }
+
     g_graphicsContext.SetScissors(m_destRect);
+   /* CLog::Log(LOGDEBUG, "%s - m_destRect : %f %f %f %f\n",
+              __FUNCTION__, m_destRect.x1,  m_destRect.x2, m_destRect.y1,m_destRect.y2);*/
 
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    glClearColor(0, 0, 0, 0);
+
+/*    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);*/
+    glClearColor(GLfloat(2.0/31.0), GLfloat(2.0/63.0), GLfloat(2.0/31.0), 0);
     glClear(GL_COLOR_BUFFER_BIT);
 
     g_graphicsContext.SetScissors(old);
     g_graphicsContext.EndPaint();
+
+#ifdef HAS_IMXVPU
+    // FIXME : move in its own render mode instead of mixup with BYPASS
+    if (m_format == RENDER_FMT_IMX)
+    {
+      int index = m_iYV12RenderBuffer;
+      struct v4l2_crop crop;
+      crop.c.top = (int)m_destRect.y1;
+      crop.c.left = (int)m_destRect.x1;
+      crop.c.width =  (int)(m_destRect.x2 -  m_destRect.x1);
+      crop.c.height = (int)(m_destRect.y2 - m_destRect.y1);
+      CIMXOutputFrame *imxPicture = m_buffers[index].imxOutputFrame;
+      if (imxPicture != NULL)
+      {
+        imxPicture->Render(crop);
+        m_buffers[index].imxOutputFrame = NULL;
+      }
+    }
     return;
+#endif
   }
 
   // this needs to be checked after texture validation
@@ -597,6 +664,9 @@
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   m_formats.push_back(RENDER_FMT_CVBREF);
 #endif
+#ifdef HAS_IMXVPU
+  m_formats.push_back(RENDER_FMT_IMX);
+#endif
 #ifdef HAS_LIBSTAGEFRIGHT
   m_formats.push_back(RENDER_FMT_EGLIMG);
 #endif
@@ -726,6 +796,13 @@
         m_renderMethod = RENDER_CVREF;
         break;
       }
+      else if (m_format == RENDER_FMT_IMX)
+      {
+        CLog::Log(LOGNOTICE, "GL: IMX format Uses BYPASS render method");
+        m_renderMethod = RENDER_BYPASS;
+        break;
+      }
+      
       #if defined(TARGET_DARWIN_IOS)
       else if (ios_version < 5.0 && m_format == RENDER_FMT_YUV420P)
       {
@@ -890,6 +967,18 @@
     SAFE_RELEASE(buf.mediacodec);
   }
 #endif
+#ifdef HAS_IMXVPU
+  if (buf.imxOutputFrame != NULL)
+  {
+    // If we take that branch the buffer was not queued to V4L2
+    // So release the picture now so that VPU will be given
+    // the buffer back as soon as next ::Decode() call
+    buf.imxOutputFrame->Release();
+    buf.imxOutputFrame = NULL;
+  }
+  return;
+#endif
+
 }
 
 void CLinuxRendererGLES::Render(DWORD flags, int index)
@@ -2667,6 +2756,15 @@
   CVBufferRetain(buf.cvBufferRef);
 }
 #endif
+
+#ifdef HAS_IMXVPU
+void CLinuxRendererGLES::AddProcessor(CIMXOutputFrame *imx, int index)
+{
+  YUVBUFFER &buf = m_buffers[index];
+  buf.imxOutputFrame = imx;
+}
+#endif
+
 #ifdef HAS_LIBSTAGEFRIGHT
 void CLinuxRendererGLES::AddProcessor(CDVDVideoCodecStageFright* stf, EGLImageKHR eglimg, int index)
 {
@@ -2688,6 +2786,7 @@
 }
 #endif
 
+
 #if defined(TARGET_ANDROID)
 void CLinuxRendererGLES::AddProcessor(CDVDMediaCodecInfo *mediacodec, int index)
 {
diff -Naur xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.h xbmc-wolfgar-imx-wip.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
--- xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2014-02-09 01:41:14.826138345 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2014-02-09 01:40:25.665083043 +0100
@@ -42,6 +42,7 @@
 class COpenMaxVideo;
 class CDVDVideoCodecStageFright;
 class CDVDMediaCodecInfo;
+class CIMXOutputFrame;
 typedef std::vector<int>     Features;
 
 
@@ -169,6 +170,9 @@
 #ifdef HAS_LIBSTAGEFRIGHT
   virtual void         AddProcessor(CDVDVideoCodecStageFright* stf, EGLImageKHR eglimg, int index);
 #endif
+#ifdef HAS_IMXVPU
+  virtual void         AddProcessor(CIMXOutputFrame *imx,  int index);
+#endif
 #if defined(TARGET_ANDROID)
   // mediaCodec
   virtual void         AddProcessor(CDVDMediaCodecInfo *mediacodec, int index);
@@ -280,6 +284,9 @@
 #ifdef HAVE_VIDEOTOOLBOXDECODER
     struct __CVBuffer *cvBufferRef;
 #endif
+#ifdef HAS_IMXVPU
+    CIMXOutputFrame *imxOutputFrame;
+#endif
 #ifdef HAS_LIBSTAGEFRIGHT
     CDVDVideoCodecStageFright* stf;
     EGLImageKHR eglimg;
diff -Naur xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/RenderFormats.h xbmc-wolfgar-imx-wip.test/xbmc/cores/VideoRenderers/RenderFormats.h
--- xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/RenderFormats.h	2014-02-09 01:41:14.827138346 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/VideoRenderers/RenderFormats.h	2014-02-09 01:40:25.674083053 +0100
@@ -35,6 +35,7 @@
   RENDER_FMT_OMXEGL,
   RENDER_FMT_CVBREF,
   RENDER_FMT_BYPASS,
+  RENDER_FMT_IMX,
   RENDER_FMT_EGLIMG,
   RENDER_FMT_MEDIACODEC,
 };
diff -Naur xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/RenderManager.cpp xbmc-wolfgar-imx-wip.test/xbmc/cores/VideoRenderers/RenderManager.cpp
--- xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/RenderManager.cpp	2014-02-09 01:41:14.826138345 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/cores/VideoRenderers/RenderManager.cpp	2014-02-09 01:40:25.674083053 +0100
@@ -920,6 +920,10 @@
   else if(pic.format == RENDER_FMT_VAAPI)
     m_pRenderer->AddProcessor(*pic.vaapi, index);
 #endif
+#ifdef HAS_IMXVPU
+  else if(pic.format == RENDER_FMT_IMX)
+    m_pRenderer->AddProcessor(pic.imxOutputFrame, index);
+#endif
 #ifdef HAS_LIBSTAGEFRIGHT
   else if(pic.format == RENDER_FMT_EGLIMG)
     m_pRenderer->AddProcessor(pic.stf, pic.eglimg, index);
diff -Naur xbmc-gotham-latest.test/xbmc/input/linux/LinuxInputDevices.cpp xbmc-wolfgar-imx-wip.test/xbmc/input/linux/LinuxInputDevices.cpp
--- xbmc-gotham-latest.test/xbmc/input/linux/LinuxInputDevices.cpp	2014-02-09 01:41:09.587132460 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/input/linux/LinuxInputDevices.cpp	2014-02-09 01:40:22.522079500 +0100
@@ -1222,7 +1222,8 @@
 
     if ((now - m_lastHotplugCheck) >= 10)
     {
-      CheckHotplugged();
+      // Comment for now as it has visible issue on video decoding when USB devices are available
+      //CheckHotplugged();
       m_lastHotplugCheck = now;
     }
   }
diff -Naur xbmc-gotham-latest.test/xbmc/powermanagement/PowerManager.cpp xbmc-wolfgar-imx-wip.test/xbmc/powermanagement/PowerManager.cpp
diff -Naur xbmc-gotham-latest.test/xbmc/video/dialogs/GUIDialogVideoOSD.cpp xbmc-wolfgar-imx-wip.test/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
diff -Naur xbmc-gotham-latest.test/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp xbmc-wolfgar-imx-wip.test/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
--- xbmc-gotham-latest.test/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp	2014-02-09 01:41:14.415137886 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp	2014-02-09 01:40:25.076082379 +0100
@@ -17,6 +17,7 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
+#include <linux/fb.h>
 
 #include "EGLNativeTypeAmlogic.h"
 #include "guilib/gui3d.h"
@@ -24,7 +25,6 @@
 #include "utils/StringUtils.h"
 
 #include <stdlib.h>
-#include <linux/fb.h>
 #include <sys/ioctl.h>
 #include <EGL/egl.h>
 
diff -Naur xbmc-gotham-latest.test/xbmc/windowing/egl/EGLNativeTypeIMX.cpp xbmc-wolfgar-imx-wip.test/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
--- xbmc-gotham-latest.test/xbmc/windowing/egl/EGLNativeTypeIMX.cpp	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/windowing/egl/EGLNativeTypeIMX.cpp	2014-02-09 01:40:25.076082379 +0100
@@ -0,0 +1,272 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/mxcfb.h>
+#include "system.h"
+#include <EGL/egl.h>
+
+#include "EGLNativeTypeIMX.h"
+#include <math.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "guilib/gui3d.h"
+
+CEGLNativeTypeIMX::CEGLNativeTypeIMX()
+{
+}
+
+CEGLNativeTypeIMX::~CEGLNativeTypeIMX()
+{
+} 
+
+bool CEGLNativeTypeIMX::CheckCompatibility()
+{
+  char name[256] = {0};
+  get_sysfs_str("/sys/class/graphics/fb0/device/modalias", name, 255);
+  CStdString strName = name;
+  StringUtils::Trim(strName);
+  if (strName == "platform:mxc_sdc_fb")
+    return true;
+  return false;
+}
+
+void CEGLNativeTypeIMX::Initialize()
+{  
+  struct mxcfb_gbl_alpha alpha;
+  int fd, fd2;
+
+  
+  fd = open("/dev/fb0",O_RDWR);
+  if (fd < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while opening /dev/fb0.\n", __FUNCTION__);
+    return;
+  }
+  fd2 = open("/dev/fb1",O_RDWR);
+  if (fd2 < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while opening /dev/fb1.\n", __FUNCTION__);
+    return;
+  }
+  
+  /* Store screen info */
+  if (ioctl(fd, FBIOGET_VSCREENINFO, &m_screeninfo) != 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while querying frame buffer.\n", __FUNCTION__);
+    return;
+  }
+  /* Configure overlay in the same way as BG plane */
+  if (ioctl(fd2, FBIOPUT_VSCREENINFO, &m_screeninfo) != 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while setting overlay frame buffer.\n", __FUNCTION__);
+    return;
+  }
+      
+  /* set fb0 as the only visible layer - ioctl on /dev/fb0 so that fb0 is BG and fb1 is FG */
+  alpha.alpha = 255;
+  alpha.enable = 1;
+  if (ioctl(fd, MXCFB_SET_GBL_ALPHA, &alpha) != 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while initializing frame buffer.\n", __FUNCTION__);
+  }
+ 
+  /* Unblank the fbs */
+  if (ioctl(fd, FBIOBLANK, 0) < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while unblanking fb0.\n", __FUNCTION__);
+  }
+  if (ioctl(fd2, FBIOBLANK, 0) < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while unblanking fb0.\n", __FUNCTION__);
+  }
+  
+  close(fd);
+  close(fd2);
+  
+  return;
+}
+
+void CEGLNativeTypeIMX::Destroy()
+{
+  struct fb_fix_screeninfo fixed_info;
+  void *fb_buffer;
+  struct mxcfb_gbl_alpha alpha;
+  int fd;
+
+  fd = open("/dev/fb0",O_RDWR);
+  if (fd < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while opening /dev/fb0.\n", __FUNCTION__);
+    return;
+  }   
+  /* only fb0 visible */
+  alpha.alpha = 255;
+  alpha.enable = 1;
+  if (ioctl(fd, MXCFB_SET_GBL_ALPHA, &alpha) != 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while initializing frame buffer.\n", __FUNCTION__);
+  }
+  
+  ioctl( fd, FBIOGET_FSCREENINFO, &fixed_info);  
+  /* Black fb0 */
+  fb_buffer = mmap(NULL, fixed_info.smem_len, PROT_WRITE, MAP_SHARED, fd, 0);
+  if (fb_buffer == MAP_FAILED)
+  {
+    CLog::Log(LOGERROR, "%s - fb mmap failed %s.\n", __FUNCTION__, strerror(errno));
+  }
+  else 
+  {
+    memset(fb_buffer, 0x0, fixed_info.smem_len);
+    munmap(fb_buffer, fixed_info.smem_len);
+  }
+ 
+  close(fd); 
+
+  /* Blank overlay */
+  fd = open("/dev/fb1",O_RDWR);
+  if (fd < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while opening /dev/fb1.\n", __FUNCTION__);
+    return;
+  }
+  if (ioctl(fd, FBIOBLANK, 1) < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while blanking fb1.\n", __FUNCTION__);
+  }  
+  close(fd);
+  
+  return;
+}
+
+bool CEGLNativeTypeIMX::CreateNativeDisplay()
+{
+  /* EGL will be rendered on fb0 */
+  m_display = fbGetDisplayByIndex(0);
+  m_nativeDisplay = &m_display;
+  return true;
+}
+
+bool CEGLNativeTypeIMX::CreateNativeWindow()
+{
+  m_window = fbCreateWindow(m_display, 0, 0, m_screeninfo.xres, m_screeninfo.yres);
+  m_nativeWindow = &m_window;
+  return true;
+}  
+
+bool CEGLNativeTypeIMX::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType*)m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeIMX::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType*)m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeIMX::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeIMX::DestroyNativeWindow()
+{
+  return true;
+}
+
+bool CEGLNativeTypeIMX::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  double drate = 0, hrate = 0, vrate = 0;
+  if (!res)
+    return false;
+
+  drate = 1e12 / m_screeninfo.pixclock;
+  hrate = drate / (m_screeninfo.left_margin + m_screeninfo.xres +  m_screeninfo.right_margin + m_screeninfo.hsync_len);
+  vrate = hrate / (m_screeninfo.upper_margin + m_screeninfo.yres + m_screeninfo.lower_margin + m_screeninfo.vsync_len);
+
+  res->iWidth = m_screeninfo.xres;
+  res->iHeight = m_screeninfo.yres;
+  res->iScreenWidth  = res->iWidth;
+  res->iScreenHeight = res->iHeight;
+  res->fRefreshRate = lrint(vrate);
+  res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  res->iScreen       = 0;
+  res->bFullScreen   = true;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+  res->fPixelRatio   = 1.0f;
+  res->strMode = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
+  res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  return res->iWidth > 0 && res->iHeight> 0;
+}
+
+bool CEGLNativeTypeIMX::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  return false;
+}
+
+bool CEGLNativeTypeIMX::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  RESOLUTION_INFO res;
+  bool ret = false;
+  ret = GetNativeResolution(&res);
+  if (ret && res.iWidth > 1 && res.iHeight > 1)
+  {
+    resolutions.push_back(res);
+    return true;
+  }
+  return false;
+}
+
+bool CEGLNativeTypeIMX::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  return false;
+}
+
+bool CEGLNativeTypeIMX::ShowWindow(bool show)
+{
+  // CLog::Log(LOGERROR, "%s - call CEGLNativeTypeIMX::ShowWindow with %d.\n", __FUNCTION__, show);
+  return false;
+}
+
+int CEGLNativeTypeIMX::get_sysfs_str(const char *path, char *valstr, const int size) const
+{
+  int fd = open(path, O_RDONLY);
+  if (fd >= 0)
+  {
+    int len = read(fd, valstr, size - 1);
+    if (len != -1 )
+      valstr[len] = '\0';
+    close(fd);
+  }
+  else
+  {
+    sprintf(valstr, "%s", "fail");
+    return -1;
+  }
+  return 0;
+}
diff -Naur xbmc-gotham-latest.test/xbmc/windowing/egl/EGLNativeTypeIMX.h xbmc-wolfgar-imx-wip.test/xbmc/windowing/egl/EGLNativeTypeIMX.h
--- xbmc-gotham-latest.test/xbmc/windowing/egl/EGLNativeTypeIMX.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/windowing/egl/EGLNativeTypeIMX.h	2014-02-09 01:40:25.078082381 +0100
@@ -0,0 +1,62 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <linux/fb.h>
+#include "EGLNativeType.h"
+#include "EGL/eglvivante.h"
+
+class CEGLNativeTypeIMX : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeIMX();
+  virtual ~CEGLNativeTypeIMX();
+  virtual std::string GetNativeName() const { return "iMX"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+  
+  protected:
+  int get_sysfs_str(const char *path, char *valstr, const int size) const;
+  bool ModeToResolution(const char *mode, RESOLUTION_INFO *res) const;
+  
+  EGLNativeDisplayType m_display;
+  EGLNativeWindowType  m_window;
+
+protected:
+  struct fb_var_screeninfo m_screeninfo;
+
+};
diff -Naur xbmc-gotham-latest.test/xbmc/windowing/egl/EGLWrapper.cpp xbmc-wolfgar-imx-wip.test/xbmc/windowing/egl/EGLWrapper.cpp
--- xbmc-gotham-latest.test/xbmc/windowing/egl/EGLWrapper.cpp	2014-02-09 01:41:14.417137884 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/windowing/egl/EGLWrapper.cpp	2014-02-09 01:40:25.077082380 +0100
@@ -17,11 +17,10 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
-
+#include "EGLNativeTypeIMX.h"
 #include "system.h"
 
 #ifdef HAS_EGL
-
 #include "utils/log.h"
 #include "EGLNativeTypeAndroid.h"
 #include "EGLNativeTypeAmlogic.h"
@@ -83,7 +82,8 @@
   if ((nativeGuess = CreateEGLNativeType<CEGLNativeTypeWayland>(implementation)) ||
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeAndroid>(implementation)) ||
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeAmlogic>(implementation)) ||
-      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeRaspberryPI>(implementation)))
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeRaspberryPI>(implementation)) ||
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeIMX>(implementation)))
   {
     m_nativeTypes = nativeGuess;
 
diff -Naur xbmc-gotham-latest.test/xbmc/windowing/egl/Makefile.in xbmc-wolfgar-imx-wip.test/xbmc/windowing/egl/Makefile.in
--- xbmc-gotham-latest.test/xbmc/windowing/egl/Makefile.in	2014-02-09 01:41:14.375137840 +0100
+++ xbmc-wolfgar-imx-wip.test/xbmc/windowing/egl/Makefile.in	2014-02-09 01:40:25.055082355 +0100
@@ -5,6 +5,7 @@
 SRCS+= EGLNativeTypeAndroid.cpp
 SRCS+= EGLNativeTypeRaspberryPI.cpp
 SRCS+= EGLNativeTypeWayland.cpp
+SRCS+= EGLNativeTypeIMX.cpp
 SRCS+= EGLWrapper.cpp
 
 # Wayland specific detail
