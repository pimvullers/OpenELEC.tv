diff -Naur xbmc-gotham-latest.test/configure.in xbmc-imx6-koying.test/configure.in
--- xbmc-gotham-latest.test/configure.in	2014-02-21 23:10:49.246106103 +0100
+++ xbmc-imx6-koying.test/configure.in	2014-02-21 23:11:24.639122704 +0100
@@ -558,7 +558,7 @@
 
 AC_ARG_ENABLE([codec],
   [AS_HELP_STRING([--enable-codec],
-  [enable additional codecs from a list of comma separated names, (default is none, choices are amcodec, libstagefright)])],
+  [enable additional codecs from a list of comma separated names, (default is none, choices are amcodec, libstagefright and imxvpu)])],
   [add_codecs=$enableval],
   [add_codecs=no])
 
@@ -1993,6 +1993,17 @@
     *libstagefright*)
         XB_ADD_CODEC([LIBSTAGEFRIGHT], [libstagefright], [$codecs])
         ;;
+    *imxvpu*)
+      AC_CHECK_HEADER([imx-mm/vpu/vpu_wrapper.h],, AC_MSG_ERROR($missing_headers))
+      AC_CHECK_LIB([vpu], main, LIBS="$LIBS -lfslvpuwrap -lvpu", AC_MSG_ERROR($missing_library))
+      XB_ADD_CODEC([IMXVPU], [imxvpu], [$codecs])
+      CXXFLAGS="$CXXFLAGS -Wno-psabi -DLINUX "
+      CFLAGS="$CFLAGS -DLINUX"
+      if test "$use_x11" = "no"; then
+        CXXFLAGS="$CXXFLAGS -DEGL_API_FB"
+        CFLAGS="$CFLAGS -DEGL_API_FB"
+      fi
+      ;;     
     *)
   esac
 done
diff -Naur xbmc-gotham-latest.test/lib/ffmpeg/libavcodec/arm/dca.h xbmc-imx6-koying.test/lib/ffmpeg/libavcodec/arm/dca.h
--- xbmc-gotham-latest.test/lib/ffmpeg/libavcodec/arm/dca.h	2014-02-21 23:10:38.903101147 +0100
+++ xbmc-imx6-koying.test/lib/ffmpeg/libavcodec/arm/dca.h	2014-02-21 23:11:24.183122503 +0100
@@ -30,9 +30,9 @@
 
 #define decode_blockcodes decode_blockcodes
 static inline int decode_blockcodes(int code1, int code2, int levels,
-                                    int *values)
+                                    int32_t *values)
 {
-    int v0, v1, v2, v3, v4, v5;
+    int32_t v0, v1, v2, v3, v4, v5;
 
     __asm__ ("smmul   %0,  %6,  %10           \n"
              "smmul   %3,  %7,  %10           \n"
@@ -101,3 +101,4 @@
 #endif
 
 #endif /* AVCODEC_ARM_DCA_H */
+
diff -Naur xbmc-gotham-latest.test/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp xbmc-imx6-koying.test/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
--- xbmc-gotham-latest.test/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp	2014-02-21 23:10:30.558097110 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp	2014-02-21 23:11:23.795122326 +0100
@@ -714,7 +714,10 @@
    * will automatically add "@" instead to enable surroundXX mangling.
    * We don't want to do that if "default" can handle multichannel
    * itself (e.g. in case of a pulseaudio server). */
-  EnumerateDevice(list, "default", "", config);
+
+  /* For Wandboard, we do not enurate default device as it will be grabbed
+   * as one of the sysdefault devices... */
+
 
   void **hints;
 
@@ -765,8 +768,8 @@
        * found by the enumeration process. Skip them as well ("hw", "dmix",
        * "plughw", "dsnoop"). */
 
+      /* For wandboard all devices are prefixed by sysdefault so do not ignore them */
       else if (baseName != "default"
-            && baseName != "sysdefault"
             && baseName != "surround40"
             && baseName != "surround41"
             && baseName != "surround50"
@@ -875,6 +878,22 @@
 
 AEDeviceType CAESinkALSA::AEDeviceTypeFromName(const std::string &name)
 {
+  std::size_t found;
+
+  /* Hack : Check for specific wandboard sound device names */
+  found = name.find("imxspdif");
+  if (found!=std::string::npos)
+    return AE_DEVTYPE_IEC958;
+
+  found = name.find("imxhdmisoc");
+  if (found!=std::string::npos)
+    return AE_DEVTYPE_HDMI;
+
+  found = name.find("sgtl5000audio");
+  if (found!=std::string::npos)
+    return AE_DEVTYPE_PCM;
+
+
   if (name.substr(0, 4) == "hdmi")
     return AE_DEVTYPE_HDMI;
   else if (name.substr(0, 6) == "iec958" || name.substr(0, 5) == "spdif")
diff -Naur xbmc-gotham-latest.test/xbmc/cores/AudioEngine/Utils/AEConvert.cpp xbmc-imx6-koying.test/xbmc/cores/AudioEngine/Utils/AEConvert.cpp
--- xbmc-gotham-latest.test/xbmc/cores/AudioEngine/Utils/AEConvert.cpp	2014-02-21 23:10:30.595097127 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/AudioEngine/Utils/AEConvert.cpp	2014-02-21 23:11:23.796122326 +0100
@@ -841,7 +841,7 @@
   _mm_empty();
   #else /* no SSE2 */
   for (uint32_t i = 0; i < samples; ++i)
-    *dst++ = (safeRound(*data++ * ((float)INT24_MAX+.5f)) & 0xFFFFFF) << 8;
+    *dst++ = safeRound(*data++ * ((float)INT24_MAX+.5f)) & 0x00FFFFFF;
   #endif
 
   return samples << 2;
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2014-02-21 23:10:30.378097022 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2014-02-21 23:11:23.790122324 +0100
@@ -35,6 +35,9 @@
 #include "Video/DVDVideoCodecFFmpeg.h"
 #include "Video/DVDVideoCodecOpenMax.h"
 #include "Video/DVDVideoCodecLibMpeg2.h"
+#if defined(HAS_IMXVPU)
+#include "Video/DVDVideoCodecIMX.h"
+#endif
 #include "Video/DVDVideoCodecStageFright.h"
 #if defined(HAVE_LIBCRYSTALHD)
 #include "Video/DVDVideoCodecCrystalHD.h"
@@ -191,7 +194,11 @@
 #elif defined(TARGET_POSIX) && !defined(TARGET_DARWIN)
   hwSupport += "VAAPI:no ";
 #endif
-
+#if defined(HAS_IMXVPU)
+  hwSupport += "iMXVPU:yes ";
+#else
+  hwSupport += "iMXVPU:no ";
+#endif  
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 #if defined(HAS_LIBAMCODEC)
   // amcodec can handle dvd playback.
@@ -205,6 +212,15 @@
     }
   }
 
+/*#endif*/
+  
+#if defined(HAS_IMXVPU)
+  if (!hint.software)
+  {
+    if ( (pCodec = OpenCodec(new CDVDVideoCodecIMX(), hint, options)) ) return pCodec;
+  }
+#endif
+  
 #if defined(TARGET_DARWIN_OSX)
   if (!hint.software && CSettings::Get().GetBool("videoplayer.usevda"))
   {
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2014-02-21 23:10:30.397097031 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2014-02-21 23:11:23.790122324 +0100
@@ -27,6 +27,7 @@
 #include <vector>
 #include <string>
 #include "cores/VideoRenderers/RenderFormats.h"
+#include "DVDVideoCodecInfo.h"
 
 struct DVDCodecAvailableType 
 {
@@ -91,6 +92,11 @@
     struct {
       CDVDMediaCodecInfo *mediacodec;
     };
+  
+    struct {
+      CDVDVideoCodecBuffer *codecinfo;
+    };
+
   };
 
   unsigned int iFlags;
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp	2014-02-21 23:11:23.790122324 +0100
@@ -0,0 +1,950 @@
+/* 
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/mxcfb.h>
+#include "DVDVideoCodecIMX.h"
+
+#include <linux/mxc_v4l2.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "DVDClock.h"
+#include "threads/Atomics.h"
+
+
+// FIXME get rid of these defines properly
+#define FRAME_ALIGN 16
+#define MEDIAINFO 1
+#define _4CC(c1,c2,c3,c4) (((uint32_t)(c4)<<24)|((uint32_t)(c3)<<16)|((uint32_t)(c2)<<8)|(uint32_t)(c1))
+#define Align(ptr,align)  (((unsigned int)ptr + (align) - 1)/(align)*(align))
+#define min(a, b) (a<b)?a:b
+
+#define IMX_MAX_QUEUE_SIZE 1
+// Experiments show that we need at least one more (+1) V4L buffer than the min value returned by the VPU
+const int CDVDVideoCodecIMX::m_extraVpuBuffers = IMX_MAX_QUEUE_SIZE + 6;
+CCriticalSection CDVDVideoCodecIMX::m_codecBufferLock;
+
+bool CDVDVideoCodecIMX::VpuAllocBuffers(VpuMemInfo *pMemBlock)
+{
+  int i, size;
+  unsigned char * ptr;
+  VpuMemDesc vpuMem;
+  VpuDecRetCode ret;
+
+  for(i=0; i<pMemBlock->nSubBlockNum; i++)
+  {
+    size = pMemBlock->MemSubBlock[i].nAlignment + pMemBlock->MemSubBlock[i].nSize;
+    if (pMemBlock->MemSubBlock[i].MemType == VPU_MEM_VIRT)
+    { // Allocate standard virtual memory
+      ptr = (unsigned char *)malloc(size);
+      if(ptr == NULL)
+      {
+        CLog::Log(LOGERROR, "%s - Unable to malloc %d bytes.\n", __FUNCTION__, size);
+        goto AllocFailure;
+      }
+      pMemBlock->MemSubBlock[i].pVirtAddr = (unsigned char*)Align(ptr, pMemBlock->MemSubBlock[i].nAlignment);
+
+      m_decMemInfo.virtMem[m_decMemInfo.nVirtNum] = (unsigned int)ptr;
+      m_decMemInfo.nVirtNum++;
+    }
+    else
+    { // Allocate contigous mem for DMA
+      vpuMem.nSize = size;
+      ret = VPU_DecGetMem(&vpuMem);
+      if(ret != VPU_DEC_RET_SUCCESS)
+      {
+        CLog::Log(LOGERROR, "%s - Unable alloc %d bytes of physical memory (%d).\n", __FUNCTION__, size, ret);
+        goto AllocFailure;
+      }
+      pMemBlock->MemSubBlock[i].pVirtAddr = (unsigned char*)Align(vpuMem.nVirtAddr, pMemBlock->MemSubBlock[i].nAlignment);
+      pMemBlock->MemSubBlock[i].pPhyAddr = (unsigned char*)Align(vpuMem.nPhyAddr, pMemBlock->MemSubBlock[i].nAlignment);
+
+      m_decMemInfo.phyMem_phyAddr[m_decMemInfo.nPhyNum] = (unsigned int)vpuMem.nPhyAddr;
+      m_decMemInfo.phyMem_virtAddr[m_decMemInfo.nPhyNum] = (unsigned int)vpuMem.nVirtAddr;
+      m_decMemInfo.phyMem_cpuAddr[m_decMemInfo.nPhyNum] = (unsigned int)vpuMem.nCpuAddr;
+      m_decMemInfo.phyMem_size[m_decMemInfo.nPhyNum] = size;
+      m_decMemInfo.nPhyNum++;
+    }
+  }
+
+  return true;
+
+AllocFailure:
+        VpuFreeBuffers();
+        return false;
+}
+
+int CDVDVideoCodecIMX::VpuFindBuffer(void *frameAddr)
+{
+  for (int i=0; i<m_vpuFrameBufferNum; i++)
+  {
+    if (m_vpuFrameBuffers[i].pbufY == frameAddr)
+      return i;
+  }
+  return -1;
+}
+
+bool CDVDVideoCodecIMX::VpuFreeBuffers(void)
+{
+  VpuMemDesc vpuMem;
+  VpuDecRetCode vpuRet;
+  bool ret = true;
+
+  //free virtual mem
+  for(int i=0; i<m_decMemInfo.nVirtNum; i++)
+  {
+    if (m_decMemInfo.virtMem[i])
+      free((void*)m_decMemInfo.virtMem[i]);
+  }
+  m_decMemInfo.nVirtNum = 0;
+
+  //free physical mem
+  for(int i=0; i<m_decMemInfo.nPhyNum; i++)
+  {
+    vpuMem.nPhyAddr = m_decMemInfo.phyMem_phyAddr[i];
+    vpuMem.nVirtAddr = m_decMemInfo.phyMem_virtAddr[i];
+    vpuMem.nCpuAddr = m_decMemInfo.phyMem_cpuAddr[i];
+    vpuMem.nSize = m_decMemInfo.phyMem_size[i];
+    vpuRet = VPU_DecFreeMem(&vpuMem);
+    if(vpuRet != VPU_DEC_RET_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s - Errror while trying to free physical memory (%d).\n", __FUNCTION__, ret);
+      ret = false;
+    }
+  }
+  m_decMemInfo.nPhyNum = 0;
+
+  return ret;
+}
+
+
+bool CDVDVideoCodecIMX::VpuOpen(void)
+{
+  VpuDecRetCode  ret;
+  VpuVersionInfo vpuVersion;
+  VpuMemInfo     memInfo;
+  VpuDecConfig config;
+  int param;
+
+  memset(&memInfo, 0, sizeof(VpuMemInfo));
+  ret = VPU_DecLoad();
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s - VPU load failed with error code %d.\n", __FUNCTION__, ret);
+    goto VpuOpenError;
+  }
+
+  ret = VPU_DecGetVersionInfo(&vpuVersion);
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s - VPU version cannot be read (%d).\n", __FUNCTION__, ret);
+    goto VpuOpenError;
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "VPU Lib version : major.minor.rel=%d.%d.%d.\n", vpuVersion.nLibMajor, vpuVersion.nLibMinor, vpuVersion.nLibRelease);
+  }
+
+  ret = VPU_DecQueryMem(&memInfo);
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+          CLog::Log(LOGERROR, "%s - iMX VPU query mem error (%d).\n", __FUNCTION__, ret);
+          goto VpuOpenError;
+  }
+  VpuAllocBuffers(&memInfo);
+
+  m_decOpenParam.nReorderEnable = 1;
+  m_decOpenParam.nChromaInterleave = 1;
+  m_decOpenParam.nMapType = 0;
+  m_decOpenParam.nTiled2LinearEnable = 0;
+  m_decOpenParam.nEnableFileMode = 0;
+
+  ret = VPU_DecOpen(&m_vpuHandle, &m_decOpenParam, &memInfo);
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s - iMX VPU open failed (%d).\n", __FUNCTION__, ret);
+    goto VpuOpenError;
+  }
+
+  config = VPU_DEC_CONF_SKIPMODE;
+  param = VPU_DEC_SKIPNONE;
+  ret = VPU_DecConfig(m_vpuHandle, config, &param);
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s - iMX VPU set skip mode failed  (%d).\n", __FUNCTION__, ret);
+    goto VpuOpenError;
+  }
+
+  return true;
+
+VpuOpenError:
+  Dispose();
+  return false;
+}
+
+bool CDVDVideoCodecIMX::VpuAllocFrameBuffers(void)
+{
+  VpuDecRetCode ret;
+  VpuMemDesc vpuMem;
+  int totalSize=0;
+  int mvSize=0;
+  int ySize=0;
+  int uvSize=0;
+  int yStride=0;
+  int uvStride=0;
+  unsigned char* ptr;
+  unsigned char* ptrVirt;
+  int nAlign;
+
+  m_vpuFrameBufferNum =  m_initInfo.nMinFrameBufferCount + m_extraVpuBuffers;
+  m_vpuFrameBuffers = new VpuFrameBuffer[m_vpuFrameBufferNum];
+
+  yStride=Align(m_initInfo.nPicWidth,FRAME_ALIGN);
+  if(m_initInfo.nInterlace)
+  {
+    ySize=Align(m_initInfo.nPicWidth,FRAME_ALIGN)*Align(m_initInfo.nPicHeight,(2*FRAME_ALIGN));
+  }
+  else
+  {
+    ySize=Align(m_initInfo.nPicWidth,FRAME_ALIGN)*Align(m_initInfo.nPicHeight,FRAME_ALIGN);
+  }
+
+  //NV12 for all video
+  uvStride=yStride;
+  uvSize=ySize/2;
+  mvSize=uvSize/2;
+
+  nAlign=m_initInfo.nAddressAlignment;
+  if(nAlign>1)
+  {
+    ySize=Align(ySize,nAlign);
+    uvSize=Align(uvSize,nAlign);
+  }
+
+  m_outputBuffers = new CDVDVideoCodecIMXBuffer*[m_vpuFrameBufferNum];
+
+  for (int i=0 ; i < m_vpuFrameBufferNum; i++)
+  {
+    totalSize=(ySize+uvSize+mvSize+nAlign)*1;
+
+    vpuMem.nSize=totalSize;
+    ret = VPU_DecGetMem(&vpuMem);
+    if(ret != VPU_DEC_RET_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s: vpu malloc frame buf failure: ret=%d \r\n",__FUNCTION__,ret);
+      return false;
+    }
+
+    //record memory info for release
+    m_decMemInfo.phyMem_phyAddr[m_decMemInfo.nPhyNum]=vpuMem.nPhyAddr;
+    m_decMemInfo.phyMem_virtAddr[m_decMemInfo.nPhyNum]=vpuMem.nVirtAddr;
+    m_decMemInfo.phyMem_cpuAddr[m_decMemInfo.nPhyNum]=vpuMem.nCpuAddr;
+    m_decMemInfo.phyMem_size[m_decMemInfo.nPhyNum]=vpuMem.nSize;
+    m_decMemInfo.nPhyNum++;
+
+    //fill frameBuf
+    ptr=(unsigned char*)vpuMem.nPhyAddr;
+    ptrVirt=(unsigned char*)vpuMem.nVirtAddr;
+
+    //align the base address
+    if(nAlign>1)
+    {
+      ptr=(unsigned char*)Align(ptr,nAlign);
+      ptrVirt=(unsigned char*)Align(ptrVirt,nAlign);
+    }
+
+    // fill stride info
+    m_vpuFrameBuffers[i].nStrideY=yStride;
+    m_vpuFrameBuffers[i].nStrideC=uvStride;
+
+    // fill phy addr
+    m_vpuFrameBuffers[i].pbufY=ptr;
+    m_vpuFrameBuffers[i].pbufCb=ptr+ySize;
+    m_vpuFrameBuffers[i].pbufCr=0;
+    m_vpuFrameBuffers[i].pbufMvCol=ptr+ySize+uvSize;
+    //ptr+=ySize+uSize+vSize+mvSize;
+    // fill virt addr
+    m_vpuFrameBuffers[i].pbufVirtY=ptrVirt;
+    m_vpuFrameBuffers[i].pbufVirtCb=ptrVirt+ySize;
+    m_vpuFrameBuffers[i].pbufVirtCr=0;
+    m_vpuFrameBuffers[i].pbufVirtMvCol=ptrVirt+ySize+uvSize;
+    //ptrVirt+=ySize+uSize+vSize+mvSize;
+
+    m_vpuFrameBuffers[i].pbufY_tilebot=0;
+    m_vpuFrameBuffers[i].pbufCb_tilebot=0;
+    m_vpuFrameBuffers[i].pbufVirtY_tilebot=0;
+    m_vpuFrameBuffers[i].pbufVirtCb_tilebot=0;
+
+#ifdef TRACE_FRAMES
+    m_outputBuffers[i] = new CDVDVideoCodecIMXBuffer(i);
+#else
+    m_outputBuffers[i] = new CDVDVideoCodecIMXBuffer();
+#endif
+  }
+
+  return true;
+}
+
+CDVDVideoCodecIMX::CDVDVideoCodecIMX()
+{
+  m_vpuHandle = 0;
+  m_pFormatName = "iMX-xxx";
+  memset(&m_decMemInfo, 0, sizeof(DecMemInfo));
+  m_vpuHandle = 0;
+  m_vpuFrameBuffers = NULL;
+  m_outputBuffers = NULL;
+  m_extraMem = NULL;
+  m_vpuFrameBufferNum = 0;
+  m_dropState = false;
+  m_convert_bitstream = false;
+  m_frameCounter = 0;
+  m_usePTS = true;
+  if (getenv("IMX_NOPTS") != NULL)
+  {
+    m_usePTS = false;
+  }
+  m_converter = NULL;
+  m_convert_bitstream = false;
+}
+
+CDVDVideoCodecIMX::~CDVDVideoCodecIMX()
+{
+  Dispose();
+}
+
+bool CDVDVideoCodecIMX::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  if (hints.software)
+  {
+    CLog::Log(LOGNOTICE, "iMX VPU : software decoding requested.\n");
+    return false;
+  }
+
+  m_hints = hints;
+  CLog::Log(LOGDEBUG, "Let's decode with iMX VPU\n");
+
+#ifdef MEDIAINFO
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: fpsrate %d / fpsscale %d\n", m_hints.fpsrate, m_hints.fpsscale);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: CodecID %d \n", m_hints.codec);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: StreamType %d \n", m_hints.type);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Level %d \n", m_hints.level);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Profile %d \n", m_hints.profile);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: PTS_invalid %d \n", m_hints.ptsinvalid);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Tag %d \n", m_hints.codec_tag);
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: %dx%d \n", m_hints.width,  m_hints.height);
+  { uint8_t *pb = (uint8_t*)&m_hints.codec_tag;
+    if (isalnum(pb[0]) && isalnum(pb[1]) && isalnum(pb[2]) && isalnum(pb[3]))
+      CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: Tag fourcc %c%c%c%c\n", pb[0], pb[1], pb[2], pb[3]);
+  }
+  if (m_hints.extrasize)
+  {
+    char buf[4096];
+
+    for (int i=0; i < m_hints.extrasize; i++)
+      sprintf(buf+i*2, "%02x", ((uint8_t*)m_hints.extradata)[i]);
+    CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: extradata %d %s\n", m_hints.extrasize, buf);
+  }
+  CLog::Log(LOGDEBUG, "Decode: MEDIAINFO: %d / %d \n", m_hints.width,  m_hints.height);
+  CLog::Log(LOGDEBUG, "Decode: aspect %f - forced aspect %d\n", m_hints.aspect, m_hints.forced_aspect);
+#endif
+
+  m_convert_bitstream = false;
+  switch(m_hints.codec)
+  {
+  case CODEC_ID_MPEG2VIDEO:
+  case CODEC_ID_MPEG2VIDEO_XVMC:
+    m_decOpenParam.CodecFormat = VPU_V_MPEG2;
+    m_pFormatName = "iMX-mpeg2";
+    break;
+  case CODEC_ID_H263:
+    m_decOpenParam.CodecFormat = VPU_V_H263;
+    m_pFormatName = "iMX-h263";
+    break;
+  case CODEC_ID_H264:
+    m_decOpenParam.CodecFormat = VPU_V_AVC;
+    m_pFormatName = "iMX-h264";
+    if (hints.extradata)
+    {
+      if ( *(char*)hints.extradata == 1 )
+      {
+        m_converter         = new CBitstreamConverter();
+        m_convert_bitstream = m_converter->Open(hints.codec, (uint8_t *)hints.extradata, hints.extrasize, true);
+      }
+    }
+    break;
+  case CODEC_ID_VC1:
+    m_decOpenParam.CodecFormat = VPU_V_VC1_AP;
+    m_pFormatName = "iMX-vc1";
+    break;
+/* FIXME TODO
+ * => for this type we have to set height, width, nChromaInterleave and nMapType
+  case CODEC_ID_MJPEG:
+    m_decOpenParam.CodecFormat = VPU_V_MJPG;
+    m_pFormatName = "iMX-mjpg";
+    break;*/
+  case CODEC_ID_CAVS:
+  case CODEC_ID_AVS:
+    m_decOpenParam.CodecFormat = VPU_V_AVS;
+    m_pFormatName = "iMX-AVS";
+    break;
+  case CODEC_ID_RV10:
+  case CODEC_ID_RV20:
+  case CODEC_ID_RV30:
+  case CODEC_ID_RV40:
+    m_decOpenParam.CodecFormat = VPU_V_RV;
+    m_pFormatName = "iMX-RV";
+    break;
+  case CODEC_ID_KMVC:
+    m_decOpenParam.CodecFormat = VPU_V_AVC_MVC;
+    m_pFormatName = "iMX-MVC";
+    break;
+  case CODEC_ID_VP8:
+    m_decOpenParam.CodecFormat = VPU_V_VP8;
+    m_pFormatName = "iMX-vp8";
+    break;
+  case CODEC_ID_MSMPEG4V3:
+    m_decOpenParam.CodecFormat = VPU_V_XVID; // VPU_V_DIVX3
+    m_pFormatName = "iMX-divx3";
+    break;
+  case CODEC_ID_MPEG4:
+    switch(m_hints.codec_tag)
+    {
+    case _4CC('D','I','V','X'):
+      m_decOpenParam.CodecFormat = VPU_V_XVID; // VPU_V_DIVX4
+      m_pFormatName = "iMX-divx4";
+      break;
+    case _4CC('D','X','5','0'):
+    case _4CC('D','I','V','5'):
+      m_decOpenParam.CodecFormat = VPU_V_XVID; // VPU_V_DIVX56
+      m_pFormatName = "iMX-divx5";
+      break;
+    case _4CC('X','V','I','D'):
+    case _4CC('M','P','4','V'):
+    case _4CC('P','M','P','4'):
+    case _4CC('F','M','P','4'):
+      m_decOpenParam.CodecFormat = VPU_V_XVID;
+      m_pFormatName = "iMX-xvid";
+      break;
+    default:
+      CLog::Log(LOGERROR, "iMX VPU : MPEG4 codec tag %d is not (yet) handled.\n", m_hints.codec_tag);
+      return false;
+    }
+    break;
+  default:
+    CLog::Log(LOGERROR, "iMX VPU : codecid %d is not (yet) handled.\n", m_hints.codec);
+    return false;
+  }
+
+  return true;
+}
+
+void CDVDVideoCodecIMX::Dispose(void)
+{
+  VpuDecRetCode  ret;
+  bool VPU_loaded = m_vpuHandle;
+
+  // Invalidate output buffers to prevent the renderer from mapping this memory
+  for (int i=0; i<m_vpuFrameBufferNum; i++)
+  {
+    m_outputBuffers[i]->ReleaseFramebuffer(&m_vpuHandle);
+    SAFE_RELEASE(m_outputBuffers[i]);
+  }
+
+  if (m_vpuHandle)
+  {
+    ret = VPU_DecFlushAll(m_vpuHandle);
+    if (ret != VPU_DEC_RET_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s - VPU flush failed with error code %d.\n", __FUNCTION__, ret);
+    }
+    ret = VPU_DecClose(m_vpuHandle);
+    if (ret != VPU_DEC_RET_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s - VPU close failed with error code %d.\n", __FUNCTION__, ret);
+    }
+    m_vpuHandle = 0;
+  }
+
+  // Clear pts queue
+  while(!m_pts.empty())
+    m_pts.pop();
+
+  // Clear memory
+  if (m_outputBuffers != NULL)
+  {
+    delete m_outputBuffers;
+    m_outputBuffers = NULL;
+  }
+
+  VpuFreeBuffers();
+  m_vpuFrameBufferNum = 0;
+
+  if (m_vpuFrameBuffers != NULL)
+  {
+    delete m_vpuFrameBuffers;
+    m_vpuFrameBuffers = NULL;
+  }
+
+  if (VPU_loaded)
+  {
+    ret = VPU_DecUnLoad();
+    if (ret != VPU_DEC_RET_SUCCESS)
+    {
+      CLog::Log(LOGERROR, "%s - VPU unload failed with error code %d.\n", __FUNCTION__, ret);
+    }
+  }
+
+  if (m_converter)
+  {
+    m_converter->Close();
+    SAFE_DELETE(m_converter);
+  }
+  return;
+}
+
+int CDVDVideoCodecIMX::Decode(BYTE *pData, int iSize, double dts, double pts)
+{
+  VpuDecFrameLengthInfo frameLengthInfo;
+  VpuBufferNode inData;
+  VpuDecRetCode ret;
+  int decRet = 0;
+  int retStatus = 0;
+  int demuxer_bytes = iSize;
+  uint8_t *demuxer_content = pData;
+  bool retry = false;
+
+#ifdef IMX_PROFILE
+  static unsigned long long previous, current;
+  unsigned long long before_dec;
+#endif
+
+  if (!m_vpuHandle)
+  {
+    VpuOpen();
+    if (!m_vpuHandle)
+      return VC_ERROR;
+  }
+
+  for (int i=0; i < m_vpuFrameBufferNum; i++)
+  {
+    if (m_outputBuffers[i]->Rendered())
+    {
+      ret = m_outputBuffers[i]->ReleaseFramebuffer(&m_vpuHandle);
+      if(ret != VPU_DEC_RET_SUCCESS)
+      {
+        CLog::Log(LOGERROR, "%s: vpu clear frame display failure: ret=%d \r\n",__FUNCTION__,ret);
+      }
+    }
+  }
+
+#ifdef IMX_PROFILE
+  current = XbmcThreads::SystemClockMillis();
+  CLog::Log(LOGDEBUG, "%s - delta time decode : %llu - demux size : %d  dts : %f - pts : %f\n", __FUNCTION__, current - previous, iSize, dts, pts);
+  previous = current;
+#endif
+
+/* FIXME tests
+  CLog::Log(LOGDEBUG, "%s - demux size : %d  dts : %f - pts : %f - %x %x %x %x\n", __FUNCTION__, iSize, dts, pts, ((unsigned int *)pData)[0], ((unsigned int *)pData)[1], ((unsigned int *)pData)[2], ((unsigned int *)pData)[3]);
+  ((unsigned int *)pData)[0] = htonl(iSize-4);
+*/
+
+  if (pData && iSize)
+  {
+    if (m_convert_bitstream)
+    {
+      // convert demuxer packet from bitstream to bytestream (AnnexB)
+      if (m_converter->Convert(demuxer_content, demuxer_bytes))
+      {
+        demuxer_content = m_converter->GetConvertBuffer();
+        demuxer_bytes = m_converter->GetConvertSize();
+      }
+      else
+        CLog::Log(LOGERROR,"%s - bitstream_convert error", __FUNCTION__);
+    }
+
+    if (m_usePTS)
+    {        
+      if (pts != DVD_NOPTS_VALUE)
+        m_pts.push(-pts);
+      else if (dts !=  DVD_NOPTS_VALUE)
+        m_pts.push(-dts);
+    }
+
+    inData.nSize = demuxer_bytes;
+    inData.pPhyAddr = NULL;
+    inData.pVirAddr = demuxer_content;
+    // FIXME TODO VP8 & DivX3 require specific sCodecData values
+    if ((m_decOpenParam.CodecFormat == VPU_V_MPEG2) ||
+        (m_decOpenParam.CodecFormat == VPU_V_VC1_AP)||
+        (m_decOpenParam.CodecFormat == VPU_V_XVID))
+    {
+      inData.sCodecData.pData = (unsigned char *)m_hints.extradata;
+      inData.sCodecData.nSize = m_hints.extrasize;
+    }
+    else
+    {
+      inData.sCodecData.pData = NULL;
+      inData.sCodecData.nSize = 0;
+    }
+
+    do // Decode as long as the VPU consumes data
+    {
+      retry = false;
+#ifdef IMX_PROFILE
+      before_dec = XbmcThreads::SystemClockMillis();
+#endif
+      ret = VPU_DecDecodeBuf(m_vpuHandle, &inData, &decRet);
+#ifdef IMX_PROFILE
+        CLog::Log(LOGDEBUG, "%s - VPU dec 0x%x decode takes : %lld\n\n", __FUNCTION__, decRet,  XbmcThreads::SystemClockMillis() - before_dec);
+#endif
+
+      if (ret != VPU_DEC_RET_SUCCESS)
+      {
+        CLog::Log(LOGERROR, "%s - VPU decode failed with error code %d.\n", __FUNCTION__, ret);
+        goto out_error;
+      }
+
+      if (decRet & VPU_DEC_INIT_OK)
+      // VPU decoding init OK : We can retrieve stream info
+      {
+        ret = VPU_DecGetInitialInfo(m_vpuHandle, &m_initInfo);
+        if (ret == VPU_DEC_RET_SUCCESS)
+        {
+          CLog::Log(LOGDEBUG, "%s - VPU Init Stream Info : %dx%d (interlaced : %d - Minframe : %d)"\
+                    " - Align : %d bytes - crop : %d %d %d %d - Q16Ratio : %x\n", __FUNCTION__,
+            m_initInfo.nPicWidth, m_initInfo.nPicHeight, m_initInfo.nInterlace, m_initInfo.nMinFrameBufferCount,
+            m_initInfo.nAddressAlignment, m_initInfo.PicCropRect.nLeft, m_initInfo.PicCropRect.nTop,
+            m_initInfo.PicCropRect.nRight, m_initInfo.PicCropRect.nBottom, m_initInfo.nQ16ShiftWidthDivHeightRatio);
+          if (VpuAllocFrameBuffers())
+          {
+            ret = VPU_DecRegisterFrameBuffer(m_vpuHandle, m_vpuFrameBuffers, m_vpuFrameBufferNum);
+            if (ret != VPU_DEC_RET_SUCCESS)
+            {
+              CLog::Log(LOGERROR, "%s - VPU error while registering frame buffers (%d).\n", __FUNCTION__, ret);
+              goto out_error;
+            }
+          }
+          else
+          {
+            goto out_error;
+          }
+        }
+        else
+        {
+          CLog::Log(LOGERROR, "%s - VPU get initial info failed (%d).\n", __FUNCTION__, ret);
+          goto out_error;
+        }
+      } //VPU_DEC_INIT_OK
+
+      if (decRet & VPU_DEC_ONE_FRM_CONSUMED)
+      {
+        ret = VPU_DecGetConsumedFrameInfo(m_vpuHandle, &frameLengthInfo);
+        if (ret != VPU_DEC_RET_SUCCESS)
+          CLog::Log(LOGERROR, "%s - VPU error retireving info about consummed frame (%d).\n", __FUNCTION__, ret);
+      } //VPU_DEC_ONE_FRM_CONSUMED
+
+      if ((decRet & VPU_DEC_OUTPUT_DIS) ||
+          (decRet & VPU_DEC_OUTPUT_MOSAIC_DIS))
+      // Frame ready to be displayed
+      {
+        if (retStatus & VC_PICTURE)
+            CLog::Log(LOGERROR, "%s - Second picture in the same decode call !\n", __FUNCTION__);
+
+        ret = VPU_DecGetOutputFrame(m_vpuHandle, &m_frameInfo);
+        if(ret != VPU_DEC_RET_SUCCESS)
+        {
+          CLog::Log(LOGERROR, "%s - VPU Cannot get output frame(%d).\n", __FUNCTION__, ret);
+          goto out_error;
+        }
+        retStatus |= VC_PICTURE;
+      } //VPU_DEC_OUTPUT_DIS
+
+      if (decRet & VPU_DEC_OUTPUT_REPEAT)
+      {
+        CLog::Log(LOGDEBUG, "%s - Frame repeat.\n", __FUNCTION__);
+      }
+      if (decRet & VPU_DEC_OUTPUT_DROPPED)
+      {
+        CLog::Log(LOGDEBUG, "%s - Frame dropped.\n", __FUNCTION__);
+      }
+      if (decRet & VPU_DEC_NO_ENOUGH_BUF)
+      {
+          CLog::Log(LOGERROR, "%s - No frame buffer available.\n", __FUNCTION__);
+      }
+      if (decRet & VPU_DEC_SKIP)
+      {
+        CLog::Log(LOGDEBUG, "%s - Frame skipped.\n", __FUNCTION__);
+      }
+      if (decRet & VPU_DEC_FLUSH)
+      {
+        CLog::Log(LOGNOTICE, "%s - VPU requires a flush.\n", __FUNCTION__);
+        ret = VPU_DecFlushAll(m_vpuHandle);
+        if (ret != VPU_DEC_RET_SUCCESS)
+        {
+          CLog::Log(LOGERROR, "%s - VPU flush failed(%d).\n", __FUNCTION__, ret);
+        }
+        retStatus = VC_FLUSHED;
+      }
+      if (decRet & VPU_DEC_OUTPUT_EOS)
+      {
+        CLog::Log(LOGNOTICE, "%s - EOS encountered.\n", __FUNCTION__);
+      }
+      if (decRet & VPU_DEC_NO_ENOUGH_INBUF)
+      {
+        // We are done with VPU decoder that time
+        break;
+      }
+      if (!(decRet & VPU_DEC_INPUT_USED))
+      {
+        CLog::Log(LOGERROR, "%s - input not used : addr %p  size :%d!\n", __FUNCTION__, inData.pVirAddr, inData.nSize);
+      }
+
+      if (!(decRet & VPU_DEC_OUTPUT_DIS)  &&
+           (inData.nSize != 0))
+      {
+        // Let's process again as VPU_DEC_NO_ENOUGH_INBUF was not set
+        // and we don't have an image ready if we reach that point
+
+        inData.pVirAddr = NULL;
+        inData.nSize = 0;
+        retry = true;
+      }
+
+    } while (retry == true);
+  } //(pData && iSize)
+
+  if (retStatus == 0)
+  {
+    retStatus |= VC_BUFFER;
+  }
+
+#ifdef IMX_PROFILE
+  CLog::Log(LOGDEBUG, "%s - returns %x - duration %lld\n", __FUNCTION__, retStatus, XbmcThreads::SystemClockMillis() - previous);
+#endif
+  return retStatus;
+
+out_error:
+  return VC_ERROR;
+}
+
+void CDVDVideoCodecIMX::Reset()
+{
+  int ret;
+
+  CLog::Log(LOGDEBUG, "%s - called\n", __FUNCTION__);
+
+  // Clear pts queue
+  while(!m_pts.empty())
+    m_pts.pop();
+
+  // Invalidate all buffers
+  for(int i=0; i < m_vpuFrameBufferNum; i++)
+    m_outputBuffers[i]->ReleaseFramebuffer(&m_vpuHandle);
+
+  // Flush VPU
+  ret = VPU_DecFlushAll(m_vpuHandle);
+  if (ret != VPU_DEC_RET_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s - VPU flush failed with error code %d.\n", __FUNCTION__, ret);
+  }
+
+}
+
+unsigned CDVDVideoCodecIMX::GetAllowedReferences()
+{
+  return 3;
+}
+
+bool CDVDVideoCodecIMX::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  if (pDvdVideoPicture)
+  {
+    SAFE_RELEASE(pDvdVideoPicture->codecinfo);
+  }
+
+  return true;
+}
+
+bool CDVDVideoCodecIMX::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  pDvdVideoPicture->iFlags = DVP_FLAG_ALLOCATED;
+  if (m_dropState)
+    pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
+  else
+    pDvdVideoPicture->iFlags &= ~DVP_FLAG_DROPPED;
+
+  pDvdVideoPicture->format = RENDER_FMT_IMXMAP;
+  pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
+  pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  pDvdVideoPicture->iWidth = m_frameInfo.pExtInfo->FrmCropRect.nRight - m_frameInfo.pExtInfo->FrmCropRect.nLeft;
+  pDvdVideoPicture->iHeight = m_frameInfo.pExtInfo->FrmCropRect.nBottom - m_frameInfo.pExtInfo->FrmCropRect.nTop;
+
+  pDvdVideoPicture->iDisplayWidth = ((pDvdVideoPicture->iWidth * m_frameInfo.pExtInfo->nQ16ShiftWidthDivHeightRatio) + 32767) >> 16;
+  pDvdVideoPicture->iDisplayHeight = pDvdVideoPicture->iHeight;
+
+  int idx = VpuFindBuffer(m_frameInfo.pDisplayFrameBuf->pbufY);
+  if (idx != -1)
+  {
+    CDVDVideoCodecIMXBuffer *buffer = m_outputBuffers[idx];
+    if (m_usePTS)
+    {
+      if (m_pts.size())
+      {
+        pDvdVideoPicture->pts = -m_pts.top();
+        m_pts.pop();
+      }
+      else
+        CLog::Log(LOGERROR, "%s - logic error: no PTS available", __FUNCTION__);
+    }
+
+    buffer->Queue(m_frameInfo.pDisplayFrameBuf);
+    pDvdVideoPicture->codecinfo = buffer;
+
+#ifdef TRACE_FRAMES
+    CLog::Log(LOGDEBUG, "+  %02d\n", idx);
+    CLog::Log(LOGDEBUG, "pts %f\n",pDvdVideoPicture->pts);
+#endif
+
+    pDvdVideoPicture->codecinfo->Lock();
+    pDvdVideoPicture->codecinfo->iWidth = m_frameInfo.pExtInfo->nFrmWidth;
+    pDvdVideoPicture->codecinfo->iHeight = m_frameInfo.pExtInfo->nFrmHeight;
+    pDvdVideoPicture->codecinfo->data[0] = m_frameInfo.pDisplayFrameBuf->pbufVirtY;
+    pDvdVideoPicture->codecinfo->data[1] = m_frameInfo.pDisplayFrameBuf->pbufY;
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "%s - could not find frame buffer\n", __FUNCTION__);
+  }
+
+  return true;
+}
+
+void CDVDVideoCodecIMX::SetDropState(bool bDrop)
+{
+
+  // We are fast enough to continue to really decode every frames
+  // and avoid artefacts...
+  // (Of course these frames won't be rendered but only decoded !)
+
+  if (m_dropState != bDrop)
+  {
+    m_dropState = bDrop;
+    CLog::Log(LOGNOTICE, "%s : %d\n", __FUNCTION__, bDrop);
+  }
+}
+
+/*******************************************/
+
+#ifdef TRACE_FRAMES
+CDVDVideoCodecIMXBuffer::CDVDVideoCodecIMXBuffer(int idx)
+  : m_refs(1)
+  , m_idx(idx)
+#else
+CDVDVideoCodecIMXBuffer::CDVDVideoCodecIMXBuffer()
+  : m_refs(1)
+#endif
+  , m_frameBuffer(NULL)
+  , m_rendered(false)
+{
+}
+
+void CDVDVideoCodecIMXBuffer::Lock()
+{
+#ifdef TRACE_FRAMES
+  long count = AtomicIncrement(&m_refs);
+  CLog::Log(LOGDEBUG, "R+ %02d  -  ref : %d\n", m_idx, count);
+#else
+  AtomicIncrement(&m_refs);
+#endif
+}
+
+long CDVDVideoCodecIMXBuffer::Release()
+{
+  long count = AtomicDecrement(&m_refs);
+#ifdef TRACE_FRAMES
+  CLog::Log(LOGDEBUG, "R- %02d  -  ref : %d\n", m_idx, count);
+#endif
+  if (count == 1)
+  {
+    // If count drops to 1 then the only reference is being held by the codec
+    // that it can be released in the next Decode call.
+    if(m_frameBuffer != NULL)
+      m_rendered = true;
+#ifdef TRACE_FRAMES
+    CLog::Log(LOGDEBUG, "R  %02d\n", m_idx);
+#endif
+  }
+  else if (count == 0)
+  {
+#ifdef TRACE_FRAMES
+    CLog::Log(LOGDEBUG, "~  %02d\n", m_idx);
+#endif
+
+    delete this;
+  }
+
+  return count;
+}
+
+bool CDVDVideoCodecIMXBuffer::IsValid()
+{
+  CSingleLock lock(CDVDVideoCodecIMX::m_codecBufferLock);
+  return m_frameBuffer != NULL;
+}
+
+bool CDVDVideoCodecIMXBuffer::Rendered()
+{
+  return m_rendered;
+}
+
+void CDVDVideoCodecIMXBuffer::Queue(VpuFrameBuffer *buffer)
+{
+  CSingleLock lock(CDVDVideoCodecIMX::m_codecBufferLock);
+  m_frameBuffer = buffer;
+  m_rendered = false;
+}
+
+VpuDecRetCode CDVDVideoCodecIMXBuffer::ReleaseFramebuffer(VpuDecHandle *handle)
+{
+  CSingleLock lock(CDVDVideoCodecIMX::m_codecBufferLock);
+  VpuDecRetCode ret = VPU_DEC_RET_FAILURE;
+
+  if((m_frameBuffer != NULL) && *handle)
+  {
+    ret = VPU_DecOutFrameDisplayed(*handle, m_frameBuffer);
+    if(ret != VPU_DEC_RET_SUCCESS)
+      CLog::Log(LOGERROR, "%s: vpu clear frame display failure: ret=%d \r\n",__FUNCTION__,ret);
+  }
+#ifdef TRACE_FRAMES
+  CLog::Log(LOGDEBUG, "-  %02d\n", m_idx);
+#endif
+  m_rendered = false;
+  m_frameBuffer = NULL;
+  return ret;
+}
+
+CDVDVideoCodecIMXBuffer::~CDVDVideoCodecIMXBuffer()
+{
+  assert(m_refs == 0);
+}
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h	2014-02-21 23:11:23.791122324 +0100
@@ -0,0 +1,129 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <queue>
+#include <linux/videodev2.h>
+#include <imx-mm/vpu/vpu_wrapper.h>
+#include "DVDVideoCodec.h"
+#include "DVDStreamInfo.h"
+#include "DVDVideoCodecInfo.h"
+#include "threads/CriticalSection.h"
+#include "utils/BitstreamConverter.h"
+
+#include <queue>
+
+//#define IMX_PROFILE
+//#define TRACE_FRAMES
+
+// FIXME TODO Develop real proper CVPUBuffer class
+#define VPU_DEC_MAX_NUM_MEM_NUM 20
+typedef struct
+{
+  //virtual mem info
+  int nVirtNum;
+  unsigned int virtMem[VPU_DEC_MAX_NUM_MEM_NUM];
+
+  //phy mem info
+  int nPhyNum;
+  unsigned int phyMem_virtAddr[VPU_DEC_MAX_NUM_MEM_NUM];
+  unsigned int phyMem_phyAddr[VPU_DEC_MAX_NUM_MEM_NUM];
+  unsigned int phyMem_cpuAddr[VPU_DEC_MAX_NUM_MEM_NUM];
+  unsigned int phyMem_size[VPU_DEC_MAX_NUM_MEM_NUM];
+} DecMemInfo;
+
+class CDVDVideoCodecIMXBuffer : public CDVDVideoCodecBuffer
+{
+public:
+#ifdef TRACE_FRAMES
+  CDVDVideoCodecIMXBuffer(int idx);
+#else
+  CDVDVideoCodecIMXBuffer();
+#endif
+
+  // reference counting
+  virtual void       Lock();
+  virtual long       Release();
+  virtual bool       IsValid();
+
+  bool               Rendered();
+  void               Queue(VpuFrameBuffer *buffer);
+  VpuDecRetCode      ReleaseFramebuffer(VpuDecHandle *handle);
+
+protected:
+  // private because we are reference counted
+  virtual            ~CDVDVideoCodecIMXBuffer();
+
+#ifdef TRACE_FRAMES
+  int                 m_idx;
+#endif
+  long                m_refs;
+  VpuFrameBuffer     *m_frameBuffer;
+  bool                m_rendered;
+};
+
+class CDVDVideoCodecIMX : public CDVDVideoCodec
+{
+  friend class CDVDVideoCodecIMXBuffer;
+
+public:
+  CDVDVideoCodecIMX();
+  virtual ~CDVDVideoCodecIMX();
+
+  // Methods from CDVDVideoCodec which require overrides
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose(void);
+  virtual int  Decode(BYTE *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool ClearPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+  virtual unsigned GetAllowedReferences();
+
+protected:
+
+  bool VpuOpen(void);
+  bool VpuAllocBuffers(VpuMemInfo *);
+  bool VpuFreeBuffers(void);
+  bool VpuAllocFrameBuffers(void);
+  int  VpuFindBuffer(void *frameAddr);
+
+  static const int    m_extraVpuBuffers;   // Number of additional buffers for VPU
+  static CCriticalSection m_codecBufferLock;
+
+  CDVDStreamInfo      m_hints;             // Hints from demuxer at stream opening
+  const char         *m_pFormatName;       // Current decoder format name
+  VpuDecOpenParam     m_decOpenParam;      // Parameters required to call VPU_DecOpen
+  DecMemInfo          m_decMemInfo;        // VPU dedicated memory description
+  VpuDecHandle        m_vpuHandle;         // Handle for VPU library calls
+  VpuDecInitInfo      m_initInfo;          // Initial info returned from VPU at decoding start
+  bool                m_dropState;         // Current drop state
+  int                 m_vpuFrameBufferNum; // Total number of allocated frame buffers
+  VpuFrameBuffer     *m_vpuFrameBuffers;   // Table of VPU frame buffers description
+  CDVDVideoCodecIMXBuffer **m_outputBuffers;
+  VpuMemDesc         *m_extraMem;          // Table of allocated extra Memory
+//  VpuMemDesc         *m_outputBuffers;     // Table of buffers out of VPU (used to call properly VPU_DecOutFrameDisplayed)
+  int                 m_frameCounter;      // Decoded frames counter
+  bool                m_usePTS;            // State whether pts out of decoding process should be used
+  std::priority_queue<double>         m_pts;
+  VpuDecOutFrameInfo  m_frameInfo;
+  CBitstreamConverter *m_converter;
+  bool                m_convert_bitstream;
+};
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecInfo.h xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecInfo.h
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecInfo.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecInfo.h	2014-02-21 23:11:23.791122324 +0100
@@ -0,0 +1,38 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef DVDVIDEOCODECINFO_H
+#define DVDVIDEOCODECINFO_H
+
+class CDVDVideoCodecBuffer
+{
+public:
+  // reference counting
+  virtual void                Lock() = 0;
+  virtual long                Release() = 0;
+  virtual bool                IsValid() = 0;
+
+  uint32_t            iWidth;
+  uint32_t            iHeight;
+  uint8_t*            data[4];      // [4] = alpha channel, currently not used
+  int                 iLineSize[4];   // [4] = alpha channel, currently not used
+};
+
+#endif // DVDVIDEOCODECINFO_H
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in	2014-02-21 23:10:30.382097024 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in	2014-02-21 23:11:23.790122324 +0100
@@ -24,6 +24,9 @@
 SRCS += OpenMaxVideo.cpp
 SRCS += DVDVideoCodecOpenMax.cpp
 endif
+ifeq (@USE_IMXVPU@,1)
+SRCS += DVDVideoCodecIMX.cpp 
+endif
 ifeq (@USE_LIBAMCODEC@,1)
 SRCS += AMLCodec.cpp
 SRCS += DVDVideoCodecAmlogic.cpp
diff -Naur xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
--- xbmc-gotham-latest.test/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2014-02-21 23:10:30.530097095 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2014-02-21 23:11:23.794122325 +0100
@@ -995,6 +995,8 @@
     case RENDER_FMT_EGLIMG:    return "EGLIMG";
     case RENDER_FMT_BYPASS:    return "BYPASS";
     case RENDER_FMT_MEDIACODEC:return "MEDIACODEC";
+    case RENDER_FMT_YV12_BUFFER:     return "YV12BUF";
+    case RENDER_FMT_IMXMAP:    return "IMXMAP";
     case RENDER_FMT_NONE:      return "NONE";
   }
   return "UNKNOWN";
diff -Naur xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp xbmc-imx6-koying.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
--- xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2014-02-21 23:10:30.329096998 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2014-02-21 23:11:23.788122322 +0100
@@ -76,6 +76,15 @@
 static PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES;
 #endif
 
+#ifdef HAS_IMXVPU
+#include "windowing/egl/EGLWrapper.h"
+#define GL_VIV_NV12 0x8FC1
+typedef void (GL_APIENTRYP PFNGLTEXDIRECTVIVMAPPROC) (GLenum Target, GLsizei Width, GLsizei Height, GLenum Format, GLvoid ** Logical, const GLuint * Physical);
+typedef void (GL_APIENTRYP PFNGLTEXDIRECTINVALIDATEVIVPROC) (GLenum Target);
+static PFNGLTEXDIRECTVIVMAPPROC glTexDirectVIVMap;
+static PFNGLTEXDIRECTINVALIDATEVIVPROC glTexDirectInvalidateVIV;
+#endif
+
 #if defined(TARGET_ANDROID)
 #include "DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.h"
 #endif
@@ -100,6 +109,7 @@
 #if defined(TARGET_ANDROID)
   mediacodec = NULL;
 #endif
+  codecinfo = NULL;
 }
 
 CLinuxRendererGLES::YUVBUFFER::~YUVBUFFER()
@@ -151,6 +161,12 @@
   if (!glEGLImageTargetTexture2DOES)
     glEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC) CEGLWrapper::GetProcAddress("glEGLImageTargetTexture2DOES");
 #endif
+#ifdef HAS_IMXVPU
+  if (!glTexDirectVIVMap)
+    glTexDirectVIVMap = (PFNGLTEXDIRECTVIVMAPPROC) CEGLWrapper::GetProcAddress("glTexDirectVIVMap");
+  if (!glTexDirectInvalidateVIV)
+    glTexDirectInvalidateVIV = (PFNGLTEXDIRECTINVALIDATEVIVPROC) CEGLWrapper::GetProcAddress("glTexDirectInvalidateVIV");
+#endif
 }
 
 CLinuxRendererGLES::~CLinuxRendererGLES()
@@ -279,6 +295,10 @@
   {
     return source;
   }
+  if ( m_renderMethod & RENDER_IMXMAP )
+  {
+    return source;
+  }
 
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   if (m_renderMethod & RENDER_CVREF )
@@ -604,6 +624,10 @@
 #if defined(TARGET_ANDROID)
   m_formats.push_back(RENDER_FMT_MEDIACODEC);
 #endif
+  m_formats.push_back(RENDER_FMT_YV12_BUFFER);
+#ifdef HAS_IMXVPU
+  m_formats.push_back(RENDER_FMT_IMXMAP);
+#endif
 
   // setup the background colour
   m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
@@ -715,6 +739,16 @@
         m_renderMethod = RENDER_MEDIACODEC;
         break;
       }
+      else if (m_format == RENDER_FMT_YV12_BUFFER)
+      {
+        CLog::Log(LOGNOTICE, "GL: Using YV12 Buffer render method");
+      }
+      else if (m_format == RENDER_FMT_IMXMAP)
+      {
+        CLog::Log(LOGNOTICE, "GL: Using IMXMAP render method");
+        m_renderMethod = RENDER_IMXMAP;
+        break;
+      }
       else if (m_format == RENDER_FMT_BYPASS)
       {
         CLog::Log(LOGNOTICE, "GL: Using BYPASS render method");
@@ -807,6 +841,18 @@
     m_textureCreate = &CLinuxRendererGLES::CreateNV12Texture;
     m_textureDelete = &CLinuxRendererGLES::DeleteNV12Texture;
   }
+  else if (m_format == RENDER_FMT_YV12_BUFFER)
+  {
+    m_textureUpload = &CLinuxRendererGLES::UploadYV12BufferTexture;
+    m_textureCreate = &CLinuxRendererGLES::CreateYV12Texture;
+    m_textureDelete = &CLinuxRendererGLES::DeleteYV12Texture;
+  }
+  else if (m_format == RENDER_FMT_IMXMAP)
+  {
+    m_textureUpload = &CLinuxRendererGLES::UploadIMXMAPTexture;
+    m_textureCreate = &CLinuxRendererGLES::CreateIMXMAPTexture;
+    m_textureDelete = &CLinuxRendererGLES::DeleteIMXMAPTexture;
+  }
   else
   {
     // default to YV12 texture handlers
@@ -952,6 +998,10 @@
   {
     RenderSurfaceTexture(index, m_currentField);
   }
+  else if (m_renderMethod & RENDER_IMXMAP)
+  {
+    RenderIMXMAPTexture(index, m_currentField);
+  }
   else
   {
     RenderSoftware(index, m_currentField);
@@ -1156,7 +1206,7 @@
 //    imgwidth  *= planes[0].pixpertex_x;
 //    imgheight *= planes[0].pixpertex_y;
 //  }
-//  
+//
 //  glBegin(GL_QUADS);
 //
 //  glMultiTexCoord2fARB(GL_TEXTURE0, planes[0].rect.x1, planes[0].rect.y1);
@@ -1578,6 +1628,75 @@
 #endif
 }
 
+void CLinuxRendererGLES::RenderIMXMAPTexture(int index, int field)
+{
+#if defined(HAS_IMXVPU)
+#ifdef DEBUG_VERBOSE
+  unsigned int time = XbmcThreads::SystemClockMillis();
+#endif
+
+  YUVPLANE &plane = m_buffers[index].fields[field][0];
+  CDVDVideoCodecBuffer* codecinfo = m_buffers[index].codecinfo;
+
+  if((codecinfo == NULL) || !codecinfo->IsValid()) return;
+
+  glDisable(GL_DEPTH_TEST);
+
+  glActiveTexture(GL_TEXTURE0);
+  glBindTexture(m_textureTarget, plane.id);
+
+  g_Windowing.EnableGUIShader(SM_TEXTURE_RGBA);
+
+  GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
+  GLfloat ver[4][4];
+  GLfloat tex[4][2];
+  GLfloat col[3] = {1.0f, 1.0f, 1.0f};
+
+  GLint   posLoc = g_Windowing.GUIShaderGetPos();
+  GLint   texLoc = g_Windowing.GUIShaderGetCoord0();
+  GLint   colLoc = g_Windowing.GUIShaderGetCol();
+
+  glVertexAttribPointer(posLoc, 4, GL_FLOAT, 0, 0, ver);
+  glVertexAttribPointer(texLoc, 2, GL_FLOAT, 0, 0, tex);
+  glVertexAttribPointer(colLoc, 3, GL_FLOAT, 0, 0, col);
+
+  glEnableVertexAttribArray(posLoc);
+  glEnableVertexAttribArray(texLoc);
+  glEnableVertexAttribArray(colLoc);
+
+  // Set vertex coordinates
+  for(int i = 0; i < 4; i++)
+  {
+    ver[i][0] = m_rotatedDestCoords[i].x;
+    ver[i][1] = m_rotatedDestCoords[i].y;
+    ver[i][2] = 0.0f;// set z to 0
+    ver[i][3] = 1.0f;
+  }
+
+  // Set texture coordinates
+  tex[0][0] = tex[3][0] = plane.rect.x1;
+  tex[0][1] = tex[1][1] = plane.rect.y1;
+  tex[1][0] = tex[2][0] = plane.rect.x2;
+  tex[2][1] = tex[3][1] = plane.rect.y2;
+
+  glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, idx);
+
+  glDisableVertexAttribArray(posLoc);
+  glDisableVertexAttribArray(texLoc);
+  glDisableVertexAttribArray(colLoc);
+
+  g_Windowing.DisableGUIShader();
+  VerifyGLState();
+
+  glBindTexture(m_textureTarget, 0);
+  VerifyGLState();
+
+#ifdef DEBUG_VERBOSE
+  CLog::Log(LOGDEBUG, "RenderIMXMAPTexture %d: tm:%d\n", index, XbmcThreads::SystemClockMillis() - time);
+#endif
+#endif
+}
+
 bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
 {
   if (!m_bValidated)
@@ -2299,7 +2418,7 @@
 
   glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
   glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-	// This is necessary for non-power-of-two textures
+        // This is necessary for non-power-of-two textures
   glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
   glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
@@ -2405,7 +2524,7 @@
 
   glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
   glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-	// This is necessary for non-power-of-two textures
+        // This is necessary for non-power-of-two textures
   glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
   glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 
@@ -2479,6 +2598,84 @@
   return true;
 }
 
+//********************************************************************************************************
+// Buffer creation, deletion, copying + clearing
+//********************************************************************************************************
+void CLinuxRendererGLES::UploadYV12BufferTexture(int index)
+{
+  YUVBUFFER& buf    =  m_buffers[index];
+  YV12Image* im     =  &buf.image;
+  YUVFIELDS& fields =  buf.fields;
+
+  if (!buf.codecinfo || !(im->flags & IMAGE_FLAG_READY))
+    return;
+
+  bool deinterlacing;
+  if (m_currentField == FIELD_FULL)
+    deinterlacing = false;
+  else
+    deinterlacing = true;
+
+  glEnable(m_textureTarget);
+  VerifyGLState();
+
+  glPixelStorei(GL_UNPACK_ALIGNMENT,1);
+
+  if (deinterlacing)
+  {
+    // Load Even Y Field
+    LoadPlane( fields[FIELD_TOP][0] , GL_LUMINANCE, buf.flipindex
+        , im->width, im->height >> 1
+                                   , buf.codecinfo->iLineSize[0]*2, im->bpp, buf.codecinfo->data[0] );
+
+    // Load Odd Y fields
+    LoadPlane( fields[FIELD_BOT][0], GL_LUMINANCE, buf.flipindex
+        , im->width, im->height >> 1
+                                   , buf.codecinfo->iLineSize[0]*2, im->bpp, buf.codecinfo->data[0] + buf.codecinfo->iLineSize[0]) ;
+
+    // Load Even U & V Fields
+    LoadPlane( fields[FIELD_TOP][1], GL_LUMINANCE, buf.flipindex
+        , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+                                                   , buf.codecinfo->iLineSize[1]*2, im->bpp, buf.codecinfo->data[1] );
+
+    LoadPlane( fields[FIELD_TOP][2], GL_ALPHA, buf.flipindex
+        , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+                                                   , buf.codecinfo->iLineSize[2]*2, im->bpp, buf.codecinfo->data[2] );
+
+    // Load Odd U & V Fields
+    LoadPlane( fields[FIELD_BOT][1], GL_LUMINANCE, buf.flipindex
+        , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+                                                   , buf.codecinfo->iLineSize[1]*2, im->bpp, buf.codecinfo->data[1] + buf.codecinfo->iLineSize[1] );
+
+    LoadPlane( fields[FIELD_BOT][2], GL_ALPHA, buf.flipindex
+        , im->width >> im->cshift_x, im->height >> (im->cshift_y + 1)
+                                                   , buf.codecinfo->iLineSize[2]*2, im->bpp, buf.codecinfo->data[2] + buf.codecinfo->iLineSize[2] );
+  }
+  else
+  {
+    // Load Y plane
+    LoadPlane( fields[FIELD_FULL][0], GL_LUMINANCE, buf.flipindex
+        , im->width, im->height
+        , buf.codecinfo->iLineSize[0], im->bpp, buf.codecinfo->data[0] );
+
+    //load U plane
+    LoadPlane( fields[FIELD_FULL][1], GL_LUMINANCE, buf.flipindex
+        , im->width >> im->cshift_x, im->height >> im->cshift_y
+                                                   , buf.codecinfo->iLineSize[1], im->bpp, buf.codecinfo->data[1] );
+
+    //load V plane
+    LoadPlane( fields[FIELD_FULL][2], GL_ALPHA, buf.flipindex
+        , im->width >> im->cshift_x, im->height >> im->cshift_y
+                                                   , buf.codecinfo->iLineSize[2], im->bpp, buf.codecinfo->data[2] );
+  }
+
+  VerifyGLState();
+
+  CalculateTextureSourceRects(index, 3);
+
+  glDisable(m_textureTarget);
+}
+
 void CLinuxRendererGLES::SetTextureFilter(GLenum method)
 {
   for (int i = 0 ; i<m_NumYV12Buffers ; i++)
@@ -2508,6 +2705,82 @@
   }
 }
 
+//********************************************************************************************************
+// IMXMAP creation, deletion, copying + clearing
+//********************************************************************************************************
+void CLinuxRendererGLES::UploadIMXMAPTexture(int index)
+{
+#ifdef HAS_IMXVPU
+  YUVBUFFER& buf    =  m_buffers[index];
+  CDVDVideoCodecBuffer* codecinfo = buf.codecinfo;
+
+  if(codecinfo && codecinfo->IsValid())
+  {
+    YUVPLANE &plane = m_buffers[index].fields[0][0];
+
+    glActiveTexture(GL_TEXTURE0);
+    glBindTexture(m_textureTarget, plane.id);
+
+    GLuint physical = ~0U;
+    glTexDirectVIVMap(m_textureTarget, codecinfo->iWidth, codecinfo->iHeight, GL_VIV_NV12,
+                      (GLvoid **)(&codecinfo->data[0]), &physical);
+    glTexDirectInvalidateVIV(m_textureTarget);
+
+    glBindTexture(m_textureTarget, 0);
+
+    plane.flipindex = m_buffers[index].flipindex;
+    plane.texwidth  = codecinfo->iWidth;
+    plane.texheight = codecinfo->iHeight;
+
+    CalculateTextureSourceRects(index, 1);
+  }
+
+#endif
+}
+void CLinuxRendererGLES::DeleteIMXMAPTexture(int index)
+{
+  YUVBUFFER &buf = m_buffers[index];
+  YUVPLANE &plane = buf.fields[0][0];
+
+  if(plane.id && glIsTexture(plane.id))
+    glDeleteTextures(1, &plane.id);
+  plane.id = 0;
+
+  SAFE_RELEASE(buf.codecinfo);
+}
+bool CLinuxRendererGLES::CreateIMXMAPTexture(int index)
+{
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE  &plane  = fields[0][0];
+
+  DeleteEGLIMGTexture(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+
+  im.height = m_sourceHeight;
+  im.width  = m_sourceWidth;
+
+  plane.texwidth  = 0; // Must be actual frame width for pseudo-cropping
+  plane.texheight = 0; // Must be actual frame height for pseudo-cropping
+  plane.pixpertex_x = 1;
+  plane.pixpertex_y = 1;
+
+  glEnable(m_textureTarget);
+  glGenTextures(1, &plane.id);
+  VerifyGLState();
+
+  glBindTexture(m_textureTarget, plane.id);
+
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+  glDisable(m_textureTarget);
+  return true;
+}
+
+
 bool CLinuxRendererGLES::Supports(ERENDERFEATURE feature)
 {
   // Player controls render, let it dictate available render features
@@ -2737,5 +3010,16 @@
 }
 #endif
 
+void CLinuxRendererGLES::AddProcessor(CDVDVideoCodecBuffer *codecinfo, int index)
+{
+  YUVBUFFER &buf = m_buffers[index];
+
+  SAFE_RELEASE(buf.codecinfo);
+  buf.codecinfo = codecinfo;
+
+  if (codecinfo)
+    codecinfo->Lock();
+}
+
 #endif
 
diff -Naur xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.h xbmc-imx6-koying.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
--- xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2014-02-21 23:10:30.317096992 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2014-02-21 23:11:23.788122322 +0100
@@ -33,6 +33,7 @@
 #include "guilib/GraphicContext.h"
 #include "BaseRenderer.h"
 #include "xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecInfo.h"
 
 class CRenderCapture;
 
@@ -89,7 +90,8 @@
   RENDER_CVREF  = 0x080,
   RENDER_BYPASS = 0x100,
   RENDER_EGLIMG = 0x200,
-  RENDER_MEDIACODEC = 0x400
+  RENDER_MEDIACODEC = 0x400,
+  RENDER_IMXMAP = 0x800
 };
 
 enum RenderQuality
@@ -173,6 +175,7 @@
   // mediaCodec
   virtual void         AddProcessor(CDVDMediaCodecInfo *mediacodec, int index);
 #endif
+  virtual void         AddProcessor(CDVDVideoCodecBuffer *codecinfo, int index);
 
 protected:
   virtual void Render(DWORD flags, int index);
@@ -212,6 +215,12 @@
   void DeleteSurfaceTexture(int index);
   bool CreateSurfaceTexture(int index);
 
+  void UploadYV12BufferTexture(int index);
+
+  void UploadIMXMAPTexture(int index);
+  void DeleteIMXMAPTexture(int index);
+  bool CreateIMXMAPTexture(int index);
+
   void CalculateTextureSourceRects(int source, int num_planes);
 
   // renderers
@@ -222,6 +231,7 @@
   void RenderEglImage(int index, int field);       // Android OES texture
   void RenderCoreVideoRef(int index, int field);  // CoreVideo reference
   void RenderSurfaceTexture(int index, int field);// MediaCodec rendering using SurfaceTexture
+  void RenderIMXMAPTexture(int index, int field); // IMXMAP rendering
 
   CFrameBufferObject m_fbo;
 
@@ -288,6 +298,7 @@
     // mediacodec
     CDVDMediaCodecInfo *mediacodec;
 #endif
+    CDVDVideoCodecBuffer *codecinfo;
   };
 
   typedef YUVBUFFER          YUVBUFFERS[NUM_BUFFERS];
diff -Naur xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/RenderFormats.h xbmc-imx6-koying.test/xbmc/cores/VideoRenderers/RenderFormats.h
--- xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/RenderFormats.h	2014-02-21 23:10:30.318096992 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/VideoRenderers/RenderFormats.h	2014-02-21 23:11:23.788122322 +0100
@@ -37,6 +37,8 @@
   RENDER_FMT_BYPASS,
   RENDER_FMT_EGLIMG,
   RENDER_FMT_MEDIACODEC,
+  RENDER_FMT_YV12_BUFFER,
+  RENDER_FMT_IMXMAP,
 };
 
 #endif
diff -Naur xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/RenderManager.cpp xbmc-imx6-koying.test/xbmc/cores/VideoRenderers/RenderManager.cpp
--- xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/RenderManager.cpp	2014-02-21 23:10:30.318096992 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/VideoRenderers/RenderManager.cpp	2014-02-21 23:11:23.788122322 +0100
@@ -928,6 +928,8 @@
   else if(pic.format == RENDER_FMT_MEDIACODEC)
     m_pRenderer->AddProcessor(pic.mediacodec, index);
 #endif
+  else if(pic.format == RENDER_FMT_YV12_BUFFER || pic.format == RENDER_FMT_IMXMAP)
+    m_pRenderer->AddProcessor(pic.codecinfo, index);
 
   m_pRenderer->ReleaseImage(index, false);
 
diff -Naur xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp xbmc-imx6-koying.test/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
--- xbmc-gotham-latest.test/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp	2014-02-21 23:10:30.315096991 +0100
+++ xbmc-imx6-koying.test/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp	2014-02-21 23:11:23.788122322 +0100
@@ -39,12 +39,12 @@
 //
 // Transformation matrixes for different colorspaces.
 //
-static float yuv_coef_bt601[4][4] = 
+static float yuv_coef_bt601[4][4] =
 {
     { 1.0f,      1.0f,     1.0f,     0.0f },
     { 0.0f,     -0.344f,   1.773f,   0.0f },
     { 1.403f,   -0.714f,   0.0f,     0.0f },
-    { 0.0f,      0.0f,     0.0f,     0.0f } 
+    { 0.0f,      0.0f,     0.0f,     0.0f }
 };
 
 static float yuv_coef_bt709[4][4] =
@@ -55,7 +55,7 @@
     { 0.0f,      0.0f,     0.0f,     0.0f }
 };
 
-static float yuv_coef_ebu[4][4] = 
+static float yuv_coef_ebu[4][4] =
 {
     { 1.0f,      1.0f,     1.0f,     0.0f },
     { 0.0f,     -0.3960f,  2.029f,   0.0f },
@@ -74,19 +74,19 @@
 static float** PickYUVConversionMatrix(unsigned flags)
 {
   // Pick the matrix.
-   
+
    switch(CONF_FLAGS_YUVCOEF_MASK(flags))
    {
      case CONF_FLAGS_YUVCOEF_240M:
        return (float**)yuv_coef_smtp240m; break;
      case CONF_FLAGS_YUVCOEF_BT709:
        return (float**)yuv_coef_bt709; break;
-     case CONF_FLAGS_YUVCOEF_BT601:    
+     case CONF_FLAGS_YUVCOEF_BT601:
        return (float**)yuv_coef_bt601; break;
      case CONF_FLAGS_YUVCOEF_EBU:
        return (float**)yuv_coef_ebu; break;
    }
-   
+
    return (float**)yuv_coef_bt601;
 }
 
@@ -228,7 +228,7 @@
   m_hProj   = -1;
   m_hModel  = -1;
   m_hAlpha  = -1;
-  if (m_format == RENDER_FMT_YUV420P)
+  if (m_format == RENDER_FMT_YUV420P || m_format == RENDER_FMT_YV12_BUFFER)
     m_defines += "#define XBMC_YV12\n";
   else if (m_format == RENDER_FMT_NV12)
     m_defines += "#define XBMC_NV12\n";
diff -Naur xbmc-gotham-latest.test/xbmc/input/linux/LinuxInputDevices.cpp xbmc-imx6-koying.test/xbmc/input/linux/LinuxInputDevices.cpp
--- xbmc-gotham-latest.test/xbmc/input/linux/LinuxInputDevices.cpp	2014-02-21 23:10:27.131095441 +0100
+++ xbmc-imx6-koying.test/xbmc/input/linux/LinuxInputDevices.cpp	2014-02-21 23:11:23.525122201 +0100
@@ -1222,7 +1222,8 @@
 
     if ((now - m_lastHotplugCheck) >= 10)
     {
-      CheckHotplugged();
+      // Comment for now as it has visible issue on video decoding when USB devices are available
+      //CheckHotplugged();
       m_lastHotplugCheck = now;
     }
   }
diff -Naur xbmc-gotham-latest.test/xbmc/powermanagement/PowerManager.cpp xbmc-imx6-koying.test/xbmc/powermanagement/PowerManager.cpp
diff -Naur xbmc-gotham-latest.test/xbmc/windowing/egl/EGLNativeTypeIMX.cpp xbmc-imx6-koying.test/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
--- xbmc-gotham-latest.test/xbmc/windowing/egl/EGLNativeTypeIMX.cpp	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-imx6-koying.test/xbmc/windowing/egl/EGLNativeTypeIMX.cpp	2014-02-21 23:11:23.780122319 +0100
@@ -0,0 +1,300 @@
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/mxcfb.h>
+#include "system.h"
+#include <EGL/egl.h>
+
+#include "EGLNativeTypeIMX.h"
+#include <math.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include "utils/log.h"
+#include "utils/RegExp.h"
+#include "utils/StringUtils.h"
+#include "utils/Environment.h"
+#include "guilib/gui3d.h"
+#include "windowing/WindowingFactory.h"
+
+CEGLNativeTypeIMX::CEGLNativeTypeIMX()
+{
+}
+
+CEGLNativeTypeIMX::~CEGLNativeTypeIMX()
+{
+}
+
+bool CEGLNativeTypeIMX::CheckCompatibility()
+{
+  char name[256] = {0};
+  get_sysfs_str("/sys/class/graphics/fb0/device/modalias", name, 255);
+  CStdString strName = name;
+  StringUtils::Trim(strName);
+  if (strName == "platform:mxc_sdc_fb")
+    return true;
+  return false;
+}
+
+void CEGLNativeTypeIMX::Initialize()
+{
+  int fd;
+
+  fd = open("/dev/fb0",O_RDWR);
+  if (fd < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while opening /dev/fb0.\n", __FUNCTION__);
+    return;
+  }
+
+  // Unblank the fbs
+  if (ioctl(fd, FBIOBLANK, 0) < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while unblanking fb0.\n", __FUNCTION__);
+  }
+
+  close(fd);
+
+  fd = open("/sys/class/graphics/fb0/mode", O_RDWR);
+  if (fd >= 0)
+  {
+    CLog::Log(LOGNOTICE, "%s - graphics sysfs is writable", __FUNCTION__);
+    m_readonly = false;
+  }
+  else
+  {
+    CLog::Log(LOGNOTICE, "%s - graphics sysfs is read-only", __FUNCTION__);
+    m_readonly = true;
+  }
+  close(fd);
+
+  return;
+}
+
+void CEGLNativeTypeIMX::Destroy()
+{
+  struct fb_fix_screeninfo fixed_info;
+  void *fb_buffer;
+  int fd;
+
+  fd = open("/dev/fb0",O_RDWR);
+  if (fd < 0)
+  {
+    CLog::Log(LOGERROR, "%s - Error while opening /dev/fb0.\n", __FUNCTION__);
+    return;
+  }
+
+  ioctl( fd, FBIOGET_FSCREENINFO, &fixed_info);
+  // Black fb0
+  fb_buffer = mmap(NULL, fixed_info.smem_len, PROT_WRITE, MAP_SHARED, fd, 0);
+  if (fb_buffer == MAP_FAILED)
+  {
+    CLog::Log(LOGERROR, "%s - fb mmap failed %s.\n", __FUNCTION__, strerror(errno));
+  }
+  else
+  {
+    memset(fb_buffer, 0x0, fixed_info.smem_len);
+    munmap(fb_buffer, fixed_info.smem_len);
+  }
+
+  close(fd);
+
+  return;
+}
+
+bool CEGLNativeTypeIMX::CreateNativeDisplay()
+{
+  // EGL will be rendered on fb0
+  m_display = fbGetDisplayByIndex(0);
+  m_nativeDisplay = &m_display;
+  return true;
+}
+
+bool CEGLNativeTypeIMX::CreateNativeWindow()
+{
+  m_window = fbCreateWindow(m_display, 0, 0, 0, 0);
+  m_nativeWindow = &m_window;
+  return true;
+}
+
+bool CEGLNativeTypeIMX::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType*)m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeIMX::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType*)m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeIMX::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeIMX::DestroyNativeWindow()
+{
+  return true;
+}
+
+bool CEGLNativeTypeIMX::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  char mode[256] = {0};
+  get_sysfs_str("/sys/class/graphics/fb0/mode", mode, 255);
+  return ModeToResolution(mode, res);
+}
+
+bool CEGLNativeTypeIMX::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  if (m_readonly)
+    return false;
+
+  set_sysfs_str("/sys/class/graphics/fb0/blank", "1");
+  set_sysfs_str("/sys/class/graphics/fb0/mode", res.strId.c_str());
+  set_sysfs_str("/sys/class/graphics/fb0/blank", "0");
+
+  return true;
+}
+
+bool CEGLNativeTypeIMX::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  if (m_readonly)
+    return false;
+
+  char valstr[256] = {0};
+  get_sysfs_str("/sys/class/graphics/fb0/modes", valstr, 255);
+  std::vector<CStdString> probe_str;
+  StringUtils::SplitString(valstr, "\n", probe_str);
+
+  resolutions.clear();
+  RESOLUTION_INFO res;
+  for (size_t i = 0; i < probe_str.size(); i++)
+  {
+    if(!StringUtils::StartsWith(probe_str[i], "U:")) // && !StringUtils::StartsWith(mode, "S:"))
+      continue;
+    if(ModeToResolution(probe_str[i].c_str(), &res))
+      resolutions.push_back(res);
+  }
+  return resolutions.size() > 0;
+}
+
+bool CEGLNativeTypeIMX::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  return GetNativeResolution(res);
+}
+
+bool CEGLNativeTypeIMX::ShowWindow(bool show)
+{
+  // Force vsync depending on FB_MULTI_BUFFER
+  EGLBoolean status;
+  EGLint result;
+
+  std::string fb_buffers = CEnvironment::getenv("FB_MULTI_BUFFER");
+  if (fb_buffers.empty())
+    status = eglSwapInterval(g_Windowing.GetEGLDisplay(), 0);
+  else
+  {
+    CLog::Log(LOGNOTICE, "%s - FB_MULTI_BUFFER is set",__FUNCTION__);
+    status = eglSwapInterval(g_Windowing.GetEGLDisplay(), 1);
+  }
+  result = eglGetError();
+  if(result != EGL_SUCCESS)
+    CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, result);
+
+  return false;
+}
+
+int CEGLNativeTypeIMX::get_sysfs_str(const char *path, char *valstr, const int size) const
+{
+  int fd = open(path, O_RDONLY);
+  if (fd >= 0)
+  {
+    int len = read(fd, valstr, size - 1);
+    if (len != -1 )
+      valstr[len] = '\0';
+    close(fd);
+  }
+  else
+  {
+    sprintf(valstr, "%s", "fail");
+    return -1;
+  }
+  return 0;
+}
+
+int CEGLNativeTypeIMX::set_sysfs_str(const char *path, const char *val)
+{
+  int fd = open(path, O_RDWR);
+  if (fd >= 0)
+  {
+    write(fd, val, strlen(val));
+    close(fd);
+    return 0;
+  }
+  return -1;
+}
+
+bool CEGLNativeTypeIMX::ModeToResolution(const char *mode, RESOLUTION_INFO *res) const
+{
+  if (!res)
+    return false;
+
+  res->iWidth = 0;
+  res->iHeight= 0;
+
+  if(!mode)
+    return false;
+
+  std::string fromMode = StringUtils::Mid(mode, 2);
+  StringUtils::Trim(fromMode);
+
+  CRegExp split(true);
+  split.RegComp("([0-9]+)x([0-9]+)([pi])-([0-9]+)");
+  if (split.RegFind(fromMode) < 0)
+    return false;
+
+  int w = atoi(split.GetMatch(1).c_str());
+  int h = atoi(split.GetMatch(2).c_str());
+  std::string p = split.GetMatch(3);
+  int r = atoi(split.GetMatch(4).c_str());
+
+  res->iWidth = w;
+  res->iHeight= h;
+  res->iScreenWidth = w;
+  res->iScreenHeight= h;
+  res->fRefreshRate = r;
+  res->dwFlags = p[0] == 'p' ? D3DPRESENTFLAG_PROGRESSIVE : D3DPRESENTFLAG_INTERLACED;
+
+  res->iScreen       = 0;
+  res->bFullScreen   = true;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+  res->fPixelRatio   = 1.0f;
+  res->strMode       = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
+                                           res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  res->strId         = mode;
+
+  return res->iWidth > 0 && res->iHeight> 0;
+}
+
diff -Naur xbmc-gotham-latest.test/xbmc/windowing/egl/EGLNativeTypeIMX.h xbmc-imx6-koying.test/xbmc/windowing/egl/EGLNativeTypeIMX.h
--- xbmc-gotham-latest.test/xbmc/windowing/egl/EGLNativeTypeIMX.h	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-imx6-koying.test/xbmc/windowing/egl/EGLNativeTypeIMX.h	2014-02-21 23:11:23.780122319 +0100
@@ -0,0 +1,60 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <linux/fb.h>
+#include "EGLNativeType.h"
+#include "EGL/eglvivante.h"
+
+class CEGLNativeTypeIMX : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeIMX();
+  virtual ~CEGLNativeTypeIMX();
+  virtual std::string GetNativeName() const { return "iMX"; }
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; }
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+  
+protected:
+  bool m_readonly;
+  int get_sysfs_str(const char *path, char *valstr, const int size) const;
+  int set_sysfs_str(const char *path, const char *val);
+  bool ModeToResolution(const char *mode, RESOLUTION_INFO *res) const;
+  
+  EGLNativeDisplayType m_display;
+  EGLNativeWindowType  m_window;
+};
diff -Naur xbmc-gotham-latest.test/xbmc/windowing/egl/EGLWrapper.cpp xbmc-imx6-koying.test/xbmc/windowing/egl/EGLWrapper.cpp
--- xbmc-gotham-latest.test/xbmc/windowing/egl/EGLWrapper.cpp	2014-02-21 23:10:29.976096826 +0100
+++ xbmc-imx6-koying.test/xbmc/windowing/egl/EGLWrapper.cpp	2014-02-21 23:11:23.780122319 +0100
@@ -17,16 +17,17 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
-
 #include "system.h"
 
 #ifdef HAS_EGL
-
 #include "utils/log.h"
 #include "EGLNativeTypeAndroid.h"
 #include "EGLNativeTypeAmlogic.h"
 #include "EGLNativeTypeRaspberryPI.h"
 #include "EGLNativeTypeWayland.h"
+#ifdef HAS_IMXVPU
+#include "EGLNativeTypeIMX.h"
+#endif
 #include "EGLWrapper.h"
 
 #define CheckError() m_result = eglGetError(); if(m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
@@ -83,7 +84,11 @@
   if ((nativeGuess = CreateEGLNativeType<CEGLNativeTypeWayland>(implementation)) ||
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeAndroid>(implementation)) ||
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeAmlogic>(implementation)) ||
-      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeRaspberryPI>(implementation)))
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeRaspberryPI>(implementation))
+#ifdef HAS_IMXVPU
+      || (nativeGuess = CreateEGLNativeType<CEGLNativeTypeIMX>(implementation))
+#endif
+      )
   {
     m_nativeTypes = nativeGuess;
 
diff -Naur xbmc-gotham-latest.test/xbmc/windowing/egl/Makefile.in xbmc-imx6-koying.test/xbmc/windowing/egl/Makefile.in
--- xbmc-gotham-latest.test/xbmc/windowing/egl/Makefile.in	2014-02-21 23:10:29.933096805 +0100
+++ xbmc-imx6-koying.test/xbmc/windowing/egl/Makefile.in	2014-02-21 23:11:23.779122318 +0100
@@ -24,6 +24,10 @@
        wayland/XBMCSurface.cpp
 endif
 
+ifeq (@USE_IMXVPU@,1)
+SRCS+= EGLNativeTypeIMX.cpp
+endif
+
 LIB = windowing_egl.a
 
 include ../../../Makefile.include
