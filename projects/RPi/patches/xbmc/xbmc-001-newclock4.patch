From 6a095dba6f512c2c78158feb4f764b6ddc5b1d3e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 18 Aug 2014 17:48:04 +0100
Subject: [PATCH 01/77] omxplayer: Reset codec on flush to stop a stale
 timestamp from being returned

---
 xbmc/cores/omxplayer/OMXPlayerAudio.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
index 55f8ac7..2d5ddf2 100644
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
@@ -491,6 +491,8 @@ void OMXPlayerAudio::Process()
 void OMXPlayerAudio::Flush()
 {
   m_flush = true;
+  if(m_pAudioCodec)
+    m_pAudioCodec->Reset();
   m_messageQueue.Flush();
   m_messageQueue.Put( new CDVDMsg(CDVDMsg::GENERAL_FLUSH), 1);
 }

From 05e74bdeac984a465a5a132f127ea60c0aa2a773 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 30 Dec 2013 12:02:14 +0000
Subject: [PATCH 03/77] [rbp] Hardware accelerated resampling

This replaces the format conversion, up/down mixing and resampling code from ActiveAE with a GPU accelerated version.
Should significantly reduce CPU when using paplayer or dvdplayer.

Requires updated firmware
---
 .../Engines/ActiveAE/ActiveAEResample.cpp          |   5 +
 .../Engines/ActiveAE/ActiveAEResample.h            |   8 +
 .../Engines/ActiveAE/ActiveAEResamplePi.cpp        | 656 +++++++++++++++++++++
 .../Engines/ActiveAE/ActiveAEResamplePi.h          |  63 ++
 xbmc/cores/AudioEngine/Makefile.in                 |   1 +
 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp          |  14 +-
 xbmc/linux/OMXCore.cpp                             |   4 +-
 7 files changed, 742 insertions(+), 9 deletions(-)
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
index cbb6d69..99cd607 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
@@ -18,6 +18,10 @@
  *
  */
 
+#include "system.h"
+
+#if !defined(TARGET_RASPBERRY_PI)
+
 #include "ActiveAEResample.h"
 #include "utils/log.h"
 
@@ -386,3 +390,4 @@ int CActiveAEResample::GetAVChannelIndex(enum AEChannel aechannel, uint64_t layo
 {
   return av_get_channel_layout_channel_index(layout, GetAVChannel(aechannel));
 }
+#endif
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
index a471e02..5d37cc7 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
@@ -19,6 +19,8 @@
  *
  */
 
+#include "system.h"
+
 #include "cores/AudioEngine/Utils/AEChannelInfo.h"
 #include "cores/AudioEngine/Utils/AEAudioFormat.h"
 #include "cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h"
@@ -29,6 +31,10 @@ extern "C" {
 #include "libswresample/swresample.h"
 }
 
+#if defined(TARGET_RASPBERRY_PI)
+#include "ActiveAEResamplePi.h"
+#else
+
 namespace ActiveAE
 {
 
@@ -63,3 +69,5 @@ class CActiveAEResample
 };
 
 }
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
new file mode 100644
index 0000000..cc01738
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
@@ -0,0 +1,656 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(TARGET_RASPBERRY_PI)
+
+#include "ActiveAEResample.h"
+#include "linux/RBP.h"
+#include "settings/Settings.h"
+#include "utils/log.h"
+
+extern "C" {
+#include "libavutil/channel_layout.h"
+#include "libavutil/opt.h"
+#include "libswresample/swresample.h"
+}
+
+//#define DEBUG_VERBOSE
+
+#define CLASSNAME "CActiveAEResamplePi"
+
+#define BUFFERSIZE (32*1024*2*8)
+
+//#define BENCHMARKING
+#ifdef BENCHMARKING
+#define LOGTIMEINIT(f) \
+  struct timespec now; \
+  uint64_t  Start, End; \
+  clock_gettime(CLOCK_MONOTONIC, &now); \
+  Start = ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec; \
+  const char *_filename = f;
+
+#define LOGTIME(n) \
+  clock_gettime(CLOCK_MONOTONIC, &now); \
+  End = ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec; \
+  CLog::Log(LOGNOTICE, "ActiveAE::%s %d - resample %s took %.0fms", __FUNCTION__, n, _filename, (End-Start)*1e-6); \
+  Start=End;
+#else
+#define LOGTIMEINIT(f)
+#define LOGTIME(n)
+#endif
+
+using namespace ActiveAE;
+
+CActiveAEResample::CActiveAEResample()
+{
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+
+  m_Initialized = false;
+  m_last_src_fmt = AV_SAMPLE_FMT_NONE;
+  m_last_dst_fmt = AV_SAMPLE_FMT_NONE;
+  m_last_src_channels = 0;
+  m_last_dst_channels = 0;
+  m_encoded_buffer = NULL;
+}
+
+CActiveAEResample::~CActiveAEResample()
+{
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  DeInit();
+}
+
+void CActiveAEResample::DeInit()
+{
+  CLog::Log(LOGDEBUG, "%s:%s", CLASSNAME, __func__);
+  if (m_Initialized)
+  {
+    m_omx_mixer.FlushAll();
+    m_omx_mixer.Deinitialize();
+    m_Initialized = false;
+  }
+}
+
+static int format_to_bits(AVSampleFormat fmt)
+{
+  switch (fmt)
+  {
+  case AV_SAMPLE_FMT_U8:
+  case AV_SAMPLE_FMT_U8P:
+    return 8;
+  case AV_SAMPLE_FMT_S16:
+  case AV_SAMPLE_FMT_S16P:
+    return 16;
+  case AV_SAMPLE_FMT_S32:
+  case AV_SAMPLE_FMT_S32P:
+  case AV_SAMPLE_FMT_FLT:
+  case AV_SAMPLE_FMT_FLTP:
+    return 32;
+  default:
+    assert(0);
+  }
+  return 0;
+}
+
+bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, int dst_bits, int dst_dither, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, int src_bits, int src_dither, bool upmix, bool normalize, CAEChannelInfo *remapLayout, AEQuality quality)
+{
+  LOGTIMEINIT("x");
+
+  CLog::Log(LOGINFO, "%s::%s remap:%p chan:%d->%d rate:%d->%d format:%d->%d bits:%d->%d norm:%d upmix:%d", CLASSNAME, __func__, remapLayout, src_channels, dst_channels, src_rate, dst_rate, src_fmt, dst_fmt, src_bits, dst_bits, normalize, upmix);
+
+  // replace passed in number of bits with correct ones
+  src_bits = format_to_bits(src_fmt);
+  dst_bits = format_to_bits(dst_fmt);
+
+  m_dst_chan_layout = dst_chan_layout;
+  m_dst_channels = dst_channels;
+  m_dst_rate = dst_rate;
+  m_dst_fmt = dst_fmt;
+  m_dst_bits = dst_bits;
+  m_src_chan_layout = src_chan_layout;
+  m_src_channels = src_channels;
+  m_src_rate = src_rate;
+  m_src_fmt = src_fmt;
+  m_src_bits = src_bits;
+
+  if (m_dst_chan_layout == 0)
+    m_dst_chan_layout = av_get_default_channel_layout(m_dst_channels);
+  if (m_src_chan_layout == 0)
+    m_src_chan_layout = av_get_default_channel_layout(m_src_channels);
+
+  OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8 mix;
+  OMX_INIT_STRUCTURE(mix);
+
+  assert(sizeof(mix.coeff)/sizeof(mix.coeff[0]) == 64);
+
+  LOGTIME(1);
+// this code is just uses ffmpeg to produce the 8x8 mixing matrix
+{
+  // dummy sample rate and format, as we only care about channel mapping
+  SwrContext *m_pContext = swr_alloc_set_opts(NULL, m_dst_chan_layout, AV_SAMPLE_FMT_FLT, 48000,
+                                                        m_src_chan_layout, AV_SAMPLE_FMT_FLT, 48000, 0, NULL);
+  if (!m_pContext)
+  {
+    CLog::Log(LOGERROR, "CActiveAEResample::Init - create context failed");
+    return false;
+  }
+  // tell resampler to clamp float values
+  // not required for sink stage (remapLayout == true)
+  if (!remapLayout && normalize)
+  {
+    av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
+  }
+
+  if (remapLayout)
+  {
+    // one-to-one mapping of channels
+    // remapLayout is the layout of the sink, if the channel is in our src layout
+    // the channel is mapped by setting coef 1.0
+    double m_rematrix[AE_CH_MAX][AE_CH_MAX];
+    memset(m_rematrix, 0, sizeof(m_rematrix));
+    m_dst_chan_layout = 0;
+    for (unsigned int out=0; out<remapLayout->Count(); out++)
+    {
+      m_dst_chan_layout += (uint64_t) (1 << out);
+      int idx = GetAVChannelIndex((*remapLayout)[out], m_src_chan_layout);
+      if (idx >= 0)
+      {
+        m_rematrix[out][idx] = 1.0;
+      }
+    }
+
+    av_opt_set_int(m_pContext, "out_channel_count", m_dst_channels, 0);
+    av_opt_set_int(m_pContext, "out_channel_layout", m_dst_chan_layout, 0);
+
+    if (swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
+    {
+      CLog::Log(LOGERROR, "CActiveAEResample::Init - setting channel matrix failed");
+      return false;
+    }
+  }
+  // stereo upmix
+  else if (upmix && m_src_channels == 2 && m_dst_channels > 2)
+  {
+    double m_rematrix[AE_CH_MAX][AE_CH_MAX];
+    memset(m_rematrix, 0, sizeof(m_rematrix));
+    for (int out=0; out<m_dst_channels; out++)
+    {
+      uint64_t out_chan = av_channel_layout_extract_channel(m_dst_chan_layout, out);
+      switch(out_chan)
+      {
+        case AV_CH_FRONT_LEFT:
+        case AV_CH_BACK_LEFT:
+        case AV_CH_SIDE_LEFT:
+          m_rematrix[out][0] = 1.0;
+          break;
+        case AV_CH_FRONT_RIGHT:
+        case AV_CH_BACK_RIGHT:
+        case AV_CH_SIDE_RIGHT:
+          m_rematrix[out][1] = 1.0;
+          break;
+        case AV_CH_FRONT_CENTER:
+          m_rematrix[out][0] = 0.5;
+          m_rematrix[out][1] = 0.5;
+          break;
+        case AV_CH_LOW_FREQUENCY:
+          m_rematrix[out][0] = 0.5;
+          m_rematrix[out][1] = 0.5;
+          break;
+        default:
+          break;
+      }
+    }
+
+    if (swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
+    {
+      CLog::Log(LOGERROR, "CActiveAEResample::Init - setting channel matrix failed");
+      return false;
+    }
+  }
+
+  if (swr_init(m_pContext) < 0)
+  {
+    CLog::Log(LOGERROR, "CActiveAEResample::Init - init resampler failed");
+    return false;
+  }
+
+  const int samples = 8;
+  uint8_t *output, *input;
+  av_samples_alloc(&output, NULL, m_dst_channels, samples, AV_SAMPLE_FMT_FLT, 1);
+  av_samples_alloc(&input , NULL, m_src_channels, samples, AV_SAMPLE_FMT_FLT, 1);
+
+  // Produce "identity" samples
+  float *f = (float *)input;
+  for (int j=0; j < samples; j++)
+    for (int i=0; i < m_src_channels; i++)
+      *f++ = i == j ? 1.0f : 0.0f;
+
+  int ret = swr_convert(m_pContext, &output, samples, (const uint8_t **)&input, samples);
+  if (ret < 0)
+    CLog::Log(LOGERROR, "CActiveAEResample::Resample - resample failed");
+
+  f = (float *)output;
+  for (int j=0; j < samples; j++)
+    for (int i=0; i < m_dst_channels; i++)
+      mix.coeff[8*i+j] = *f++ * (1<<16);
+
+  for (int j=0; j < 8; j++)
+  {
+    char s[128] = {}, *t=s;
+    for (int i=0; i < 8; i++)
+      t += sprintf(t, "% 6.2f ", mix.coeff[j*8+i] * (1.0/0x10000));
+    CLog::Log(LOGINFO, "%s::%s  %s", CLASSNAME, __func__, s);
+  }
+  av_freep(&input);
+  av_freep(&output);
+  swr_free(&m_pContext);
+}
+  LOGTIME(2);
+
+  // This may be called before Application calls g_RBP.Initialise, so call it here too
+  g_RBP.Initialize();
+
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  if (!m_omx_mixer.Initialize("OMX.broadcom.audio_mixer", OMX_IndexParamAudioInit))
+    CLog::Log(LOGERROR, "%s::%s - m_omx_mixer.Initialize omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(3);
+
+  // audio_mixer only supports up to 192kHz, however as long as ratio of samplerates remains the same we can lie
+  while (src_rate > 192000 || dst_rate > 192000)
+    src_rate >>= 1, dst_rate >>= 1;
+
+  OMX_INIT_STRUCTURE(m_pcm_input);
+  m_pcm_input.nPortIndex            = m_omx_mixer.GetInputPort();
+  m_pcm_input.eNumData              = OMX_NumericalDataSigned;
+  m_pcm_input.eEndian               = OMX_EndianLittle;
+  m_pcm_input.bInterleaved          = OMX_TRUE;
+  m_pcm_input.nBitPerSample         = m_src_bits;
+  // 0x8000 = float, 0x10000 = planar
+  uint32_t flags = 0;
+  if (m_src_fmt == AV_SAMPLE_FMT_FLT || m_src_fmt == AV_SAMPLE_FMT_FLTP)
+   flags |= 0x8000;
+  if (m_src_fmt >= AV_SAMPLE_FMT_U8P)
+   flags |= 0x10000;
+  m_pcm_input.ePCMMode              = flags == 0 ? OMX_AUDIO_PCMModeLinear : (OMX_AUDIO_PCMMODETYPE)flags;
+  m_pcm_input.nChannels             = src_channels;
+  m_pcm_input.nSamplingRate         = src_rate;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_input);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_mixer in SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  OMX_INIT_STRUCTURE(m_pcm_output);
+  m_pcm_output.nPortIndex            = m_omx_mixer.GetOutputPort();
+  m_pcm_output.eNumData              = OMX_NumericalDataSigned;
+  m_pcm_output.eEndian               = OMX_EndianLittle;
+  m_pcm_output.bInterleaved          = OMX_TRUE;
+  m_pcm_output.nBitPerSample         = m_dst_bits;
+  flags = 0;
+  if (m_dst_fmt == AV_SAMPLE_FMT_FLT || m_dst_fmt == AV_SAMPLE_FMT_FLTP)
+   flags |= 0x8000;
+  if (m_dst_fmt >= AV_SAMPLE_FMT_U8P)
+   flags |= 0x10000;
+  m_pcm_output.ePCMMode              = flags == 0 ? OMX_AUDIO_PCMModeLinear : (OMX_AUDIO_PCMMODETYPE)flags;
+  m_pcm_output.nChannels             = dst_channels;
+  m_pcm_output.nSamplingRate         = dst_rate;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_mixer out SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(4);
+
+  mix.nPortIndex = m_omx_mixer.GetInputPort();
+  omx_err = m_omx_mixer.SetConfig(OMX_IndexConfigBrcmAudioDownmixCoefficients8x8, &mix);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error setting mixer OMX_IndexConfigBrcmAudioDownmixCoefficients, error 0x%08x\n",
+              CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  // set up the number/size of buffers for decoder input
+  OMX_PARAM_PORTDEFINITIONTYPE port_param;
+  OMX_INIT_STRUCTURE(port_param);
+  port_param.nPortIndex = m_omx_mixer.GetInputPort();
+
+  omx_err = m_omx_mixer.GetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, (unsigned int)1);
+  port_param.nBufferSize = BUFFERSIZE;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error set OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(5);
+
+  omx_err = m_omx_mixer.AllocInputBuffers();
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - Error alloc buffers 0x%08x", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(6);
+
+  // set up the number/size of buffers for decoder output
+  OMX_INIT_STRUCTURE(port_param);
+  port_param.nPortIndex = m_omx_mixer.GetOutputPort();
+
+  omx_err = m_omx_mixer.GetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, (unsigned int)1);
+  port_param.nBufferSize = BUFFERSIZE;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error set OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(7);
+
+  omx_err = m_omx_mixer.AllocOutputBuffers();
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - Error alloc buffers 0x%08x", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(8);
+
+  omx_err = m_omx_mixer.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - m_omx_mixer OMX_StateExecuting omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(9);
+
+  m_Initialized = true;
+
+  return true;
+}
+
+
+static void copy_planes(uint8_t **dst_buffer, int d_pitch, int d_planes, int d_samplesize, int offset, uint8_t *src_buffer, int src_samples)
+{
+  int planesize = src_samples * d_samplesize / d_planes;
+  for (int i=0; i < d_planes; i++)
+    memcpy(dst_buffer[i] + offset * d_pitch, src_buffer + i * planesize, planesize);
+}
+
+int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t **src_buffer, int src_samples, double ratio)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s samples:%d->%d (%.2f)", CLASSNAME, __func__, src_samples, dst_samples, ratio);
+  #endif
+  if (!m_Initialized)
+    return 0;
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  const int s_planes = m_src_fmt >= AV_SAMPLE_FMT_U8P ? m_src_channels : 1;
+  const int d_planes = m_dst_fmt >= AV_SAMPLE_FMT_U8P ? m_dst_channels : 1;
+  const int s_chans  = m_src_fmt >= AV_SAMPLE_FMT_U8P ? 1 : m_src_channels;
+  const int d_chans  = m_dst_fmt >= AV_SAMPLE_FMT_U8P ? 1 : m_dst_channels;
+  const int s_pitch = s_chans * m_src_bits >> 3;
+  const int d_pitch = d_chans * m_dst_bits >> 3;
+
+  const int s_samplesize = m_src_channels * m_src_bits >> 3;
+  const int d_samplesize = m_dst_channels * m_dst_bits >> 3;
+  const int max_src_samples = BUFFERSIZE / s_samplesize;
+  const int max_dst_samples = (long long)(BUFFERSIZE / d_samplesize) * m_src_rate / (m_dst_rate + m_src_rate-1);
+
+  int sent = 0;
+  int received = 0;
+
+  if (m_encoded_buffer && m_encoded_buffer->nFilledLen)
+  {
+    int samples_available = m_encoded_buffer->nFilledLen / d_samplesize - m_encoded_buffer->nOffset;
+    int samples = std::min(samples_available, dst_samples - received);
+    copy_planes(dst_buffer, d_pitch, d_planes, d_samplesize, received, (uint8_t *)m_encoded_buffer->pBuffer + m_encoded_buffer->nOffset * d_pitch, samples);
+    received += samples;
+    samples_available -= samples;
+    if (samples_available > 0)
+      m_encoded_buffer->nOffset += samples;
+    else
+      m_encoded_buffer = NULL;
+  }
+  assert(!m_encoded_buffer);
+  while (sent < src_samples)
+  {
+    OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
+
+    omx_buffer = m_omx_mixer.GetInputBuffer(1000);
+    if (omx_buffer == NULL)
+      return false;
+
+    int send = std::min(std::min(max_dst_samples, max_src_samples), src_samples - sent);
+
+    omx_buffer->nOffset = 0;
+    omx_buffer->nFlags = OMX_BUFFERFLAG_EOS;
+    omx_buffer->nFilledLen = send * s_samplesize;
+
+    assert(omx_buffer->nFilledLen > 0 && omx_buffer->nFilledLen <= omx_buffer->nAllocLen);
+
+    if (omx_buffer->nFilledLen)
+    {
+      int planesize = omx_buffer->nFilledLen / s_planes;
+      for (int i=0; i < s_planes; i++)
+        memcpy((uint8_t *)omx_buffer->pBuffer + i * planesize, src_buffer[i] + sent * s_pitch, planesize);
+      sent += send;
+    }
+
+    omx_err = m_omx_mixer.EmptyThisBuffer(omx_buffer);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s OMX_EmptyThisBuffer() failed with result(0x%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    m_encoded_buffer = m_omx_mixer.GetOutputBuffer();
+
+    if (!m_encoded_buffer)
+    {
+      CLog::Log(LOGERROR, "%s::%s no output buffer", CLASSNAME, __func__);
+      return false;
+    }
+
+    omx_err = m_omx_mixer.FillThisBuffer(m_encoded_buffer);
+    if (omx_err != OMX_ErrorNone)
+      return false;
+
+    omx_err = m_omx_mixer.WaitForOutputDone(1000);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_mixer.WaitForOutputDone result(0x%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    assert(m_encoded_buffer->nFilledLen > 0 && m_encoded_buffer->nFilledLen <= m_encoded_buffer->nAllocLen);
+
+    if (m_omx_mixer.BadState())
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_mixer.BadState", CLASSNAME, __func__);
+      return false;
+    }
+
+    if (m_encoded_buffer->nFilledLen)
+    {
+      int samples_available = m_encoded_buffer->nFilledLen / d_samplesize;
+      int samples = std::min(samples_available, dst_samples - received);
+      copy_planes(dst_buffer, d_pitch, d_planes, d_samplesize, received, (uint8_t *)m_encoded_buffer->pBuffer, samples);
+      received += samples;
+      samples_available -= samples;
+      if (samples_available > 0)
+        m_encoded_buffer->nOffset += samples;
+      else
+        m_encoded_buffer = NULL;
+    }
+  }
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s format:%d->%d rate:%d->%d chan:%d->%d samples %d->%d (%f) %d =%d", CLASSNAME, __func__,
+    (int)m_src_fmt, (int)m_dst_fmt, m_src_rate, m_dst_rate, m_src_channels, m_dst_channels, src_samples, dst_samples, ratio, m_Initialized, received);
+  #endif
+  assert(received <= dst_samples);
+  return received;
+}
+
+int64_t CActiveAEResample::GetDelay(int64_t base)
+{
+  int ret = m_dst_rate ? 1000 * GetBufferedSamples() / m_dst_rate : 0;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::GetBufferedSamples()
+{
+  int samples = 0;
+  if (m_encoded_buffer)
+  {
+    const int d_samplesize = m_dst_channels * m_dst_bits >> 3;
+    samples = m_encoded_buffer->nFilledLen / d_samplesize - m_encoded_buffer->nOffset;
+  }
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, samples);
+  #endif
+  return samples;
+}
+
+int CActiveAEResample::CalcDstSampleCount(int src_samples, int dst_rate, int src_rate)
+{
+  int ret = ((long long)src_samples * dst_rate + src_rate-1) / src_rate;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::GetSrcBufferSize(int samples)
+{
+  int ret = 0;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::GetDstBufferSize(int samples)
+{
+  int ret = CalcDstSampleCount(samples, m_dst_rate, m_src_rate);
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+uint64_t CActiveAEResample::GetAVChannelLayout(CAEChannelInfo &info)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  uint64_t channelLayout = 0;
+  if (info.HasChannel(AE_CH_FL))   channelLayout |= AV_CH_FRONT_LEFT;
+  if (info.HasChannel(AE_CH_FR))   channelLayout |= AV_CH_FRONT_RIGHT;
+  if (info.HasChannel(AE_CH_FC))   channelLayout |= AV_CH_FRONT_CENTER;
+  if (info.HasChannel(AE_CH_LFE))  channelLayout |= AV_CH_LOW_FREQUENCY;
+  if (info.HasChannel(AE_CH_BL))   channelLayout |= AV_CH_BACK_LEFT;
+  if (info.HasChannel(AE_CH_BR))   channelLayout |= AV_CH_BACK_RIGHT;
+  if (info.HasChannel(AE_CH_FLOC)) channelLayout |= AV_CH_FRONT_LEFT_OF_CENTER;
+  if (info.HasChannel(AE_CH_FROC)) channelLayout |= AV_CH_FRONT_RIGHT_OF_CENTER;
+  if (info.HasChannel(AE_CH_BC))   channelLayout |= AV_CH_BACK_CENTER;
+  if (info.HasChannel(AE_CH_SL))   channelLayout |= AV_CH_SIDE_LEFT;
+  if (info.HasChannel(AE_CH_SR))   channelLayout |= AV_CH_SIDE_RIGHT;
+  if (info.HasChannel(AE_CH_TC))   channelLayout |= AV_CH_TOP_CENTER;
+  if (info.HasChannel(AE_CH_TFL))  channelLayout |= AV_CH_TOP_FRONT_LEFT;
+  if (info.HasChannel(AE_CH_TFC))  channelLayout |= AV_CH_TOP_FRONT_CENTER;
+  if (info.HasChannel(AE_CH_TFR))  channelLayout |= AV_CH_TOP_FRONT_RIGHT;
+  if (info.HasChannel(AE_CH_TBL))   channelLayout |= AV_CH_TOP_BACK_LEFT;
+  if (info.HasChannel(AE_CH_TBC))   channelLayout |= AV_CH_TOP_BACK_CENTER;
+  if (info.HasChannel(AE_CH_TBR))   channelLayout |= AV_CH_TOP_BACK_RIGHT;
+
+  return channelLayout;
+}
+
+AVSampleFormat CActiveAEResample::GetAVSampleFormat(AEDataFormat format)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  if      (format == AE_FMT_U8)     return AV_SAMPLE_FMT_U8;
+  else if (format == AE_FMT_S16NE)  return AV_SAMPLE_FMT_S16;
+  else if (format == AE_FMT_S32NE)  return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_S24NE4) return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_S24NE4MSB)return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_FLOAT)  return AV_SAMPLE_FMT_FLT;
+  else if (format == AE_FMT_DOUBLE) return AV_SAMPLE_FMT_DBL;
+
+  else if (format == AE_FMT_U8P)     return AV_SAMPLE_FMT_U8P;
+  else if (format == AE_FMT_S16NEP)  return AV_SAMPLE_FMT_S16P;
+  else if (format == AE_FMT_S32NEP)  return AV_SAMPLE_FMT_S32P;
+  else if (format == AE_FMT_S24NE4P) return AV_SAMPLE_FMT_S32P;
+  else if (format == AE_FMT_S24NE4MSB)return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_FLOATP)  return AV_SAMPLE_FMT_FLTP;
+  else if (format == AE_FMT_DOUBLEP) return AV_SAMPLE_FMT_DBLP;
+
+  if (AE_IS_PLANAR(format))
+    return AV_SAMPLE_FMT_FLTP;
+  else
+    return AV_SAMPLE_FMT_FLT;
+}
+
+uint64_t CActiveAEResample::GetAVChannel(enum AEChannel aechannel)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  switch (aechannel)
+  {
+  case AE_CH_FL:   return AV_CH_FRONT_LEFT;
+  case AE_CH_FR:   return AV_CH_FRONT_RIGHT;
+  case AE_CH_FC:   return AV_CH_FRONT_CENTER;
+  case AE_CH_LFE:  return AV_CH_LOW_FREQUENCY;
+  case AE_CH_BL:   return AV_CH_BACK_LEFT;
+  case AE_CH_BR:   return AV_CH_BACK_RIGHT;
+  case AE_CH_FLOC: return AV_CH_FRONT_LEFT_OF_CENTER;
+  case AE_CH_FROC: return AV_CH_FRONT_RIGHT_OF_CENTER;
+  case AE_CH_BC:   return AV_CH_BACK_CENTER;
+  case AE_CH_SL:   return AV_CH_SIDE_LEFT;
+  case AE_CH_SR:   return AV_CH_SIDE_RIGHT;
+  case AE_CH_TC:   return AV_CH_TOP_CENTER;
+  case AE_CH_TFL:  return AV_CH_TOP_FRONT_LEFT;
+  case AE_CH_TFC:  return AV_CH_TOP_FRONT_CENTER;
+  case AE_CH_TFR:  return AV_CH_TOP_FRONT_RIGHT;
+  case AE_CH_TBL:  return AV_CH_TOP_BACK_LEFT;
+  case AE_CH_TBC:  return AV_CH_TOP_BACK_CENTER;
+  case AE_CH_TBR:  return AV_CH_TOP_BACK_RIGHT;
+  default:
+    return 0;
+  }
+}
+
+int CActiveAEResample::GetAVChannelIndex(enum AEChannel aechannel, uint64_t layout)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  return av_get_channel_layout_channel_index(layout, GetAVChannel(aechannel));
+}
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h
new file mode 100644
index 0000000..b88a90b
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h
@@ -0,0 +1,63 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "linux/OMXCore.h"
+
+namespace ActiveAE
+{
+
+class CActiveAEResample
+{
+public:
+  CActiveAEResample();
+  virtual ~CActiveAEResample();
+  bool Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, int dst_bits, int dst_dither, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, int src_bits, int src_dither, bool upmix, bool normalize, CAEChannelInfo *remapLayout, AEQuality quality);
+  int Resample(uint8_t **dst_buffer, int dst_samples, uint8_t **src_buffer, int src_samples, double ratio);
+  int64_t GetDelay(int64_t base);
+  int GetBufferedSamples();
+  int CalcDstSampleCount(int src_samples, int dst_rate, int src_rate);
+  int GetSrcBufferSize(int samples);
+  int GetDstBufferSize(int samples);
+  static uint64_t GetAVChannelLayout(CAEChannelInfo &info);
+//  static CAEChannelInfo GetAEChannelLayout(uint64_t layout);
+  static AVSampleFormat GetAVSampleFormat(AEDataFormat format);
+  static AEDataFormat GetAESampleFormat(AVSampleFormat format, int bits);
+  static uint64_t GetAVChannel(enum AEChannel aechannel);
+  int GetAVChannelIndex(enum AEChannel aechannel, uint64_t layout);
+
+protected:
+  void DeInit();
+  uint64_t m_src_chan_layout, m_dst_chan_layout;
+  int m_src_rate, m_dst_rate;
+  int m_src_channels, m_dst_channels;
+  AVSampleFormat m_src_fmt, m_dst_fmt;
+  int m_src_bits, m_dst_bits;
+
+  OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_input;
+  OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_output;
+  COMXCoreComponent    m_omx_mixer;
+  bool                 m_Initialized;
+  AVSampleFormat m_last_src_fmt, m_last_dst_fmt;
+  int m_last_src_channels, m_last_dst_channels;
+  OMX_BUFFERHEADERTYPE *m_encoded_buffer;
+};
+
+}
diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index 581249e..20c05bb 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -31,6 +31,7 @@ SRCS += Engines/ActiveAE/ActiveAESink.cpp
 SRCS += Engines/ActiveAE/ActiveAEStream.cpp
 SRCS += Engines/ActiveAE/ActiveAESound.cpp
 SRCS += Engines/ActiveAE/ActiveAEResample.cpp
+SRCS += Engines/ActiveAE/ActiveAEResamplePi.cpp
 SRCS += Engines/ActiveAE/ActiveAEBuffer.cpp
 
 ifeq (@USE_ANDROID@,1)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
index 7af2078..b199acd 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
@@ -78,9 +78,9 @@ static void SetAudioProps(bool stream_channels, uint32_t channel_map)
   CLog::Log(LOGDEBUG, "%s:%s hdmi_stream_channels %d hdmi_channel_map %08x", CLASSNAME, __func__, stream_channels, channel_map);
 }
 
-static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
+static uint32_t GetChannelMap(const CAEChannelInfo &channelLayout, bool passthrough)
 {
-  unsigned int channels = format.m_channelLayout.Count();
+  unsigned int channels = channelLayout.Count();
   uint32_t channel_map = 0;
   if (passthrough)
     return 0;
@@ -119,12 +119,12 @@ static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
   // According to CEA-861-D only RL and RR are known. In case of a format having SL and SR channels
   // but no BR BL channels, we use the wide map in order to open only the num of channels really
   // needed.
-  if (format.m_channelLayout.HasChannel(AE_CH_BL) && !format.m_channelLayout.HasChannel(AE_CH_SL))
+  if (channelLayout.HasChannel(AE_CH_BL) && !channelLayout.HasChannel(AE_CH_SL))
     map = map_back;
 
   for (unsigned int i = 0; i < channels; ++i)
   {
-    AEChannel c = format.m_channelLayout[i];
+    AEChannel c = channelLayout[i];
     unsigned int chan = 0;
     if ((unsigned int)c < sizeof map_normal / sizeof *map_normal)
       chan = map[(unsigned int)c];
@@ -155,9 +155,9 @@ static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
     0xff, // 7
     0x13, // 7.1
   };
-  uint8_t cea = format.m_channelLayout.HasChannel(AE_CH_LFE) ? cea_map_lfe[channels] : cea_map[channels];
+  uint8_t cea = channelLayout.HasChannel(AE_CH_LFE) ? cea_map_lfe[channels] : cea_map[channels];
   if (cea == 0xff)
-    CLog::Log(LOGERROR, "%s::%s - Unexpected CEA mapping %d,%d", CLASSNAME, __func__, format.m_channelLayout.HasChannel(AE_CH_LFE), channels);
+    CLog::Log(LOGERROR, "%s::%s - Unexpected CEA mapping %d,%d", CLASSNAME, __func__, channelLayout.HasChannel(AE_CH_LFE), channels);
 
   channel_map |= cea << 24;
 
@@ -191,7 +191,7 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
   format.m_frames        = format.m_sampleRate * AUDIO_PLAYBUFFER / NUM_OMX_BUFFERS;
   format.m_frameSamples  = format.m_frames * channels;
 
-  SetAudioProps(m_passthrough, GetChannelMap(format, m_passthrough));
+  SetAudioProps(m_passthrough, GetChannelMap(format.m_channelLayout, m_passthrough));
 
   m_format = format;
   m_sinkbuffer_sec_per_byte = 1.0 / (double)(m_format.m_frameSize * m_format.m_sampleRate);
diff --git a/xbmc/linux/OMXCore.cpp b/xbmc/linux/OMXCore.cpp
index 4ae29ba..4caa304 100644
--- a/xbmc/linux/OMXCore.cpp
+++ b/xbmc/linux/OMXCore.cpp
@@ -419,7 +419,7 @@ void COMXCoreComponent::FlushAll()
 
 void COMXCoreComponent::FlushInput()
 {
-  if(!m_handle)
+  if(!m_handle || m_resource_error)
     return;
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
@@ -436,7 +436,7 @@ void COMXCoreComponent::FlushInput()
 
 void COMXCoreComponent::FlushOutput()
 {
-  if(!m_handle)
+  if(!m_handle || m_resource_error)
     return;
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;

From 74fd1f96569ef50e18d8b1733b2953356ce5b409 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 18:19:32 +0100
Subject: [PATCH 04/77] [rbp/omxplayer] When opening a stream don't try to
 update gui so often

---
 xbmc/dialogs/GUIDialogBusy.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/dialogs/GUIDialogBusy.cpp b/xbmc/dialogs/GUIDialogBusy.cpp
index e9ba7d3..0fdc3c2 100644
--- a/xbmc/dialogs/GUIDialogBusy.cpp
+++ b/xbmc/dialogs/GUIDialogBusy.cpp
@@ -64,7 +64,11 @@ bool CGUIDialogBusy::WaitOnEvent(CEvent &event, unsigned int displaytime /* = 10
     if (dialog)
     {
       dialog->Show();
+#ifdef TARGET_RASPBERRY_PI
+      while(!event.WaitMSec(100))
+#else
       while(!event.WaitMSec(1))
+#endif
       {
         g_windowManager.ProcessRenderLoop(false);
         if (allowCancel && dialog->IsCanceled())

From 50339d0bf4b90ee909e0b9a6788f6dc7043b5de2 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 29 Apr 2014 15:23:22 +0100
Subject: [PATCH 05/77] [ffmpeg] Speed up wtv index creation

The index creation is O(N^2) with number of entries (typically thousands).
On a Pi this can take more than 60 seconds to execute for a recording of a few hours.

By replacing with an O(N) loop, this takes virtually zero time
---
 tools/depends/target/ffmpeg/Makefile               |  3 +-
 .../ffmpeg_Speed_up_wtv_index_creation.patch       | 47 ++++++++++++++++++++++
 2 files changed, 49 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch

diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 0e08dcf..7ce982c 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.include
 include FFMPEG-VERSION
-DEPS= ../../Makefile.include FFMPEG-VERSION Makefile
+DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -63,6 +63,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM); mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); sed -i".bak" -e "s%pkg_config_default=pkg-config%export PKG_CONFIG_LIBDIR=$(PREFIX)/lib/pkgconfig \&\& pkg_config_default=$(NATIVEPREFIX)/bin/pkg-config%" configure
+	cd $(PLATFORM); patch -p3 < ../ffmpeg_Speed_up_wtv_index_creation.patch
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
 	./configure $(ffmpg_config)
diff --git a/tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch b/tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch
new file mode 100644
index 0000000..8f5f989
--- /dev/null
+++ b/tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch
@@ -0,0 +1,47 @@
+commit 0e7427498cb1131671f6fe9d054245ae7e5a36f5
+Author: popcornmix <popcornmix@gmail.com>
+Date:   Tue Mar 25 19:43:07 2014 +0000
+
+    [ffmpeg] Speed up wtv index creation
+
+    The index creation is O(N^2) with number of entries (typically thousands).
+    On a Pi this can take more than 60 seconds to execute for a recording of a few hours.
+
+    By replacing with an O(N) loop, this takes virtually zero time
+
+diff --git a/lib/ffmpeg/libavformat/wtvdec.c b/lib/ffmpeg/libavformat/wtvdec.c
+index e423370..70898bd 100644
+--- a/lib/ffmpeg/libavformat/wtvdec.c
++++ b/lib/ffmpeg/libavformat/wtvdec.c
+@@ -980,21 +980,23 @@ static int read_header(AVFormatContext *s)
+                 pb = wtvfile_open(s, root, root_size, ff_timeline_table_0_entries_Events_le16);
+                 if (pb) {
+                     int i;
++                    AVIndexEntry *e = wtv->index_entries;
++                    AVIndexEntry *e_end = wtv->index_entries + wtv->nb_index_entries - 1;
++                    uint64_t last_position = 0;
+                     while (1) {
+                         uint64_t frame_nb = avio_rl64(pb);
+                         uint64_t position = avio_rl64(pb);
++                        while (frame_nb > e->size && e <= e_end) {
++                           e->pos = last_position;
++                           e++;
++                        }
+                         if (url_feof(pb))
+                             break;
+-                        for (i = wtv->nb_index_entries - 1; i >= 0; i--) {
+-                            AVIndexEntry *e = wtv->index_entries + i;
+-                            if (frame_nb > e->size)
+-                                break;
+-                            if (position > e->pos)
+-                                e->pos = position;
+-                        }
++                        last_position = position;
+                     }
++                    e_end->pos = last_position;
+                     wtvfile_close(pb);
+-                    st->duration = wtv->index_entries[wtv->nb_index_entries - 1].timestamp;
++                    st->duration = e_end->timestamp;
+                 }
+             }
+         }

From 420bc890afead12f3315e660c77860bc5744242d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 8 Jul 2014 15:18:47 +0100
Subject: [PATCH 06/77] ffmpeg: Add armv6 acceleration for imdct/fft used by
 ac3/aac

armv6: Accelerate ff_imdct_half for general case (mdct_bits != 6)

The previous implementation targeted DTS Coherent Acoustics, which only
requires mdct_bits == 6. This relatively small size lent itself to
unrolling the loops a small number of times, and encoding offsets
calculated at assembly time within the load/store instructions of each
iteration.

In the more general case (codecs such as AAC and AC3) much larger arrays
are used - mdct_bits == [8, 9, 11]. The old method does not scale for
these cases, so more integer registers are used with non-unrolled versions
of the loops (and with some stack spillage). The postrotation filter loop
is still unrolled by a factor of 2 to permit the double-buffering of some
VFP registers to facilitate overlap of neighbouring iterations.

I benchmarked the result by measuring the number of gperftools samples
that hit anywhere in the AAC decoder (starting from aac_decode_frame())
or specifically in ff_imdct_half_c / ff_imdct_half_vfp, for the same
example AAC stream:

                  Before          After
                  Mean   StdDev   Mean   StdDev  Confidence  Change
aac_decode_frame  2368.1 35.8     2117.2 35.3    100.0%      +11.8%
ff_imdct_half_*   457.5  22.4     251.2  16.2    100.0%      +82.1%

armv6: Accelerate ff_fft_calc for general case (nbits != 4)

The previous implementation targeted DTS Coherent Acoustics, which only
requires nbits == 4 (fft16()). This case was (and still is) linked directly
rather than being indirected through ff_fft_calc_vfp(), but now the full
range from radix-4 up to radix-65536 is available. This benefits other codecs
such as AAC and AC3.

The implementaion is based upon the C version, with each routine larger than
radix-16 calling a hierarchy of smaller FFT functions, then performing a
post-processing pass. This pass benefits a lot from loop unrolling to
counter the long pipelines in the VFP. A relaxed calling standard also
reduces the overhead of the call hierarchy, and avoiding the excessive
inlining performed by GCC probably helps with I-cache utilisation too.

I benchmarked the result by measuring the number of gperftools samples that
hit anywhere in the AAC decoder (starting from aac_decode_frame()) or
specifically in the FFT routines (fft4() to fft512() and pass()) for the
same sample AAC stream:

              Before          After
              Mean   StdDev   Mean   StdDev  Confidence  Change
Audio decode  2245.5 53.1     1599.6 43.8    100.0%      +40.4%
FFT routines  940.6  22.0     348.1  20.8    100.0%      +170.2%
---
 tools/depends/target/ffmpeg/Makefile               |   8 +-
 .../armv6-Accelerate-butterflies-float.patch       | 165 ++++++++++
 ...6-Accelerate-ff_fft_calc-for-general-case.patch | 361 +++++++++++++++++++++
 .../armv6-Accelerate-vector-fmul-window.patch      | 259 +++++++++++++++
 4 files changed, 792 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/armv6-Accelerate-butterflies-float.patch
 create mode 100644 tools/depends/target/ffmpeg/armv6-Accelerate-ff_fft_calc-for-general-case.patch
 create mode 100644 tools/depends/target/ffmpeg/armv6-Accelerate-vector-fmul-window.patch

diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 7ce982c..f205f70 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -1,6 +1,8 @@
 include ../../Makefile.include
 include FFMPEG-VERSION
-DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch
+DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch \
+      armv6-Accelerate-ff_fft_calc-for-general-case.patch \
+      armv6-Accelerate-vector-fmul-window.patch                       armv6-Accelerate-butterflies-float.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -64,6 +66,10 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); sed -i".bak" -e "s%pkg_config_default=pkg-config%export PKG_CONFIG_LIBDIR=$(PREFIX)/lib/pkgconfig \&\& pkg_config_default=$(NATIVEPREFIX)/bin/pkg-config%" configure
 	cd $(PLATFORM); patch -p3 < ../ffmpeg_Speed_up_wtv_index_creation.patch
+	cd $(PLATFORM); patch -p1 < ../armv6-Accelerate-ff_fft_calc-for-general-case.patch
+	cd $(PLATFORM); patch -p1 < ../armv6-Accelerate-vector-fmul-window.patch
+	cd $(PLATFORM); patch -p1 < ../armv6-Accelerate-butterflies-float.patch
+
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
 	./configure $(ffmpg_config)
diff --git a/tools/depends/target/ffmpeg/armv6-Accelerate-butterflies-float.patch b/tools/depends/target/ffmpeg/armv6-Accelerate-butterflies-float.patch
new file mode 100644
index 0000000..e1b6cd0
--- /dev/null
+++ b/tools/depends/target/ffmpeg/armv6-Accelerate-butterflies-float.patch
@@ -0,0 +1,165 @@
+From 46c74f06402ff196c3d35349a81423b0c2878527 Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Thu, 10 Jul 2014 17:51:55 +0100
+Subject: [PATCH] armv6: Accelerate butterflies_float
+
+I benchmarked the result by measuring the number of gperftools samples that
+hit anywhere in the AAC decoder (starting from aac_decode_frame()) or
+specifically in butterflies_float_c() / ff_butterflies_float_vfp() for the
+same sample AAC stream:
+
+                   Before          After
+                   Mean   StdDev   Mean   StdDev  Confidence  Change
+Audio decode       1542.8 43.7     1470.5 41.5    100.0%      +4.9%
+butterflies_float  130.0  11.9     70.2   12.1    100.0%      +85.2%
+---
+ libavutil/arm/float_dsp_init_vfp.c |   4 ++
+ libavutil/arm/float_dsp_vfp.S      | 116 +++++++++++++++++++++++++++++++++++++
+ 2 files changed, 120 insertions(+)
+
+diff --git a/libavutil/arm/float_dsp_init_vfp.c b/libavutil/arm/float_dsp_init_vfp.c
+index f44020e..61ff2ed 100644
+--- a/libavutil/arm/float_dsp_init_vfp.c
++++ b/libavutil/arm/float_dsp_init_vfp.c
+@@ -32,6 +32,8 @@ void ff_vector_fmul_window_vfp(float *dst, const float *src0,
+ void ff_vector_fmul_reverse_vfp(float *dst, const float *src0,
+                                 const float *src1, int len);
+
++void ff_butterflies_float_vfp(float *restrict v1, float *restrict v2, int len);
++
+ av_cold void ff_float_dsp_init_vfp(AVFloatDSPContext *fdsp, int cpu_flags)
+ {
+     if (!have_vfpv3(cpu_flags)) {
+@@ -39,4 +41,6 @@ av_cold void ff_float_dsp_init_vfp(AVFloatDSPContext *fdsp, int cpu_flags)
+         fdsp->vector_fmul_window = ff_vector_fmul_window_vfp;
+     }
+     fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_vfp;
++    if (!have_vfpv3(cpu_flags))
++        fdsp->butterflies_float = ff_butterflies_float_vfp;
+ }
+diff --git a/libavutil/arm/float_dsp_vfp.S b/libavutil/arm/float_dsp_vfp.S
+index c25588f..9f920aa 100644
+--- a/libavutil/arm/float_dsp_vfp.S
++++ b/libavutil/arm/float_dsp_vfp.S
+@@ -339,3 +339,119 @@ function ff_vector_fmul_reverse_vfp, export=1
+         vpop            {d8-d15}
+         bx              lr
+ endfunc
++
++/**
++ * ARM VFP implementation of 'butterflies_float_c' function
++ * Assume that len is a positive non-zero number
++ */
++@ void ff_butterflies_float_vfp(float *restrict v1, float *restrict v2, int len)
++function ff_butterflies_float_vfp, export=1
++BASE1   .req    a1
++BASE2   .req    a2
++LEN     .req    a3
++OLDFPSCR .req   a4
++
++        vpush   {s16-s31}
++        fmrx    OLDFPSCR, FPSCR
++
++        tst     LEN, #7
++        beq     4f                          @ common case: len is a multiple of 8
++
++        ldr     ip, =0x03000000             @ RunFast mode, scalar mode
++        fmxr    FPSCR, ip
++
++        tst     LEN, #1
++        beq     1f
++        vldmia  BASE1!, {s0}
++        vldmia  BASE2!, {s8}
++        vadd.f  s16, s0, s8
++        vsub.f  s24, s0, s8
++        vstr    s16, [BASE1, #0-4*1]
++        vstr    s24, [BASE2, #0-4*1]
++1:
++        tst     LEN, #2
++        beq     2f
++        vldmia  BASE1!, {s0-s1}
++        vldmia  BASE2!, {s8-s9}
++        vadd.f  s16, s0, s8
++        vadd.f  s17, s1, s9
++        vsub.f  s24, s0, s8
++        vsub.f  s25, s1, s9
++        vstr    d8, [BASE1, #0-8*1]    @ s16,s17
++        vstr    d12, [BASE2, #0-8*1]   @ s24,s25
++2:
++        tst     LEN, #4
++        beq     3f
++        vldmia  BASE1!, {s0-s1}
++        vldmia  BASE2!, {s8-s9}
++        vldmia  BASE1!, {s2-s3}
++        vldmia  BASE2!, {s10-s11}
++        vadd.f  s16, s0, s8
++        vadd.f  s17, s1, s9
++        vsub.f  s24, s0, s8
++        vsub.f  s25, s1, s9
++        vadd.f  s18, s2, s10
++        vadd.f  s19, s3, s11
++        vsub.f  s26, s2, s10
++        vsub.f  s27, s3, s11
++        vstr    d8, [BASE1, #0-16*1]    @ s16,s17
++        vstr    d12, [BASE2, #0-16*1]   @ s24,s25
++        vstr    d9, [BASE1, #8-16*1]    @ s18,s19
++        vstr    d13, [BASE2, #8-16*1]   @ s26,s27
++3:
++        bics    LEN, LEN, #7
++        beq     7f
++4:
++        ldr     ip, =0x03030000             @ RunFast mode, short vectors of length 4, stride 1
++        fmxr    FPSCR, ip
++
++        vldmia  BASE1!, {s0-s1}
++        vldmia  BASE2!, {s8-s9}
++        vldmia  BASE1!, {s2-s3}
++        vldmia  BASE2!, {s10-s11}
++        vadd.f  s16, s0, s8
++            vldmia  BASE1!, {s4-s5}
++            vldmia  BASE2!, {s12-s13}
++            vldmia  BASE1!, {s6-s7}
++            vldmia  BASE2!, {s14-s15}
++        vsub.f  s24, s0, s8
++            vadd.f  s20, s4, s12
++        subs    LEN, LEN, #8
++        beq     6f
++5:              vldmia  BASE1!, {s0-s3}
++                vldmia  BASE2!, {s8-s11}
++            vsub.f  s28, s4, s12
++        vstr    d8, [BASE1, #0-16*3]    @ s16,s17
++        vstr    d9, [BASE1, #8-16*3]    @ s18,s19
++        vstr    d12, [BASE2, #0-16*3]   @ s24,s25
++        vstr    d13, [BASE2, #8-16*3]   @ s26,s27
++                vadd.f  s16, s0, s8
++                    vldmia  BASE1!, {s4-s7}
++                    vldmia  BASE2!, {s12-s15}
++                vsub.f  s24, s0, s8
++            vstr    d10, [BASE1, #0-16*3]   @ s20,s21
++            vstr    d11, [BASE1, #8-16*3]   @ s22,s23
++            vstr    d14, [BASE2, #0-16*3]   @ s28,s29
++            vstr    d15, [BASE2, #8-16*3]   @ s30,s31
++                    vadd.f  s20, s4, s12
++        subs    LEN, LEN, #8
++        bne     5b
++6:                   vsub.f  s28, s4, s12
++                vstr    d8, [BASE1, #0-16*2]    @ s16,s17
++                vstr    d9, [BASE1, #8-16*2]    @ s18,s19
++                vstr    d12, [BASE2, #0-16*2]   @ s24,s25
++                vstr    d13, [BASE2, #8-16*2]   @ s26,s27
++                    vstr    d10, [BASE1, #0-16*1]   @ s20,s21
++                    vstr    d11, [BASE1, #8-16*1]   @ s22,s23
++                    vstr    d14, [BASE2, #0-16*1]   @ s28,s29
++                    vstr    d15, [BASE2, #8-16*1]   @ s30,s31
++7:
++        fmxr    FPSCR, OLDFPSCR
++        vpop    {s16-s31}
++        bx      lr
++
++        .unreq  BASE1
++        .unreq  BASE2
++        .unreq  LEN
++        .unreq  OLDFPSCR
++endfunc
+--
+1.9.3
diff --git a/tools/depends/target/ffmpeg/armv6-Accelerate-ff_fft_calc-for-general-case.patch b/tools/depends/target/ffmpeg/armv6-Accelerate-ff_fft_calc-for-general-case.patch
new file mode 100644
index 0000000..ccf9743
--- /dev/null
+++ b/tools/depends/target/ffmpeg/armv6-Accelerate-ff_fft_calc-for-general-case.patch
@@ -0,0 +1,361 @@
+From 883fb70c576181dbdf41e21872f1d0794024a6b4 Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Mon, 7 Jul 2014 15:29:09 +0100
+Subject: [PATCH] armv6: Accelerate ff_fft_calc for general case (nbits != 4)
+
+The previous implementation targeted DTS Coherent Acoustics, which only
+requires nbits == 4 (fft16()). This case was (and still is) linked directly
+rather than being indirected through ff_fft_calc_vfp(), but now the full
+range from radix-4 up to radix-65536 is available. This benefits other codecs
+such as AAC and AC3.
+
+The implementaion is based upon the C version, with each routine larger than
+radix-16 calling a hierarchy of smaller FFT functions, then performing a
+post-processing pass. This pass benefits a lot from loop unrolling to
+counter the long pipelines in the VFP. A relaxed calling standard also
+reduces the overhead of the call hierarchy, and avoiding the excessive
+inlining performed by GCC probably helps with I-cache utilisation too.
+
+I benchmarked the result by measuring the number of gperftools samples that
+hit anywhere in the AAC decoder (starting from aac_decode_frame()) or
+specifically in the FFT routines (fft4() to fft512() and pass()) for the
+same sample AAC stream:
+
+              Before          After
+              Mean   StdDev   Mean   StdDev  Confidence  Change
+Audio decode  2245.5 53.1     1599.6 43.8    100.0%      +40.4%
+FFT routines  940.6  22.0     348.1  20.8    100.0%      +170.2%
+---
+ libavcodec/arm/fft_init_arm.c |   8 +-
+ libavcodec/arm/fft_vfp.S      | 261 +++++++++++++++++++++++++++++++++++++++---
+ 2 files changed, 252 insertions(+), 17 deletions(-)
+
+diff --git a/libavcodec/arm/fft_init_arm.c b/libavcodec/arm/fft_init_arm.c
+index 3a3d1a7..bc143c1 100644
+--- a/libavcodec/arm/fft_init_arm.c
++++ b/libavcodec/arm/fft_init_arm.c
+@@ -23,6 +23,8 @@
+ #include "libavcodec/rdft.h"
+ #include "libavcodec/synth_filter.h"
+
++void ff_fft_calc_vfp(FFTContext *s, FFTComplex *z);
++
+ void ff_fft_permute_neon(FFTContext *s, FFTComplex *z);
+ void ff_fft_calc_neon(FFTContext *s, FFTComplex *z);
+
+@@ -38,10 +40,10 @@ av_cold void ff_fft_init_arm(FFTContext *s)
+ {
+     int cpu_flags = av_get_cpu_flags();
+
+-    if (have_vfp(cpu_flags)) {
++    if (have_vfp(cpu_flags) && !have_vfpv3(cpu_flags)) {
++        s->fft_calc     = ff_fft_calc_vfp;
+ #if CONFIG_MDCT
+-        if (!have_vfpv3(cpu_flags))
+-            s->imdct_half   = ff_imdct_half_vfp;
++        s->imdct_half   = ff_imdct_half_vfp;
+ #endif
+     }
+
+diff --git a/libavcodec/arm/fft_vfp.S b/libavcodec/arm/fft_vfp.S
+index 7845ebb..186bed9 100644
+--- a/libavcodec/arm/fft_vfp.S
++++ b/libavcodec/arm/fft_vfp.S
+@@ -21,8 +21,9 @@
+
+ #include "libavutil/arm/asm.S"
+
+-@ TODO: * FFTs wider than 16
+-@       * dispatch code
++@ The fftx_internal_vfp versions of the functions obey a modified AAPCS:
++@ VFP is in RunFast mode, vector length 4, stride 1 thoroughout, and
++@ all single-precision VFP registers may be corrupted on exit.
+
+ function fft4_vfp
+         vldr    d0, [a1, #0*2*4]   @ s0,s1   = z[0]
+@@ -131,18 +132,22 @@ endfunc
+              vstr    d9, [a1, #3 * 2*4]
+ .endm
+
++function fft8_internal_vfp
++        macro_fft8_head
++        macro_fft8_tail
++        bx      lr
++endfunc
++
+ function fft8_vfp
+         ldr     a3, =0x03030000     @ RunFast mode, vector length 4, stride 1
+         fmrx    a2, FPSCR
+         fmxr    FPSCR, a3
+         vpush   {s16-s31}
+-
+-        macro_fft8_head
+-        macro_fft8_tail
+-
++        mov     ip, lr
++        bl      fft8_internal_vfp
+         vpop    {s16-s31}
+         fmxr    FPSCR, a2
+-        bx      lr
++        bx      ip
+ endfunc
+
+ .align 3
+@@ -153,12 +158,7 @@ cos1pi8:    @ cos(1*pi/8) = sqrt(2+sqrt(2))/2
+ cos3pi8:    @ cos(2*pi/8) = sqrt(2-sqrt(2))/2
+         .float  0.3826834261417388916015625
+
+-function ff_fft16_vfp, export=1
+-        ldr     a3, =0x03030000     @ RunFast mode, vector length 4, stride 1
+-        fmrx    a2, FPSCR
+-        fmxr    FPSCR, a3
+-        vpush   {s16-s31}
+-
++function fft16_internal_vfp
+         macro_fft8_head
+         @ FFT4(z+8)
+         vldr    d10, [a1, #8 * 2*4]
+@@ -292,7 +292,240 @@ function ff_fft16_vfp, export=1
+               vstr    d8, [a1, #0 * 2*4]
+               vstr    d9, [a1, #4 * 2*4]
+
++        bx      lr
++endfunc
++
++function ff_fft16_vfp, export=1
++        ldr     a3, =0x03030000     @ RunFast mode, vector length 4, stride 1
++        fmrx    a2, FPSCR
++        fmxr    FPSCR, a3
++        vpush   {s16-s31}
++        mov     ip, lr
++        bl      fft16_internal_vfp
+         vpop    {s16-s31}
+         fmxr    FPSCR, a2
+-        bx      lr
++        bx      ip
++endfunc
++
++.macro pass n, z0, z1, z2, z3
++        add     v6, v5, #4*2*\n
++        @ TRANSFORM_ZERO(z[0],z[o1],z[o2],z[o3])
++            @ TRANSFORM(z[1],z[o1+1],z[o2+1],z[o3+1],wre[1],wim[-1])
++                @ TRANSFORM(z[0],z[o1],z[o2],z[o3],wre[0],wim[0])
++                    @ TRANSFORM(z[1],z[o1+1],z[o2+1],z[o3+1],wre[1],wim[-1])
++            vldr    d8, [\z2, #8*(o2+1)]        @ s16,s17
++            vldmdb  v6!, {s2}
++            vldr    d9, [\z3, #8*(o3+1)]        @ s18,s19
++            vldmia  v5!, {s0,s1}                @ s0 is unused
++        vldr    s7, [\z2, #8*o2]            @ t1
++            vmul.f  s20, s16, s2                @ vector * scalar
++        vldr    s0, [\z3, #8*o3]            @ t5
++        vldr    s6, [\z2, #8*o2+4]          @ t2
++        vldr    s3, [\z3, #8*o3+4]          @ t6
++            vmul.f  s16, s16, s1                @ vector * scalar
++        ldr     a4, =\n-1
++1:      add     \z0, \z0, #8*2
++ .if \n*4*2 >= 512
++        add     \z1, \z1, #8*2
++ .endif
++ .if \n*4*2 >= 256
++        add     \z2, \z2, #8*2
++ .endif
++ .if \n*4*2 >= 512
++        add     \z3, \z3, #8*2
++ .endif
++        @ up to 2 stalls (VFP vector issuing / waiting for s0)
++        @ depending upon whether this is the first iteration and
++        @ how many add instructions are inserted above
++        vadd.f  s4, s0, s7                  @ t5
++        vadd.f  s5, s6, s3                  @ t6
++        vsub.f  s6, s6, s3                  @ t4
++        vsub.f  s7, s0, s7                  @ t3
++        vldr    d6, [\z0, #8*0-8*2]         @ s12,s13
++            vadd.f  s0, s16, s21                @ t1
++        vldr    d7, [\z1, #8*o1-8*2]        @ s14,s15
++            vsub.f  s1, s18, s23                @ t5
++        vadd.f  s8, s4, s12                 @ vector + vector
++        @ stall (VFP vector issuing)
++        @ stall (VFP vector issuing)
++        @ stall (VFP vector issuing)
++        vsub.f  s4, s12, s4
++        vsub.f  s5, s13, s5
++        vsub.f  s6, s14, s6
++        vsub.f  s7, s15, s7
++            vsub.f  s2, s17, s20                @ t2
++            vadd.f  s3, s19, s22                @ t6
++        vstr    d4, [\z0, #8*0-8*2]         @ s8,s9
++        vstr    d5, [\z1, #8*o1-8*2]        @ s10,s11
++        @ stall (waiting for s5)
++        vstr    d2, [\z2, #8*o2-8*2]        @ s4,s5
++            vadd.f  s4, s1, s0                  @ t5
++        vstr    d3, [\z3, #8*o3-8*2]        @ s6,s7
++            vsub.f  s7, s1, s0                  @ t3
++            vadd.f  s5, s2, s3                  @ t6
++            vsub.f  s6, s2, s3                  @ t4
++            vldr    d6, [\z0, #8*1-8*2]         @ s12,s13
++            vldr    d7, [\z1, #8*(o1+1)-8*2]    @ s14,s15
++                vldr    d4, [\z2, #8*o2]            @ s8,s9
++                vldmdb  v6!, {s2,s3}
++                vldr    d5, [\z3, #8*o3]            @ s10,s11
++            vadd.f  s20, s4, s12                @ vector + vector
++                vldmia  v5!, {s0,s1}
++                    vldr    d8, [\z2, #8*(o2+1)]        @ s16,s17
++            @ stall (VFP vector issuing)
++            vsub.f  s4, s12, s4
++            vsub.f  s5, s13, s5
++            vsub.f  s6, s14, s6
++            vsub.f  s7, s15, s7
++                vmul.f  s12, s8, s3                 @ vector * scalar
++            vstr    d10, [\z0, #8*1-8*2]        @ s20,s21
++                    vldr    d9, [\z3, #8*(o3+1)]        @ s18,s19
++            vstr    d11, [\z1, #8*(o1+1)-8*2]   @ s22,s23
++                vmul.f  s8, s8, s0                  @ vector * scalar
++            vstr    d2, [\z2, #8*(o2+1)-8*2]    @ s4,s5
++            @ stall (waiting for s7)
++            vstr    d3, [\z3, #8*(o3+1)-8*2]    @ s6,s7
++                    vmul.f  s20, s16, s2                @ vector * scalar
++                @ stall (VFP vector issuing)
++                @ stall (VFP vector issuing)
++                @ stall (VFP vector issuing)
++                vadd.f  s7, s8, s13                 @ t1
++                vsub.f  s6, s9, s12                 @ t2
++                vsub.f  s0, s10, s15                @ t5
++                vadd.f  s3, s11, s14                @ t6
++                    vmul.f  s16, s16, s1                @ vector * scalar
++        subs    a4, a4, #1
++        bne     1b
++        @ What remains is identical to the first two indentations of
++        @ the above, but without the increment of z
++        vadd.f  s4, s0, s7                  @ t5
++        vadd.f  s5, s6, s3                  @ t6
++        vsub.f  s6, s6, s3                  @ t4
++        vsub.f  s7, s0, s7                  @ t3
++        vldr    d6, [\z0, #8*0]             @ s12,s13
++            vadd.f  s0, s16, s21                @ t1
++        vldr    d7, [\z1, #8*o1]            @ s14,s15
++            vsub.f  s1, s18, s23                @ t5
++        vadd.f  s8, s4, s12                 @ vector + vector
++        vsub.f  s4, s12, s4
++        vsub.f  s5, s13, s5
++        vsub.f  s6, s14, s6
++        vsub.f  s7, s15, s7
++            vsub.f  s2, s17, s20                @ t2
++            vadd.f  s3, s19, s22                @ t6
++        vstr    d4, [\z0, #8*0]             @ s8,s9
++        vstr    d5, [\z1, #8*o1]            @ s10,s11
++        vstr    d2, [\z2, #8*o2]            @ s4,s5
++            vadd.f  s4, s1, s0                  @ t5
++        vstr    d3, [\z3, #8*o3]            @ s6,s7
++            vsub.f  s7, s1, s0                  @ t3
++            vadd.f  s5, s2, s3                  @ t6
++            vsub.f  s6, s2, s3                  @ t4
++            vldr    d6, [\z0, #8*1]             @ s12,s13
++            vldr    d7, [\z1, #8*(o1+1)]        @ s14,s15
++            vadd.f  s20, s4, s12                @ vector + vector
++            vsub.f  s4, s12, s4
++            vsub.f  s5, s13, s5
++            vsub.f  s6, s14, s6
++            vsub.f  s7, s15, s7
++            vstr    d10, [\z0, #8*1]            @ s20,s21
++            vstr    d11, [\z1, #8*(o1+1)]       @ s22,s23
++            vstr    d2, [\z2, #8*(o2+1)]        @ s4,s5
++            vstr    d3, [\z3, #8*(o3+1)]        @ s6,s7
++.endm
++
++.macro fft_internal_vfp name, name2, name4, costable, n
++function \name
++ .if \n >= 512
++        push    {v1-v6,lr}
++ .elseif \n >= 256
++        push    {v1-v2,v5-v6,lr}
++ .else
++        push    {v1,v5-v6,lr}
++ .endif
++        mov     v1, a1
++        bl      \name2
++        add     a1, v1, #8*(\n/4)*2
++        bl      \name4
++        ldr     v5, =\costable
++        add     a1, v1, #8*(\n/4)*3
++        bl      \name4
++ .if \n >= 512
++  .set o1, 0*(\n/4/2)
++  .set o2, 0*(\n/4/2)
++  .set o3, 0*(\n/4/2)
++        add     v2, v1, #8*2*(\n/4/2)
++        add     v3, v1, #8*4*(\n/4/2)
++        add     v4, v1, #8*6*(\n/4/2)
++        pass    (\n/4/2), v1, v2, v3, v4
++        pop     {v1-v6,pc}
++ .elseif \n >= 256
++  .set o1, 2*(\n/4/2)
++  .set o2, 0*(\n/4/2)
++  .set o3, 2*(\n/4/2)
++        add     v2, v1, #8*4*(\n/4/2)
++        pass    (\n/4/2), v1, v1, v2, v2
++        pop     {v1-v2,v5-v6,pc}
++ .else
++  .set o1, 2*(\n/4/2)
++  .set o2, 4*(\n/4/2)
++  .set o3, 6*(\n/4/2)
++        pass    (\n/4/2), v1, v1, v1, v1
++        pop     {v1,v5-v6,pc}
++ .endif
++endfunc
++.endm
++
++#define DECL_FFT(n,n2,n4)               \
++fft_internal_vfp  fft##n##_internal_vfp, fft##n2##_internal_vfp, fft##n4##_internal_vfp, ff_cos_##n, n ;\
++                                       ;\
++function fft##n##_vfp                  ;\
++        ldr     a3, =0x03030000 /* RunFast mode, vector length 4, stride 1 */ ;\
++        fmrx    a2, FPSCR              ;\
++        fmxr    FPSCR, a3              ;\
++        vpush   {s16-s31}              ;\
++        mov     ip, lr                 ;\
++        bl      fft##n##_internal_vfp  ;\
++        vpop    {s16-s31}              ;\
++        fmxr    FPSCR, a2              ;\
++        bx      ip                     ;\
++endfunc                                ;\
++                                       ;\
++.ltorg
++
++DECL_FFT(32,16,8)
++DECL_FFT(64,32,16)
++DECL_FFT(128,64,32)
++DECL_FFT(256,128,64)
++DECL_FFT(512,256,128)
++DECL_FFT(1024,512,256)
++DECL_FFT(2048,1024,512)
++DECL_FFT(4096,2048,1024)
++DECL_FFT(8192,4096,2048)
++DECL_FFT(16384,8192,4096)
++DECL_FFT(32768,16384,8192)
++DECL_FFT(65536,32768,16384)
++
++function ff_fft_calc_vfp, export=1
++        ldr     ip, [a1, #0]    @ nbits
++        mov     a1, a2
++        ldr     ip, [pc, ip, lsl #2]
++        bx      ip
++        .word   0
++        .word   0
++        .word   fft4_vfp
++        .word   fft8_vfp
++        .word   ff_fft16_vfp    @ this one alone is exported
++        .word   fft32_vfp
++        .word   fft64_vfp
++        .word   fft128_vfp
++        .word   fft256_vfp
++        .word   fft512_vfp
++        .word   fft1024_vfp
++        .word   fft2048_vfp
++        .word   fft4096_vfp
++        .word   fft8192_vfp
++        .word   fft16384_vfp
++        .word   fft32768_vfp
++        .word   fft65536_vfp
+ endfunc
+--
+1.9.3
diff --git a/tools/depends/target/ffmpeg/armv6-Accelerate-vector-fmul-window.patch b/tools/depends/target/ffmpeg/armv6-Accelerate-vector-fmul-window.patch
new file mode 100644
index 0000000..db0118f
--- /dev/null
+++ b/tools/depends/target/ffmpeg/armv6-Accelerate-vector-fmul-window.patch
@@ -0,0 +1,259 @@
+From 1f5c397bdd4ebd2c9ed04488fcf52d77a5db3e88 Mon Sep 17 00:00:00 2001
+From: Ben Avison <bavison@riscosopen.org>
+Date: Thu, 10 Jul 2014 13:01:47 +0100
+Subject: [PATCH] armv6: Accelerate vector_fmul_window
+
+I benchmarked the result by measuring the number of gperftools samples that
+hit anywhere in the AAC decoder (starting from aac_decode_frame()) or
+specifically in vector_fmul_window_c() / ff_vector_fmul_window_vfp() for the
+same sample AAC stream:
+
+                    Before          After
+                    Mean   StdDev   Mean   StdDev  Confidence  Change
+Audio decode        1598.2 47.4     1529.2 25.4    100.0%      +4.5%
+vector_fmul_window  244.0  22.1     188.9  22.3    100.0%      +29.2%
+---
+ libavutil/arm/float_dsp_init_vfp.c |   7 +-
+ libavutil/arm/float_dsp_vfp.S      | 204 +++++++++++++++++++++++++++++++++++++
+ 2 files changed, 210 insertions(+), 1 deletion(-)
+
+diff --git a/libavutil/arm/float_dsp_init_vfp.c b/libavutil/arm/float_dsp_init_vfp.c
+index 31cb6ae..f44020e 100644
+--- a/libavutil/arm/float_dsp_init_vfp.c
++++ b/libavutil/arm/float_dsp_init_vfp.c
+@@ -26,12 +26,17 @@
+ void ff_vector_fmul_vfp(float *dst, const float *src0, const float *src1,
+                         int len);
+
++void ff_vector_fmul_window_vfp(float *dst, const float *src0,
++                               const float *src1, const float *win, int len);
++
+ void ff_vector_fmul_reverse_vfp(float *dst, const float *src0,
+                                 const float *src1, int len);
+
+ av_cold void ff_float_dsp_init_vfp(AVFloatDSPContext *fdsp, int cpu_flags)
+ {
+-    if (!have_vfpv3(cpu_flags))
++    if (!have_vfpv3(cpu_flags)) {
+         fdsp->vector_fmul = ff_vector_fmul_vfp;
++        fdsp->vector_fmul_window = ff_vector_fmul_window_vfp;
++    }
+     fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_vfp;
+ }
+diff --git a/libavutil/arm/float_dsp_vfp.S b/libavutil/arm/float_dsp_vfp.S
+index 8295280..c25588f 100644
+--- a/libavutil/arm/float_dsp_vfp.S
++++ b/libavutil/arm/float_dsp_vfp.S
+@@ -68,6 +68,210 @@ function ff_vector_fmul_vfp, export=1
+ endfunc
+
+ /**
++ * ARM VFP implementation of 'vector_fmul_window_c' function
++ * Assume that len is a positive non-zero number
++ */
++@ void ff_vector_fmul_window_vfp(float *dst, const float *src0,
++@                                const float *src1, const float *win, int len)
++function ff_vector_fmul_window_vfp, export=1
++DST0    .req    a1
++SRC0    .req    a2
++SRC1    .req    a3
++WIN0    .req    a4
++LEN     .req    v1
++DST1    .req    v2
++WIN1    .req    v3
++OLDFPSCR .req   ip
++
++        push    {v1-v3,lr}
++        ldr     LEN, [sp, #4*4+0]
++        vpush   {s16-s31}
++        fmrx    OLDFPSCR, FPSCR
++        add     DST1, DST0, LEN, lsl #3
++        add     SRC1, SRC1, LEN, lsl #2
++        add     WIN1, WIN0, LEN, lsl #3
++
++        tst     LEN, #7
++        beq     4f                          @ common case: len is a multiple of 8
++
++        ldr     lr, =0x03000000             @ RunFast mode, scalar mode
++        fmxr    FPSCR, lr
++
++        tst     LEN, #1
++        beq     1f
++        vldmdb  WIN1!, {s0}
++        vldmia  SRC0!, {s8}
++        vldmia  WIN0!, {s16}
++        vmul.f  s24, s0, s8
++        vldmdb  SRC1!, {s20}
++        vmul.f  s8, s16, s8
++        vmls.f  s24, s16, s20
++        vmla.f  s8, s0, s20
++        vstmia  DST0!, {s24}
++        vstmdb  DST1!, {s8}
++1:
++        tst     LEN, #2
++        beq     2f
++        vldmdb  WIN1!, {s0}
++        vldmdb  WIN1!, {s1}
++        vldmia  SRC0!, {s8-s9}
++        vldmia  WIN0!, {s16-s17}
++        vmul.f  s24, s0, s8
++        vmul.f  s25, s1, s9
++        vldmdb  SRC1!, {s20}
++        vldmdb  SRC1!, {s21}
++        vmul.f  s8, s16, s8
++        vmul.f  s9, s17, s9
++        vmls.f  s24, s16, s20
++        vmls.f  s25, s17, s21
++        vmla.f  s8, s0, s20
++        vmla.f  s9, s1, s21
++        vstmia  DST0!, {s24-s25}
++        vstmdb  DST1!, {s8}
++        vstmdb  DST1!, {s9}
++2:
++        tst     LEN, #4
++        beq     3f
++        vldmdb  WIN1!, {s0}
++        vldmdb  WIN1!, {s1}
++        vldmdb  WIN1!, {s2}
++        vldmdb  WIN1!, {s3}
++        vldmia  SRC0!, {s8-s11}
++        vldmia  WIN0!, {s16-s19}
++        vmul.f  s24, s0, s8
++        vmul.f  s25, s1, s9
++        vmul.f  s26, s2, s10
++        vmul.f  s27, s3, s11
++        vldmdb  SRC1!, {s20}
++        vldmdb  SRC1!, {s21}
++        vldmdb  SRC1!, {s22}
++        vldmdb  SRC1!, {s23}
++        vmul.f  s8, s16, s8
++        vmul.f  s9, s17, s9
++        vmul.f  s10, s18, s10
++        vmul.f  s11, s19, s11
++        vmls.f  s24, s16, s20
++        vmls.f  s25, s17, s21
++        vmls.f  s26, s18, s22
++        vmls.f  s27, s19, s23
++        vmla.f  s8, s0, s20
++        vmla.f  s9, s1, s21
++        vmla.f  s10, s2, s22
++        vmla.f  s11, s3, s23
++        vstmia  DST0!, {s24-s27}
++        vstmdb  DST1!, {s8}
++        vstmdb  DST1!, {s9}
++        vstmdb  DST1!, {s10}
++        vstmdb  DST1!, {s11}
++3:
++        bics    LEN, LEN, #7
++        beq     7f
++4:
++        ldr     lr, =0x03030000             @ RunFast mode, short vectors of length 4, stride 1
++        fmxr    FPSCR, lr
++
++        vldmdb  WIN1!, {s0}
++        vldmdb  WIN1!, {s1}
++        vldmdb  WIN1!, {s2}
++        vldmdb  WIN1!, {s3}
++        vldmia  SRC0!, {s8-s11}
++        vldmia  WIN0!, {s16-s19}
++        vmul.f  s24, s0, s8                     @ vector * vector
++        vldmdb  SRC1!, {s20}
++        vldmdb  SRC1!, {s21}
++        vldmdb  SRC1!, {s22}
++        vldmdb  SRC1!, {s23}
++        vmul.f  s8, s16, s8                     @ vector * vector
++        vmls.f  s24, s16, s20                   @ vector * vector
++            vldmdb  WIN1!, {s4}
++            vldmdb  WIN1!, {s5}
++            vldmdb  WIN1!, {s6}
++            vldmdb  WIN1!, {s7}
++            vldmia  SRC0!, {s12-s13}
++        vmla.f  s8, s0, s20                     @ vector * vector
++            vldmia  SRC0!, {s14-s15}
++        subs    LEN, LEN, #8
++        beq     6f
++5:          vldmia  WIN0!, {s20-s23}
++            vmul.f  s28, s4, s12                @ vector * vector
++        vstmia  DST0!, {s24-s25}
++            vldmdb  SRC1!, {s16}
++            vldmdb  SRC1!, {s17}
++            vldmdb  SRC1!, {s18}
++            vldmdb  SRC1!, {s19}
++            vmul.f  s12, s20, s12               @ vector * vector
++        vstmia  DST0!, {s26-s27}
++        vstmdb  DST1!, {s8}
++        vstmdb  DST1!, {s9}
++        vstmdb  DST1!, {s10}
++        vstmdb  DST1!, {s11}
++            vmls.f  s28, s20, s16               @ vector * vector
++                vldmdb  WIN1!, {s0}
++                vldmdb  WIN1!, {s1}
++                vldmdb  WIN1!, {s2}
++                vldmdb  WIN1!, {s3}
++                vldmia  SRC0!, {s8-s9}
++            vmla.f  s12, s4, s16                @ vector * vector
++                vldmia  SRC0!, {s10-s11}
++        subs    LEN, LEN, #8
++                vldmia  WIN0!, {s16-s19}
++                vmul.f  s24, s0, s8             @ vector * vector
++            vstmia  DST0!, {s28-s29}
++                vldmdb  SRC1!, {s20}
++                vldmdb  SRC1!, {s21}
++                vldmdb  SRC1!, {s22}
++                vldmdb  SRC1!, {s23}
++                vmul.f  s8, s16, s8             @ vector * vector
++            vstmia  DST0!, {s30-s31}
++            vstmdb  DST1!, {s12}
++            vstmdb  DST1!, {s13}
++            vstmdb  DST1!, {s14}
++            vstmdb  DST1!, {s15}
++                vmls.f  s24, s16, s20           @ vector * vector
++                    vldmdb  WIN1!, {s4}
++                    vldmdb  WIN1!, {s5}
++                    vldmdb  WIN1!, {s6}
++                    vldmdb  WIN1!, {s7}
++                    vldmia  SRC0!, {s12-s13}
++                vmla.f  s8, s0, s20             @ vector * vector
++                    vldmia  SRC0!, {s14-s15}
++        bne     5b
++6:                  vldmia  WIN0!, {s20-s23}
++                    vmul.f  s28, s4, s12        @ vector * vector
++                vstmia  DST0!, {s24-s25}
++                    vldmdb  SRC1!, {s16}
++                    vldmdb  SRC1!, {s17}
++                    vldmdb  SRC1!, {s18}
++                    vldmdb  SRC1!, {s19}
++                    vmul.f  s12, s20, s12       @ vector * vector
++                vstmia  DST0!, {s26-s27}
++                vstmdb  DST1!, {s8}
++                vstmdb  DST1!, {s9}
++                vstmdb  DST1!, {s10}
++                vstmdb  DST1!, {s11}
++                    vmls.f  s28, s20, s16       @ vector * vector
++                    vmla.f  s12, s4, s16        @ vector * vector
++                    vstmia  DST0!, {s28-s31}
++                    vstmdb  DST1!, {s12}
++                    vstmdb  DST1!, {s13}
++                    vstmdb  DST1!, {s14}
++                    vstmdb  DST1!, {s15}
++7:
++        fmxr    FPSCR, OLDFPSCR
++        vpop    {s16-s31}
++        pop     {v1-v3,pc}
++
++        .unreq  DST0
++        .unreq  SRC0
++        .unreq  SRC1
++        .unreq  WIN0
++        .unreq  LEN
++        .unreq  OLDFPSCR
++        .unreq  DST1
++        .unreq  WIN1
++endfunc
++
++/**
+  * ARM VFP optimized implementation of 'vector_fmul_reverse_c' function.
+  * Assume that len is a positive number and is multiple of 8
+  */
+--
+1.9.3

From 472c348860f3aa6b39339dfea7e1a61a76ad9a45 Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:49:17 +1300
Subject: [PATCH 07/77] adds GetTvShowSeasons

---
 xbmc/video/VideoDatabase.cpp | 30 ++++++++++++++++++++++++------
 xbmc/video/VideoDatabase.h   |  1 +
 2 files changed, 25 insertions(+), 6 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 6ed419d..131b598 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -4213,7 +4213,7 @@ bool CVideoDatabase::RemoveArtForItem(int mediaId, const MediaType &mediaType, c
   return result;
 }
 
-bool CVideoDatabase::GetTvShowSeasonArt(int showId, map<int, map<string, string> > &seasonArt)
+bool CVideoDatabase::GetTvShowSeasons(int showId, map<int, int> &seasons)
 {
   try
   {
@@ -4224,19 +4224,37 @@ bool CVideoDatabase::GetTvShowSeasonArt(int showId, map<int, map<string, string>
     CStdString sql = PrepareSQL("select idSeason,season from seasons where idShow=%i", showId);
     m_pDS2->query(sql.c_str());
 
-    vector< pair<int, int> > seasons;
+    seasons.clear();
     while (!m_pDS2->eof())
     {
-      seasons.push_back(make_pair(m_pDS2->fv(0).get_asInt(), m_pDS2->fv(1).get_asInt()));
+      seasons.insert(make_pair(m_pDS2->fv(1).get_asInt(), m_pDS2->fv(0).get_asInt()));
       m_pDS2->next();
     }
     m_pDS2->close();
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s(%d) failed", __FUNCTION__, showId);
+  }
+  return false;
+}
+
+bool CVideoDatabase::GetTvShowSeasonArt(int showId, map<int, map<string, string> > &seasonArt)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS2.get()) return false; // using dataset 2 as we're likely called in loops on dataset 1
+
+    map<int, int> seasons;
+    GetTvShowSeasons(showId, seasons);
 
-    for (vector< pair<int,int> >::const_iterator i = seasons.begin(); i != seasons.end(); ++i)
+    for (map<int, int>::const_iterator i = seasons.begin(); i != seasons.end(); ++i)
     {
       map<string, string> art;
-      GetArtForItem(i->first, MediaTypeSeason, art);
-      seasonArt.insert(make_pair(i->second,art));
+      GetArtForItem(i->second, MediaTypeSeason, art);
+      seasonArt.insert(make_pair(i->first,art));
     }
     return true;
   }
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 78259ed..cbb26b7 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -746,6 +746,7 @@ class CVideoDatabase : public CDatabase
   std::string GetArtForItem(int mediaId, const MediaType &mediaType, const std::string &artType);
   bool RemoveArtForItem(int mediaId, const MediaType &mediaType, const std::string &artType);
   bool RemoveArtForItem(int mediaId, const MediaType &mediaType, const std::set<std::string> &artTypes);
+  bool GetTvShowSeasons(int showId, std::map<int, int> &seasons);
   bool GetTvShowSeasonArt(int mediaId, std::map<int, std::map<std::string, std::string> > &seasonArt);
   bool GetArtTypes(const MediaType &mediaType, std::vector<std::string> &artTypes);
 

From 4873479f1b979e3e42de7f425645b8047748525d Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:50:10 +1300
Subject: [PATCH 08/77] move AddSeason() public.

---
 xbmc/video/VideoDatabase.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index cbb26b7..1a79c00 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -757,6 +757,7 @@ class CVideoDatabase : public CDatabase
 
   virtual bool GetFilter(CDbUrl &videoUrl, Filter &filter, SortDescription &sorting);
 
+  int AddSeason(int showID, int season);
   int AddSet(const CStdString& strSet);
   void ClearMovieSet(int idMovie);
   void SetMovieSet(int idMovie, int idSet);
@@ -787,7 +788,6 @@ class CVideoDatabase : public CDatabase
 
   int AddTvShow();
   int AddMusicVideo(const CStdString& strFilenameAndPath);
-  int AddSeason(int showID, int season);
 
   /*! \brief Adds a path to the tvshow link table.
    \param idShow the id of the show.

From 8d4bf50d6ec30ae5760bfc08ce63198775b55399 Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:48:24 +1300
Subject: [PATCH 09/77] adds GetArt function to (video) scraper, allowing art
 to be fetched given the video identifier.

---
 xbmc/addons/Scraper.cpp            | 38 ++++++++++++++++++++++++++++++++++++++
 xbmc/addons/Scraper.h              |  3 +++
 xbmc/video/VideoInfoDownloader.cpp |  5 +++++
 xbmc/video/VideoInfoDownloader.h   |  7 +++++++
 4 files changed, 53 insertions(+)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index 76d5248..f3f2930 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -924,6 +924,44 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
   return vcep;
 }
 
+// takes URL; returns true and populates art XML details on success, false otherwise
+bool CScraper::GetArt(XFILE::CCurlFile &fcurl, const std::string &id, CVideoInfoTag &video)
+{
+  CLog::Log(LOGDEBUG, "%s: Reading art for '%s' using %s scraper "
+            "(file: '%s', content: '%s', version: '%s')", __FUNCTION__, id.c_str(), Name().c_str(), Path().c_str(),
+            ADDON::TranslateContent(Content()).c_str(), Version().asString().c_str());
+
+  video.Reset();
+  vector<string> vcsIn;
+  CScraperUrl scurl;
+  vcsIn.push_back(id);
+  vector<string> vcsOut = RunNoThrow("GetArt", scurl, fcurl, &vcsIn);
+
+  // parse XML output
+  bool fRet(false);
+  for (vector<string>::const_iterator i = vcsOut.begin(); i != vcsOut.end(); ++i)
+  {
+    CXBMCTinyXML doc;
+    doc.Parse(*i, TIXML_ENCODING_UTF8);
+    if (!doc.RootElement())
+    {
+      CLog::Log(LOGERROR, "%s: Unable to parse XML", __FUNCTION__);
+      continue;
+    }
+
+    TiXmlHandle xhDoc(&doc);
+    TiXmlElement *pxeDetails = xhDoc.FirstChild("details").Element();
+    if (!pxeDetails)
+    {
+      CLog::Log(LOGERROR, "%s: Invalid XML file (want <details>)", __FUNCTION__);
+      continue;
+    }
+    video.Load(pxeDetails, true/*fChain*/);
+    fRet = true;  // but don't exit in case of chaining
+  }
+  return fRet;
+}
+
 // takes URL; returns true and populates video details on success, false otherwise
 bool CScraper::GetVideoDetails(XFILE::CCurlFile &fcurl, const CScraperUrl &scurl,
   bool fMovie/*else episode*/, CVideoInfoTag &video)
diff --git a/xbmc/addons/Scraper.h b/xbmc/addons/Scraper.h
index c7274f2..5df5296 100644
--- a/xbmc/addons/Scraper.h
+++ b/xbmc/addons/Scraper.h
@@ -18,6 +18,8 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
+
+#include <string>
 #include "addons/Addon.h"
 #include "XBDateTime.h"
 #include "utils/ScraperUrl.h"
@@ -146,6 +148,7 @@ class CScraper : public CAddon
     CAlbum &album);
   bool GetArtistDetails(XFILE::CCurlFile &fcurl, const CScraperUrl &scurl,
     const std::string &sSearch, CArtist &artist);
+  bool GetArt(XFILE::CCurlFile &fcurl, const std::string &id, CVideoInfoTag &video);
 
 private:
   CScraper(const CScraper &rhs);
diff --git a/xbmc/video/VideoInfoDownloader.cpp b/xbmc/video/VideoInfoDownloader.cpp
index f33ac8a..5d84734 100644
--- a/xbmc/video/VideoInfoDownloader.cpp
+++ b/xbmc/video/VideoInfoDownloader.cpp
@@ -191,6 +191,11 @@ bool CVideoInfoDownloader::GetDetails(const CScraperUrl &url,
     return m_info->GetVideoDetails(*m_http, url, true/*fMovie*/, movieDetails);
 }
 
+bool CVideoInfoDownloader::GetArt(const std::string &id, CVideoInfoTag &details)
+{
+  return m_info->GetArt(*m_http, id, details);
+}
+
 bool CVideoInfoDownloader::GetEpisodeDetails(const CScraperUrl &url,
                                              CVideoInfoTag &movieDetails,
                                              CGUIDialogProgress *pProgress /* = NULL */)
diff --git a/xbmc/video/VideoInfoDownloader.h b/xbmc/video/VideoInfoDownloader.h
index 22ac229..75bc341 100644
--- a/xbmc/video/VideoInfoDownloader.h
+++ b/xbmc/video/VideoInfoDownloader.h
@@ -59,6 +59,13 @@ class CVideoInfoDownloader : public CThread
 
   static void ShowErrorDialog(const ADDON::CScraperError &sce);
 
+  /*! \brief Grab art URLs for an item with the scraper
+   \param id the unique identifier used by the scraper to describe the item.
+   \param details [out] the video info tag structure to fill with art.
+   \return true on success, false on failure.
+   */
+  bool GetArt(const std::string &id, CVideoInfoTag &details);
+
 protected:
   enum LOOKUP_STATE { DO_NOTHING = 0,
                       FIND_MOVIE = 1,

From 7ee9b363f0bd7cfe77d835284a7d7c770e223e3f Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:53:14 +1300
Subject: [PATCH 10/77] refresh season art if a new season is found that isn't
 recorded in the database yet. Fixes #14339

---
 xbmc/video/VideoInfoScanner.cpp | 33 ++++++++++++++++++++++++++++++++-
 xbmc/video/VideoInfoScanner.h   |  2 ++
 2 files changed, 34 insertions(+), 1 deletion(-)

diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index 04e578b..b86746a 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -1360,6 +1360,10 @@ namespace VIDEO
       pDlgProgress->Progress();
     }
 
+    bool updateSeasons = false;
+    map<int, int> seasons;
+    m_database.GetTvShowSeasons(showInfo.m_iDbId, seasons);
+
     EPISODELIST episodes;
     bool hasEpisodeGuide = false;
 
@@ -1408,6 +1412,8 @@ namespace VIDEO
         }
         if (AddVideo(&item, CONTENT_TVSHOWS, file->isFolder, true, &showInfo) < 0)
           return INFO_ERROR;
+        if (seasons.find(item.GetVideoInfoTag()->m_iSeason) == seasons.end())
+          updateSeasons = true;
         continue;
       }
 
@@ -1537,6 +1543,8 @@ namespace VIDEO
           
         if (AddVideo(&item, CONTENT_TVSHOWS, file->isFolder, useLocal, &showInfo) < 0)
           return INFO_ERROR;
+        if (seasons.find(item.GetVideoInfoTag()->m_iSeason) == seasons.end())
+          updateSeasons = true;
       }
       else
       {
@@ -1545,9 +1553,27 @@ namespace VIDEO
                   file->cDate.GetAsLocalizedDate().c_str(), file->strTitle.c_str());
       }
     }
+    if (updateSeasons)
+      UpdateSeasons(showInfo, scraper, useLocal);
     return INFO_ADDED;
   }
 
+  void CVideoInfoScanner::UpdateSeasons(const CVideoInfoTag &showInfo, const ADDON::ScraperPtr &scraper, bool useLocal)
+  {
+    map<int, map<string, string> > seasonArt;
+    m_database.GetTvShowSeasonArt(showInfo.m_iDbId, seasonArt);
+    CVideoInfoTag details;
+    CVideoInfoDownloader loader(scraper);
+    loader.GetArt(showInfo.m_strIMDBNumber, details);
+    details.m_strPath = showInfo.m_strPath;
+    GetSeasonThumbs(details, seasonArt, CVideoThumbLoader::GetArtTypes("season"), useLocal);
+    for (map<int, map<string, string> >::iterator i = seasonArt.begin(); i != seasonArt.end(); ++i)
+    {
+      int seasonID = m_database.AddSeason(showInfo.m_iDbId, i->first);
+      m_database.SetArtForItem(seasonID, "season", i->second);
+    }
+  }
+
   CStdString CVideoInfoScanner::GetnfoFile(CFileItem *item, bool bGrabAny) const
   {
     CStdString nfoFile;
@@ -1812,6 +1838,11 @@ namespace VIDEO
     }
     for (int season = -1; season <= maxSeasons; season++)
     {
+      // skip if we already have some art
+      map<int, map<string, string> >::const_iterator i = seasonArt.find(season);
+      if (i != seasonArt.end() && !i->second.empty())
+        continue;
+
       map<string, string> art;
       if (useLocal)
       {
@@ -1865,7 +1896,7 @@ namespace VIDEO
           art.insert(make_pair(artTypes.front(), image));
       }
 
-      seasonArt.insert(make_pair(season, art));
+      seasonArt[season] = art;
     }
   }
 
diff --git a/xbmc/video/VideoInfoScanner.h b/xbmc/video/VideoInfoScanner.h
index 7da1bf2..c764e20 100644
--- a/xbmc/video/VideoInfoScanner.h
+++ b/xbmc/video/VideoInfoScanner.h
@@ -230,6 +230,8 @@ namespace VIDEO
      */
     INFO_RET OnProcessSeriesFolder(EPISODELIST& files, const ADDON::ScraperPtr &scraper, bool useLocal, const CVideoInfoTag& showInfo, CGUIDialogProgress* pDlgProgress = NULL);
 
+    void UpdateSeasons(const CVideoInfoTag &showInfo, const ADDON::ScraperPtr &scraper, bool useLocal);
+
     bool EnumerateSeriesFolder(CFileItem* item, EPISODELIST& episodeList);
     bool ProcessItemByVideoInfoTag(const CFileItem *item, EPISODELIST &episodeList);
 

From 60cf5bb235e87d2f69dbf89d359e2c581ff44b03 Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:53:34 +1300
Subject: [PATCH 11/77] REMOVEME: updated thetvdb.com scraper to support art
 updates

---
 addons/metadata.tvdb.com/tvdb.xml | 59 +++++++++++++++++++++++++--------------
 1 file changed, 38 insertions(+), 21 deletions(-)

diff --git a/addons/metadata.tvdb.com/tvdb.xml b/addons/metadata.tvdb.com/tvdb.xml
index f27e4fc..bdf329f 100644
--- a/addons/metadata.tvdb.com/tvdb.xml
+++ b/addons/metadata.tvdb.com/tvdb.xml
@@ -102,57 +102,74 @@
 			<RegExp input="$$5" output="&lt;actor&gt;&lt;name&gt;\2&lt;/name&gt;&lt;role&gt;\3&lt;/role&gt;&lt;/actor&gt;" dest="4+">
 				<expression repeat="yes" noclean="1,2,3">&lt;Actor&gt;.*?&lt;Image&gt;([^&lt;]*)&lt;/Image&gt;.*?&lt;Name&gt;([^&lt;]*)&lt;/Name&gt;.*?&lt;Role&gt;([^&lt;]*)</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$2" output="&lt;chain function=&quot;GetArt&quot;&gt;\1&lt;/chain&gt;" dest="4+">
+				<expression/>
+			</RegExp>
+			<RegExp input="$$3" output="\1" dest="6">
+				<expression>.*/(.*).zip</expression>
+			</RegExp>
+			<RegExp input="$$3" output="&lt;episodeguide&gt;&lt;url cache=&quot;$$2-$$6.xml&quot;&gt;\1&lt;/url&gt;&lt;/episodeguide&gt;" dest="4+">
+				<expression/>
+			</RegExp>
+			<expression noclean="1"/>
+		</RegExp>
+	</GetDetails>
+
+	<GetArt dest="3">
+		<RegExp input="$$4" output="&lt;details&gt;\1&lt;/details&gt;" dest="3">
+			<RegExp input="$$1" output="&lt;url function=&quot;ParseArt&quot; cache=&quot;\1-banners.xml&quot;&gt;http://thetvdb.com/api/1D62F2F90030C444/series/\1/banners.xml&lt;/url&gt;" dest="4">
+				<expression/>
+			</RegExp>
+			<expression noclean="1"/>
+		</RegExp>
+	</GetArt>
+	<ParseArt dest="3">
+		<RegExp input="$$4" output="&lt;details&gt;\1&lt;/details&gt;" dest="3">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;graphical&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;graphical&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;text&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;text&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;blank&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;season&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;season&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;seasonwide&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;seasonwide&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;poster&lt;/BannerType&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;-1&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;-1&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;poster&lt;/BannerType&gt;</expression>
 			</RegExp>
-			<RegExp conditional="fanart" input="$$7" output="&lt;fanart url=&quot;http://thetvdb.com/banners/&quot;&gt;\1&lt;/fanart&gt;" dest="4+">
-				<RegExp input="$$5" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="7+">
+			<RegExp conditional="fanart" input="$$5" output="&lt;fanart url=&quot;http://thetvdb.com/banners/&quot;&gt;\1&lt;/fanart&gt;" dest="4+">
+				<RegExp input="$$1" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="5">
 					<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;fanart&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;([^&lt;]*)&lt;/BannerType2&gt;[^&lt;]*&lt;Colors&gt;([^&lt;]*)&lt;/Colors&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;</expression>
 				</RegExp>
-				<RegExp input="$$5" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="7+">
+				<RegExp input="$$1" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="5+">
 					<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;fanart&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;([^&lt;]*)&lt;/BannerType2&gt;[^&lt;]*&lt;Colors&gt;([^&lt;]*)&lt;/Colors&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;</expression>
 				</RegExp>
 				<expression noclean="1"/>
 			</RegExp>
-			<RegExp input="$$3" output="\1" dest="6">
-				<expression>.*/(.*).zip</expression>
-			</RegExp>
-			<RegExp input="$$3" output="&lt;episodeguide&gt;&lt;url cache=&quot;$$2-$$6.xml&quot;&gt;\1&lt;/url&gt;&lt;/episodeguide&gt;" dest="4+">
-				<expression/>
-			</RegExp>
 			<expression noclean="1"/>
 		</RegExp>
-	</GetDetails>
+	</ParseArt>
 
 	<!-- input:	$1=html !-->
 	<!-- input:	$2=series url !-->

From 0d268f2c4ccf5ccce96f8b56235ce2be2c39e30e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 2 Aug 2014 17:48:04 +0100
Subject: [PATCH 12/77] [omx] Report decoded image name

---
 xbmc/cores/omxplayer/OMXImage.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index 3fbea3b..57f69c5 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -325,6 +325,7 @@ bool COMXImage::DecodeJpegToTexture(COMXImageFile *file, unsigned int width, uns
   {
     ret = true;
     *userdata = tex;
+    CLog::Log(LOGDEBUG, "%s: decoded %s %dx%d", __func__, file->GetFilename(), width, height);
   }
   else
   {

From c90a0c3aceeaf3dec055ede0126eb495dcc331dc Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 14 Dec 2013 16:55:05 +0000
Subject: [PATCH 13/77] logging: Add microsecond timer to log messages

---
 xbmc/utils/log.cpp | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/xbmc/utils/log.cpp b/xbmc/utils/log.cpp
index 4e51166..8ed8eec 100644
--- a/xbmc/utils/log.cpp
+++ b/xbmc/utils/log.cpp
@@ -23,6 +23,7 @@
 #include "threads/SingleLock.h"
 #include "threads/Thread.h"
 #include "utils/StringUtils.h"
+#include "utils/TimeUtils.cpp"
 
 static const char* const levelNames[] =
 {"DEBUG", "INFO", "NOTICE", "WARNING", "ERROR", "SEVERE", "FATAL", "NONE"};
@@ -195,19 +196,22 @@ void CLog::PrintDebugString(const std::string& line)
 
 bool CLog::WriteLogString(int logLevel, const std::string& logString)
 {
-  static const char* prefixFormat = "%02.2d:%02.2d:%02.2d T:%" PRIu64" %7s: ";
-
+  static const char* prefixFormat = "%02.2d:%02.2d:%02.2d %10.6f T:%" PRIu64" %7s: ";
   std::string strData(logString);
   /* fixup newline alignment, number of spaces should equal prefix length */
   StringUtils::Replace(strData, "\n", "\n                                            ");
 
   int hour, minute, second;
   s_globals.m_platform.GetCurrentLocalTime(hour, minute, second);
-  
+
+  struct timespec now;
+  clock_gettime(CLOCK_MONOTONIC, &now);
+  float Now = now.tv_sec + now.tv_nsec * 1e-9;
+
   strData = StringUtils::Format(prefixFormat,
                                   hour,
                                   minute,
-                                  second,
+                                  second, Now,
                                   (uint64_t)CThread::GetCurrentThreadId(),
                                   levelNames[logLevel]) + strData;
 

From 3d1e720a7b09297dacb25e5bd71c7b3e6f4459f1 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 14 Jan 2014 18:04:07 +0000
Subject: [PATCH 16/77] [rbp] Allow ALSA to be chosen in addition to Pi sink

Needs --enable-alsa in ./configure step and alsa support on platform
---
 configure.in                             |  1 -
 tools/depends/target/Makefile            |  5 +++--
 xbmc/cores/AudioEngine/AESinkFactory.cpp | 15 ++++++++++++++-
 3 files changed, 17 insertions(+), 4 deletions(-)

diff --git a/configure.in b/configure.in
index e2b2a51..fcb7b62 100644
--- a/configure.in
+++ b/configure.in
@@ -711,7 +711,6 @@ case $use_platform in
      use_arch="arm"
      use_cpu=arm1176jzf-s
      use_hardcoded_tables="yes"
-     use_alsa="no"
      ARCH="arm"
      AC_DEFINE(HAS_EGLGLES, [1], [Define if supporting EGL based GLES Framebuffer])
      USE_OMXLIB=1; AC_DEFINE([HAVE_OMXLIB],[1],["Define to 1 if OMX libs is enabled"])
diff --git a/tools/depends/target/Makefile b/tools/depends/target/Makefile
index f5374b2..73a939c 100644
--- a/tools/depends/target/Makefile
+++ b/tools/depends/target/Makefile
@@ -58,10 +58,11 @@ LINUX_SYSTEM_LIBS=
 ifeq ($(OS),linux)
   #not for raspberry pi
   ifneq ($(TARGET_PLATFORM),raspberry-pi)
-    DEPENDS += alsa-lib libsdl linux-system-libs
-    ALSA_LIB = alsa-lib
+    DEPENDS += libsdl linux-system-libs
     LINUX_SYSTEM_LIBS = linux-system-libs
   endif
+  DEPENDS += alsa-lib
+  ALSA_LIB = alsa-lib
   FFMPEG_DEPENDS = gnutls
 endif
 
diff --git a/xbmc/cores/AudioEngine/AESinkFactory.cpp b/xbmc/cores/AudioEngine/AESinkFactory.cpp
index e42d973..715b4f1 100644
--- a/xbmc/cores/AudioEngine/AESinkFactory.cpp
+++ b/xbmc/cores/AudioEngine/AESinkFactory.cpp
@@ -27,6 +27,7 @@
   #include "Sinks/AESinkAUDIOTRACK.h"
 #elif defined(TARGET_RASPBERRY_PI)
   #include "Sinks/AESinkPi.h"
+  #include "Sinks/AESinkALSA.h"
 #elif defined(TARGET_DARWIN_IOS)
   #include "Sinks/AESinkDARWINIOS.h"
 #elif defined(TARGET_DARWIN_OSX)
@@ -66,6 +67,7 @@ void CAESinkFactory::ParseDevice(std::string &device, std::string &driver)
         driver == "AUDIOTRACK"  ||
 #elif defined(TARGET_RASPBERRY_PI)
         driver == "PI"          ||
+        driver == "ALSA"        ||
 #elif defined(TARGET_DARWIN_IOS)
         driver == "DARWINIOS"  ||
 #elif defined(TARGET_DARWIN_OSX)
@@ -105,7 +107,12 @@ IAESink *CAESinkFactory::TrySink(std::string &driver, std::string &device, AEAud
 #elif defined(TARGET_ANDROID)
     sink = new CAESinkAUDIOTRACK();
 #elif defined(TARGET_RASPBERRY_PI)
+  if (driver == "PI")
     sink = new CAESinkPi();
+  #if defined(HAS_ALSA)
+  if (driver == "ALSA")
+    sink = new CAESinkALSA();
+  #endif
 #elif defined(TARGET_DARWIN_IOS)
     sink = new CAESinkDARWINIOS();
 #elif defined(TARGET_DARWIN_OSX)
@@ -196,7 +203,13 @@ void CAESinkFactory::EnumerateEx(AESinkInfoList &list, bool force)
   CAESinkPi::EnumerateDevicesEx(info.m_deviceInfoList, force);
   if(!info.m_deviceInfoList.empty())
     list.push_back(info);
-
+  #if defined(HAS_ALSA)
+  info.m_deviceInfoList.clear();
+  info.m_sinkName = "ALSA";
+  CAESinkALSA::EnumerateDevicesEx(info.m_deviceInfoList, force);
+  if(!info.m_deviceInfoList.empty())
+    list.push_back(info);
+  #endif
 #elif defined(TARGET_DARWIN_IOS)
 
   info.m_deviceInfoList.clear();

From ede35f9c20d4468b43987b49182f6f73e5d75882 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 8 Mar 2014 15:36:06 +0000
Subject: [PATCH 17/77] [hifiberry] Hack: force it to be recognised as IEC958
 capable to enable passthrough options

---
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index a464b4b..7eba389 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -1296,6 +1296,10 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
     if (snd_card_get_name(cardNr, &cardName) == 0)
       info.m_displayName = cardName;
 
+    // hack: hifiberry digi doesn't correctly report as iec958 device. Needs fixing in kernel driver
+    if (info.m_displayName == "snd_rpi_hifiberry_digi")
+      info.m_deviceType = AE_DEVTYPE_IEC958;
+
     if (info.m_deviceType == AE_DEVTYPE_HDMI && info.m_displayName.size() > 5 &&
         info.m_displayName.substr(info.m_displayName.size()-5) == " HDMI")
     {

From 205678b81f1602bfa11de7f4993a3e94d0bd93ab Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 11 Dec 2013 17:21:54 +0000
Subject: [PATCH 18/77] Move the reference-counting of Begin and End calls from
 DX and GL source files into GUIFontTTF.cpp.

---
 xbmc/guilib/GUIFontTTF.cpp   |  21 ++++++
 xbmc/guilib/GUIFontTTF.h     |   6 +-
 xbmc/guilib/GUIFontTTFDX.cpp |  79 ++++++++++------------
 xbmc/guilib/GUIFontTTFDX.h   |   4 +-
 xbmc/guilib/GUIFontTTFGL.cpp | 154 ++++++++++++++++++++-----------------------
 xbmc/guilib/GUIFontTTFGL.h   |   4 +-
 6 files changed, 135 insertions(+), 133 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 008c7ae4..e507833 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -308,6 +308,27 @@ bool CGUIFontTTFBase::Load(const CStdString& strFilename, float height, float as
   return true;
 }
 
+void CGUIFontTTFBase::Begin()
+{
+  if (m_nestedBeginCount == 0 && m_texture != NULL && FirstBegin())
+  {
+    m_vertex_count = 0;
+  }
+  // Keep track of the nested begin/end calls.
+  m_nestedBeginCount++;
+}
+
+void CGUIFontTTFBase::End()
+{
+  if (m_nestedBeginCount == 0)
+    return;
+
+  if (--m_nestedBeginCount > 0)
+    return;
+
+  LastEnd();
+}
+
 void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors, const vecText &text, uint32_t alignment, float maxPixelWidth, bool scrolling)
 {
   Begin();
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 4501dbd..df54a5d 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -77,8 +77,8 @@ class CGUIFontTTFBase
 
   bool Load(const CStdString& strFilename, float height = 20.0f, float aspect = 1.0f, float lineSpacing = 1.0f, bool border = false);
 
-  virtual void Begin() = 0;
-  virtual void End() = 0;
+  void Begin();
+  void End();
 
   const CStdString& GetFileName() const { return m_strFileName; };
 
@@ -168,6 +168,8 @@ class CGUIFontTTFBase
   CStdString m_strFileName;
 
 private:
+  virtual bool FirstBegin() = 0;
+  virtual void LastEnd() = 0;
   CGUIFontTTFBase(const CGUIFontTTFBase&);
   CGUIFontTTFBase& operator=(const CGUIFontTTFBase&);
   int m_referenceCount;
diff --git a/xbmc/guilib/GUIFontTTFDX.cpp b/xbmc/guilib/GUIFontTTFDX.cpp
index e3eba24..2f90668 100644
--- a/xbmc/guilib/GUIFontTTFDX.cpp
+++ b/xbmc/guilib/GUIFontTTFDX.cpp
@@ -51,65 +51,56 @@ CGUIFontTTFDX::~CGUIFontTTFDX(void)
   free(m_index);
 }
 
-void CGUIFontTTFDX::Begin()
+bool CGUIFontTTFDX::FirstBegin()
 {
   LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
 
   if (pD3DDevice == NULL)
+  {
     CLog::Log(LOGERROR, __FUNCTION__" - failed to get Direct3D device");
+    return false;
+  }
 
-  if (m_nestedBeginCount == 0 && pD3DDevice != NULL && m_texture != NULL)
+  int unit = 0;
+  // just have to blit from our texture.
+  m_texture->BindToUnit(unit);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_SELECTARG1 ); // only use diffuse
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
+  unit++;
+
+  if(g_Windowing.UseLimitedColor())
   {
-    int unit = 0;
-    // just have to blit from our texture.
-    m_texture->BindToUnit(unit);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_SELECTARG1 ); // only use diffuse
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
+    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP  , D3DTOP_ADD );
+    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_CURRENT) ;
+    pD3DDevice->SetRenderState( D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(16,16,16,0) );
+    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG2, D3DTA_TFACTOR );
     unit++;
-
-    if(g_Windowing.UseLimitedColor())
-    {
-      pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP  , D3DTOP_ADD );
-      pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_CURRENT) ;
-      pD3DDevice->SetRenderState( D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(16,16,16,0) );
-      pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG2, D3DTA_TFACTOR );
-      unit++;
-    }
-
-    // no other texture stages needed
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_DISABLE);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
-
-    pD3DDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
-    pD3DDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );
-    pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
-    pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
-    pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
-    pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
-    pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
-    pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE);
-
-    pD3DDevice->SetFVF(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);
-    m_vertex_count = 0;
   }
 
-  // Keep track of the nested begin/end calls.
-  m_nestedBeginCount++;
+  // no other texture stages needed
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_DISABLE);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
+
+  pD3DDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
+  pD3DDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );
+  pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
+  pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
+  pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
+  pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
+  pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
+  pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE);
+
+  pD3DDevice->SetFVF(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);
+  return true;
 }
 
-void CGUIFontTTFDX::End()
+void CGUIFontTTFDX::LastEnd()
 {
   LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
 
-  if (m_nestedBeginCount == 0)
-    return;
-
-  if (--m_nestedBeginCount > 0)
-    return;
-
   if (m_vertex_count == 0)
     return;
 
diff --git a/xbmc/guilib/GUIFontTTFDX.h b/xbmc/guilib/GUIFontTTFDX.h
index 0431085..17dfefe 100644
--- a/xbmc/guilib/GUIFontTTFDX.h
+++ b/xbmc/guilib/GUIFontTTFDX.h
@@ -41,8 +41,8 @@ class CGUIFontTTFDX : public CGUIFontTTFBase
   CGUIFontTTFDX(const CStdString& strFileName);
   virtual ~CGUIFontTTFDX(void);
 
-  virtual void Begin();
-  virtual void End();
+  virtual bool FirstBegin();
+  virtual void LastEnd();
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 6a8291b..97853fd 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -53,108 +53,96 @@ CGUIFontTTFGL::~CGUIFontTTFGL(void)
 {
 }
 
-void CGUIFontTTFGL::Begin()
+bool CGUIFontTTFGL::FirstBegin()
 {
-  if (m_nestedBeginCount == 0 && m_texture != NULL)
+  if (m_textureStatus == TEXTURE_REALLOCATED)
   {
-    if (m_textureStatus == TEXTURE_REALLOCATED)
-    {
-      if (glIsTexture(m_nTexture))
-        g_TextureManager.ReleaseHwTexture(m_nTexture);
-      m_textureStatus = TEXTURE_VOID;
-    }
-    
-    if (m_textureStatus == TEXTURE_VOID)
-    {
-      // Have OpenGL generate a texture object handle for us
-      glGenTextures(1, (GLuint*) &m_nTexture);
+    if (glIsTexture(m_nTexture))
+      g_TextureManager.ReleaseHwTexture(m_nTexture);
+    m_textureStatus = TEXTURE_VOID;
+  }
 
-      // Bind the texture object
-      glBindTexture(GL_TEXTURE_2D, m_nTexture);
+  if (m_textureStatus == TEXTURE_VOID)
+  {
+    // Have OpenGL generate a texture object handle for us
+    glGenTextures(1, (GLuint*) &m_nTexture);
+
+    // Bind the texture object
+    glBindTexture(GL_TEXTURE_2D, m_nTexture);
 #ifdef HAS_GL
-      glEnable(GL_TEXTURE_2D);
+    glEnable(GL_TEXTURE_2D);
 #endif
-      // Set the texture's stretching properties
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    // Set the texture's stretching properties
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 
-      // Set the texture image -- THIS WORKS, so the pixels must be wrong.
-      glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, m_texture->GetWidth(), m_texture->GetHeight(), 0,
-                   GL_ALPHA, GL_UNSIGNED_BYTE, 0);
-      
-      VerifyGLState();
-      m_textureStatus = TEXTURE_UPDATED;
-    }
+    // Set the texture image -- THIS WORKS, so the pixels must be wrong.
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, m_texture->GetWidth(), m_texture->GetHeight(), 0,
+        GL_ALPHA, GL_UNSIGNED_BYTE, 0);
 
-    if (m_textureStatus == TEXTURE_UPDATED)
-    {
-      glBindTexture(GL_TEXTURE_2D, m_nTexture);
-      glTexSubImage2D(GL_TEXTURE_2D, 0, 0, m_updateY1, m_texture->GetWidth(), m_updateY2 - m_updateY1, GL_ALPHA, GL_UNSIGNED_BYTE,
-                      m_texture->GetPixels() + m_updateY1 * m_texture->GetPitch());
-      glDisable(GL_TEXTURE_2D);
-        
-      m_updateY1 = m_updateY2 = 0;
-      m_textureStatus = TEXTURE_READY;
-    }
+    VerifyGLState();
+    m_textureStatus = TEXTURE_UPDATED;
+  }
 
-    // Turn Blending On
-    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);
-    glEnable(GL_BLEND);
+  if (m_textureStatus == TEXTURE_UPDATED)
+  {
+    glBindTexture(GL_TEXTURE_2D, m_nTexture);
+    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, m_updateY1, m_texture->GetWidth(), m_updateY2 - m_updateY1, GL_ALPHA, GL_UNSIGNED_BYTE,
+        m_texture->GetPixels() + m_updateY1 * m_texture->GetPitch());
+    glDisable(GL_TEXTURE_2D);
+
+    m_updateY1 = m_updateY2 = 0;
+    m_textureStatus = TEXTURE_READY;
+  }
+
+  // Turn Blending On
+  glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);
+  glEnable(GL_BLEND);
 #ifdef HAS_GL
-    glEnable(GL_TEXTURE_2D);
+  glEnable(GL_TEXTURE_2D);
 #endif
-    glBindTexture(GL_TEXTURE_2D, m_nTexture);
+  glBindTexture(GL_TEXTURE_2D, m_nTexture);
 
 #ifdef HAS_GL
-    glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE);
-    glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB,GL_REPLACE);
-    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);
-    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);
-    glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);
-    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_TEXTURE0);
-    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);
-    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_PRIMARY_COLOR);
-    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);
-    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-    VerifyGLState();
+  glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE);
+  glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB,GL_REPLACE);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_TEXTURE0);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_PRIMARY_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);
+  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+  VerifyGLState();
+
+  if(g_Windowing.UseLimitedColor())
+  {
+    glActiveTexture(GL_TEXTURE1);
+    glBindTexture(GL_TEXTURE_2D, m_nTexture); // dummy bind
+    glEnable(GL_TEXTURE_2D);
 
-    if(g_Windowing.UseLimitedColor())
-    {
-      glActiveTexture(GL_TEXTURE1);
-      glBindTexture(GL_TEXTURE_2D, m_nTexture); // dummy bind
-      glEnable(GL_TEXTURE_2D);
-
-      const GLfloat rgba[4] = {16.0f / 255.0f, 16.0f / 255.0f, 16.0f / 255.0f, 0.0f};
-      glTexEnvi (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE , GL_COMBINE);
-      glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, rgba);
-      glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_RGB      , GL_ADD);
-      glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_RGB      , GL_PREVIOUS);
-      glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE1_RGB      , GL_CONSTANT);
-      glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND0_RGB     , GL_SRC_COLOR);
-      glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND1_RGB     , GL_SRC_COLOR);
-      glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_ALPHA    , GL_REPLACE);
-      glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_ALPHA    , GL_PREVIOUS);
-      VerifyGLState();
-    }
+    const GLfloat rgba[4] = {16.0f / 255.0f, 16.0f / 255.0f, 16.0f / 255.0f, 0.0f};
+    glTexEnvi (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE , GL_COMBINE);
+    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, rgba);
+    glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_RGB      , GL_ADD);
+    glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_RGB      , GL_PREVIOUS);
+    glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE1_RGB      , GL_CONSTANT);
+    glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND0_RGB     , GL_SRC_COLOR);
+    glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND1_RGB     , GL_SRC_COLOR);
+    glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_ALPHA    , GL_REPLACE);
+    glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_ALPHA    , GL_PREVIOUS);
+    VerifyGLState();
+  }
 
 #else
-    g_Windowing.EnableGUIShader(SM_FONTS);
+  g_Windowing.EnableGUIShader(SM_FONTS);
 #endif
-
-    m_vertex_count = 0;
-  }
-  // Keep track of the nested begin/end calls.
-  m_nestedBeginCount++;
+  return true;
 }
 
-void CGUIFontTTFGL::End()
+void CGUIFontTTFGL::LastEnd()
 {
-  if (m_nestedBeginCount == 0)
-    return;
-
-  if (--m_nestedBeginCount > 0)
-    return;
-
 #ifdef HAS_GL
   glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
 
diff --git a/xbmc/guilib/GUIFontTTFGL.h b/xbmc/guilib/GUIFontTTFGL.h
index c0bb53a..735fb3a 100644
--- a/xbmc/guilib/GUIFontTTFGL.h
+++ b/xbmc/guilib/GUIFontTTFGL.h
@@ -41,8 +41,8 @@ class CGUIFontTTFGL : public CGUIFontTTFBase
   CGUIFontTTFGL(const CStdString& strFileName);
   virtual ~CGUIFontTTFGL(void);
 
-  virtual void Begin();
-  virtual void End();
+  virtual bool FirstBegin();
+  virtual void LastEnd();
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);

From 70d3e4869c1eb9a308a6ff32a1cd13958dd3f3be Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 11 Dec 2013 18:47:54 +0000
Subject: [PATCH 19/77] Convert CGUIFontTTFBase::m_vertex to be managed as a
 std::vector.

Also retired CGUIFontTTFBase::m_vertex_count and
CGUIFontTTFBase::m_vertex_size because these can be derived from vector
member functions.
---
 xbmc/guilib/GUIFontTTF.cpp   | 29 +++++------------------------
 xbmc/guilib/GUIFontTTF.h     |  4 +---
 xbmc/guilib/GUIFontTTFDX.cpp | 12 ++++++------
 xbmc/guilib/GUIFontTTFGL.cpp | 12 ++++++------
 4 files changed, 18 insertions(+), 39 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index e507833..0a80471 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -138,8 +138,7 @@ CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName)
   m_maxChars = 0;
   m_nestedBeginCount = 0;
 
-  m_vertex_size   = 4*1024;
-  m_vertex        = (SVertex*)malloc(m_vertex_size * sizeof(SVertex));
+  m_vertex.reserve(4*1024);
 
   m_face = NULL;
   m_stroker = NULL;
@@ -154,7 +153,6 @@ CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName)
   m_textureScaleX = m_textureScaleY = 0.0;
   m_ellipsesWidth = m_height = 0.0f;
   m_color = 0;
-  m_vertex_count = 0;
   m_nTexture = 0;
 }
 
@@ -215,9 +213,7 @@ void CGUIFontTTFBase::Clear()
     g_freeTypeLibrary.ReleaseStroker(m_stroker);
   m_stroker = NULL;
 
-  free(m_vertex);
-  m_vertex = NULL;
-  m_vertex_count = 0;
+  m_vertex.clear();
 }
 
 bool CGUIFontTTFBase::Load(const CStdString& strFilename, float height, float aspect, float lineSpacing, bool border)
@@ -312,7 +308,7 @@ void CGUIFontTTFBase::Begin()
 {
   if (m_nestedBeginCount == 0 && m_texture != NULL && FirstBegin())
   {
-    m_vertex_count = 0;
+    m_vertex.clear();
   }
   // Keep track of the nested begin/end calls.
   m_nestedBeginCount++;
@@ -745,22 +741,9 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
   float tt = texture.y1 * m_textureScaleY;
   float tb = texture.y2 * m_textureScaleY;
 
-  // grow the vertex buffer if required
-  if(m_vertex_count >= m_vertex_size)
-  {
-    m_vertex_size *= 2;
-    void* old      = m_vertex;
-    m_vertex       = (SVertex*)realloc(m_vertex, m_vertex_size * sizeof(SVertex));
-    if (!m_vertex)
-    {
-      free(old);
-      CLog::Log(LOGSEVERE, "%s: can't allocate %" PRIdS" bytes for texture", __FUNCTION__ , m_vertex_size * sizeof(SVertex));
-      return;
-    }
-  }
-
+  m_vertex.resize(m_vertex.size() + 4);
+  SVertex* v = &m_vertex[m_vertex.size() - 4];
   m_color = color;
-  SVertex* v = m_vertex + m_vertex_count;
 
   unsigned char r = GET_R(color)
               , g = GET_G(color)
@@ -827,8 +810,6 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
   v[3].y = y[2];
   v[3].z = z[2];
 #endif
-
-  m_vertex_count+=4;
 }
 
 // Oblique code - original taken from freetype2 (ftsynth.c)
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index df54a5d..10a7060 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -156,9 +156,7 @@ class CGUIFontTTFBase
 
   unsigned int m_nTexture;
 
-  SVertex* m_vertex;
-  int      m_vertex_count;
-  int      m_vertex_size;
+  std::vector<SVertex> m_vertex;
 
   float    m_textureScaleX;
   float    m_textureScaleY;
diff --git a/xbmc/guilib/GUIFontTTFDX.cpp b/xbmc/guilib/GUIFontTTFDX.cpp
index 2f90668..6ef8984 100644
--- a/xbmc/guilib/GUIFontTTFDX.cpp
+++ b/xbmc/guilib/GUIFontTTFDX.cpp
@@ -101,17 +101,17 @@ void CGUIFontTTFDX::LastEnd()
 {
   LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
 
-  if (m_vertex_count == 0)
+  if (m_vertex.size() == 0)
     return;
 
-  unsigned index_size = m_vertex_size * 6 / 4;
+  unsigned index_size = m_vertex.capacity() * 6 / 4;
   if(m_index_size < index_size)
   {
     uint16_t* id  = (uint16_t*)calloc(index_size, sizeof(uint16_t));
     if(id == NULL)
       return;
 
-    for(int i = 0, b = 0; i < m_vertex_size; i += 4, b += 6)
+    for(int i = 0, b = 0; i < m_vertex.capacity(); i += 4, b += 6)
     {
       id[b+0] = i + 0;
       id[b+1] = i + 1;
@@ -140,11 +140,11 @@ void CGUIFontTTFDX::LastEnd()
 
   pD3DDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST
                                     , 0
-                                    , m_vertex_count
-                                    , m_vertex_count / 2
+                                    , m_vertex.size()
+                                    , m_vertex.size() / 2
                                     , m_index
                                     , D3DFMT_INDEX16
-                                    , m_vertex
+                                    , &m_vertex[0]
                                     , sizeof(SVertex));
   pD3DDevice->SetTransform(D3DTS_WORLD, &orig);
 
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 97853fd..b76c6a5 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -146,13 +146,13 @@ void CGUIFontTTFGL::LastEnd()
 #ifdef HAS_GL
   glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
 
-  glColorPointer   (4, GL_UNSIGNED_BYTE, sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, r));
-  glVertexPointer  (3, GL_FLOAT        , sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, x));
-  glTexCoordPointer(2, GL_FLOAT        , sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, u));
+  glColorPointer   (4, GL_UNSIGNED_BYTE, sizeof(SVertex), (char*)&m_vertex[0] + offsetof(SVertex, r));
+  glVertexPointer  (3, GL_FLOAT        , sizeof(SVertex), (char*)&m_vertex[0] + offsetof(SVertex, x));
+  glTexCoordPointer(2, GL_FLOAT        , sizeof(SVertex), (char*)&m_vertex[0] + offsetof(SVertex, u));
   glEnableClientState(GL_COLOR_ARRAY);
   glEnableClientState(GL_VERTEX_ARRAY);
   glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-  glDrawArrays(GL_QUADS, 0, m_vertex_count);
+  glDrawArrays(GL_QUADS, 0, m_vertex.size());
   glPopClientAttrib();
 
   glActiveTexture(GL_TEXTURE1);
@@ -168,10 +168,10 @@ void CGUIFontTTFGL::LastEnd()
   GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
 
   // stack object until VBOs will be used
-  std::vector<SVertex> vecVertices( 6 * (m_vertex_count / 4) );
+  std::vector<SVertex> vecVertices( 6 * (m_vertex.size() / 4) );
   SVertex *vertices = &vecVertices[0];
 
-  for (int i=0; i<m_vertex_count; i+=4)
+  for (size_t i=0; i<m_vertex.size(); i+=4)
   {
     *vertices++ = m_vertex[i];
     *vertices++ = m_vertex[i+1];

From 0ad5ef4114e14d2a2df50dad2013cad5525752c1 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Mon, 16 Dec 2013 18:58:12 +0000
Subject: [PATCH 20/77] CGUIFontTTFBase::RenderCharacter can now append to
 arbitrary vectors of vertices rather than only CGUIFontTTFBase::m_vertex

---
 xbmc/guilib/GUIFontTTF.cpp | 12 +++++++-----
 xbmc/guilib/GUIFontTTF.h   |  2 +-
 2 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 0a80471..848c5c8 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -329,6 +329,8 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
 {
   Begin();
 
+  std::vector<SVertex> &vertices = m_vertex;
+
   // save the origin, which is scaled separately
   m_originX = x;
   m_originY = y;
@@ -409,7 +411,7 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
 
         for (int i = 0; i < 3; i++)
         {
-          RenderCharacter(startX + cursorX, startY, period, color, !scrolling);
+          RenderCharacter(startX + cursorX, startY, period, color, !scrolling, vertices);
           cursorX += period->advance;
         }
         break;
@@ -418,7 +420,7 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
     else if (maxPixelWidth > 0 && cursorX > maxPixelWidth)
       break;  // exceeded max allowed width - stop rendering
 
-    RenderCharacter(startX + cursorX, startY, ch, color, !scrolling);
+    RenderCharacter(startX + cursorX, startY, ch, color, !scrolling, vertices);
     if ( alignment & XBFONT_JUSTIFIED )
     {
       if ((*pos & 0xffff) == L' ')
@@ -675,7 +677,7 @@ bool CGUIFontTTFBase::CacheCharacter(wchar_t letter, uint32_t style, Character *
   return true;
 }
 
-void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX)
+void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX, std::vector<SVertex> &vertices)
 {
   // actual image width isn't same as the character width as that is
   // just baseline width and height should include the descent
@@ -741,8 +743,8 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
   float tt = texture.y1 * m_textureScaleY;
   float tb = texture.y2 * m_textureScaleY;
 
-  m_vertex.resize(m_vertex.size() + 4);
-  SVertex* v = &m_vertex[m_vertex.size() - 4];
+  vertices.resize(vertices.size() + 4);
+  SVertex* v = &vertices[vertices.size() - 4];
   m_color = color;
 
   unsigned char r = GET_R(color)
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 10a7060..dde0350 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -109,7 +109,7 @@ class CGUIFontTTFBase
   // Stuff for pre-rendering for speed
   inline Character *GetCharacter(character_t letter);
   bool CacheCharacter(wchar_t letter, uint32_t style, Character *ch);
-  void RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX);
+  void RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX, std::vector<SVertex> &vertices);
   void ClearCharacterCache();
 
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight) = 0;

From 4a29d6593f48ecac6b1cee902dccbbfd99bd4348 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 17:18:38 +0000
Subject: [PATCH 21/77] Add a cache of font glyph bounding box vertices.

This is implemented as a template because ultimately we will key on different
parameters and store values of different types, depending upon whether we
have a GLES or non-GLES backend, and for GLES, whether or not the currently
applicable transformation matrices permit the use of hardware clipping.
---
 XBMC.xcodeproj/project.pbxproj             |  10 ++
 project/VS2010Express/XBMC.vcxproj         |   2 +
 project/VS2010Express/XBMC.vcxproj.filters |   6 +
 xbmc/guilib/GUIFontCache.cpp               | 105 ++++++++++++++
 xbmc/guilib/GUIFontCache.h                 | 217 +++++++++++++++++++++++++++++
 xbmc/guilib/GUIFontTTF.cpp                 | 181 +++++++++++++-----------
 xbmc/guilib/GUIFontTTF.h                   |   5 +
 xbmc/guilib/GUIFontTTFGL.cpp               |   1 +
 xbmc/guilib/GraphicContext.h               |   1 +
 xbmc/guilib/Makefile.in                    |   1 +
 xbmc/guilib/TransformMatrix.h              |  11 ++
 11 files changed, 456 insertions(+), 84 deletions(-)
 create mode 100644 xbmc/guilib/GUIFontCache.cpp
 create mode 100644 xbmc/guilib/GUIFontCache.h

diff --git a/XBMC.xcodeproj/project.pbxproj b/XBMC.xcodeproj/project.pbxproj
index 10a2e89..1eb7173 100644
--- a/XBMC.xcodeproj/project.pbxproj
+++ b/XBMC.xcodeproj/project.pbxproj
@@ -168,6 +168,9 @@
 		1D638128161E211E003603ED /* PeripheralImon.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 1D638126161E211E003603ED /* PeripheralImon.cpp */; };
 		1DAFDB7C16DFDCA7007F8C68 /* PeripheralBusCEC.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 1DAFDB7A16DFDCA7007F8C68 /* PeripheralBusCEC.cpp */; };
 		1DE0443515828F4B005DDB4D /* Exception.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 1DE0443315828F4B005DDB4D /* Exception.cpp */; };
+		2F4564D51970129A00396109 /* GUIFontCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2F4564D31970129A00396109 /* GUIFontCache.cpp */; };
+		2F4564D61970129A00396109 /* GUIFontCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2F4564D31970129A00396109 /* GUIFontCache.cpp */; };
+		2F4564D71970129A00396109 /* GUIFontCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2F4564D31970129A00396109 /* GUIFontCache.cpp */; };
 		32C631281423A90F00F18420 /* JpegIO.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 32C631261423A90F00F18420 /* JpegIO.cpp */; };
 		36A9443D15821E2800727135 /* DatabaseUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 36A9443B15821E2800727135 /* DatabaseUtils.cpp */; };
 		36A9444115821E7C00727135 /* SortUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 36A9443F15821E7C00727135 /* SortUtils.cpp */; };
@@ -4008,6 +4011,8 @@
 		1DAFDB7B16DFDCA7007F8C68 /* PeripheralBusCEC.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PeripheralBusCEC.h; sourceTree = "<group>"; };
 		1DE0443315828F4B005DDB4D /* Exception.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Exception.cpp; path = commons/Exception.cpp; sourceTree = "<group>"; };
 		1DE0443415828F4B005DDB4D /* Exception.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Exception.h; path = commons/Exception.h; sourceTree = "<group>"; };
+		2F4564D31970129A00396109 /* GUIFontCache.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GUIFontCache.cpp; sourceTree = "<group>"; };
+		2F4564D41970129A00396109 /* GUIFontCache.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GUIFontCache.h; sourceTree = "<group>"; };
 		32C631261423A90F00F18420 /* JpegIO.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JpegIO.cpp; sourceTree = "<group>"; };
 		32C631271423A90F00F18420 /* JpegIO.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JpegIO.h; sourceTree = "<group>"; };
 		36A9443B15821E2800727135 /* DatabaseUtils.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DatabaseUtils.cpp; sourceTree = "<group>"; };
@@ -6513,6 +6518,8 @@
 				18B7C7101294222D009E7A26 /* GUIFixedListContainer.h */,
 				18B7C76B1294222E009E7A26 /* GUIFont.cpp */,
 				18B7C7111294222D009E7A26 /* GUIFont.h */,
+				2F4564D31970129A00396109 /* GUIFontCache.cpp */,
+				2F4564D41970129A00396109 /* GUIFontCache.h */,
 				18B7C76C1294222E009E7A26 /* GUIFontManager.cpp */,
 				18B7C7121294222D009E7A26 /* GUIFontManager.h */,
 				18B7C76D1294222E009E7A26 /* GUIFontTTF.cpp */,
@@ -11000,6 +11007,7 @@
 				7C5608C70F1754930056433A /* ExternalPlayer.cpp in Sources */,
 				F584E12E0F257C5100DB26A5 /* HTTPDirectory.cpp in Sources */,
 				F54C51D20F1E783200D46E3C /* GUIDialogKaraokeSongSelector.cpp in Sources */,
+				2F4564D51970129A00396109 /* GUIFontCache.cpp in Sources */,
 				F54C51D50F1E784800D46E3C /* karaokelyricscdg.cpp in Sources */,
 				F54C51D80F1E785700D46E3C /* karaokelyrics.cpp in Sources */,
 				F54C51E50F1E787700D46E3C /* karaokelyricstextkar.cpp in Sources */,
@@ -12666,6 +12674,7 @@
 				DFF0F45B17528350002DA3A4 /* Control.cpp in Sources */,
 				DFF0F45C17528350002DA3A4 /* Dialog.cpp in Sources */,
 				DFF0F45D17528350002DA3A4 /* File.cpp in Sources */,
+				2F4564D71970129A00396109 /* GUIFontCache.cpp in Sources */,
 				DFF0F45E17528350002DA3A4 /* InfoTagMusic.cpp in Sources */,
 				DFF0F45F17528350002DA3A4 /* InfoTagVideo.cpp in Sources */,
 				DFF0F46017528350002DA3A4 /* Keyboard.cpp in Sources */,
@@ -13465,6 +13474,7 @@
 				E499131D174E5DAD00741B6D /* GUIVisualisationControl.cpp in Sources */,
 				E499131E174E5DAD00741B6D /* GUIWindow.cpp in Sources */,
 				E499131F174E5DAD00741B6D /* GUIWindowManager.cpp in Sources */,
+				2F4564D61970129A00396109 /* GUIFontCache.cpp in Sources */,
 				E4991320174E5DAD00741B6D /* GUIWrappingListContainer.cpp in Sources */,
 				E4991321174E5DAD00741B6D /* imagefactory.cpp in Sources */,
 				E4991322174E5DAD00741B6D /* IWindowManagerCallback.cpp in Sources */,
diff --git a/project/VS2010Express/XBMC.vcxproj b/project/VS2010Express/XBMC.vcxproj
index 8e1e4df..a8f3426 100644
--- a/project/VS2010Express/XBMC.vcxproj
+++ b/project/VS2010Express/XBMC.vcxproj
@@ -425,6 +425,7 @@
     <ClCompile Include="..\..\xbmc\guilib\GUIFadeLabelControl.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFixedListContainer.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFont.cpp" />
+    <ClCompile Include="..\..\xbmc\guilib\GUIFontCache.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFontManager.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFontTTF.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFontTTFDX.cpp" />
@@ -1744,6 +1745,7 @@
     <ClInclude Include="..\..\xbmc\guilib\GUIFadeLabelControl.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFixedListContainer.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFont.h" />
+    <ClInclude Include="..\..\xbmc\guilib\GUIFontCache.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFontManager.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFontTTF.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFontTTFDX.h" />
diff --git a/project/VS2010Express/XBMC.vcxproj.filters b/project/VS2010Express/XBMC.vcxproj.filters
index fcec4f0..e8ac96e 100644
--- a/project/VS2010Express/XBMC.vcxproj.filters
+++ b/project/VS2010Express/XBMC.vcxproj.filters
@@ -991,6 +991,9 @@
     <ClCompile Include="..\..\xbmc\guilib\GUIFont.cpp">
       <Filter>guilib</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\guilib\GUIFontCache.cpp">
+      <Filter>guilib</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\xbmc\guilib\GUIFontManager.cpp">
       <Filter>guilib</Filter>
     </ClCompile>
@@ -3882,6 +3885,9 @@
     <ClInclude Include="..\..\xbmc\guilib\GUIFont.h">
       <Filter>guilib</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\xbmc\guilib\GUIFontCache.h">
+      <Filter>guilib</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\xbmc\guilib\GUIFontManager.h">
       <Filter>guilib</Filter>
     </ClInclude>
diff --git a/xbmc/guilib/GUIFontCache.cpp b/xbmc/guilib/GUIFontCache.cpp
new file mode 100644
index 0000000..2c72f9c
--- /dev/null
+++ b/xbmc/guilib/GUIFontCache.cpp
@@ -0,0 +1,105 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <stdint.h>
+#include <vector>
+#include "utils/StdString.h" // required by GUIFontTTF.h
+#include "GUIFontTTF.h"
+#include "GraphicContext.h"
+
+template<class Position, class Value>
+void CGUIFontCacheEntry<Position, Value>::Reassign::operator()(CGUIFontCacheEntry<Position, Value> &entry)
+{
+  entry.m_key.m_pos = m_key.m_pos;
+  entry.m_key.m_colors.assign(m_key.m_colors.begin(), m_key.m_colors.end());
+  entry.m_key.m_text.assign(m_key.m_text.begin(), m_key.m_text.end());
+  entry.m_key.m_alignment = m_key.m_alignment;
+  entry.m_key.m_maxPixelWidth = m_key.m_maxPixelWidth;
+  entry.m_key.m_scrolling = m_key.m_scrolling;
+  entry.m_matrix = m_key.m_matrix;
+  entry.m_key.m_scaleX = m_key.m_scaleX;
+  entry.m_key.m_scaleY = m_key.m_scaleY;
+
+  entry.m_lastUsedMillis = m_nowMillis;
+  entry.m_value.clear();
+}
+
+template<class Position, class Value>
+CGUIFontCacheEntry<Position, Value>::~CGUIFontCacheEntry()
+{
+  delete &m_key.m_colors;
+  delete &m_key.m_text;
+  m_value.clear();
+}
+
+template<class Position, class Value>
+Value &CGUIFontCache<Position, Value>::Lookup(Position &pos,
+                                              const vecColors &colors, const vecText &text,
+                                              uint32_t alignment, float maxPixelWidth,
+                                              bool scrolling,
+                                              unsigned int nowMillis, bool &dirtyCache)
+{
+  const CGUIFontCacheKey<Position> key(pos,
+                                       const_cast<vecColors &>(colors), const_cast<vecText &>(text),
+                                       alignment, maxPixelWidth,
+                                       scrolling, g_graphicsContext.GetGUIMatrix(),
+                                       g_graphicsContext.GetGUIScaleX(), g_graphicsContext.GetGUIScaleY());
+  EntryHashIterator i = m_list.template get<Hash>().find(key);
+  if (i == m_list.template get<Hash>().end())
+  {
+    /* Cache miss */
+    EntryAgeIterator oldest = m_list.template get<Age>().begin();
+    if (!m_list.template get<Age>().empty() && nowMillis - oldest->m_lastUsedMillis > FONT_CACHE_TIME_LIMIT)
+    {
+      /* The oldest existing entry is old enough to expire and reuse */
+      m_list.template get<Hash>().modify(m_list.template project<Hash>(oldest), typename CGUIFontCacheEntry<Position, Value>::Reassign(key, nowMillis));
+      m_list.template get<Age>().relocate(m_list.template get<Age>().end(), oldest);
+    }
+    else
+    {
+      /* We need a new entry instead */
+      /* Yes, this causes the creation an destruction of a temporary entry, but
+       * this code ought to only be used infrequently, when the cache needs to grow */
+      m_list.template get<Age>().push_back(CGUIFontCacheEntry<Position, Value>(*this, key, nowMillis));
+    }
+    dirtyCache = true;
+    return (--m_list.template get<Age>().end())->m_value;
+  }
+  else
+  {
+    /* Cache hit */
+    /* Update time in entry and move to the back of the list */
+    i->m_lastUsedMillis = nowMillis;
+    m_list.template get<Age>().relocate(m_list.template get<Age>().end(), m_list.template project<Age>(i));
+    dirtyCache = false;
+    return i->m_value;
+  }
+}
+
+template<class Position, class Value>
+void CGUIFontCache<Position, Value>::Flush()
+{
+  m_list.template get<Age>().clear();
+}
+
+template void CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Reassign::operator()(CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue> &entry);
+template CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::~CGUIFontCacheEntry();
+template CGUIFontCacheStaticValue &CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Lookup(CGUIFontCacheStaticPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
+template void CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Flush();
diff --git a/xbmc/guilib/GUIFontCache.h b/xbmc/guilib/GUIFontCache.h
new file mode 100644
index 0000000..ef65845
--- /dev/null
+++ b/xbmc/guilib/GUIFontCache.h
@@ -0,0 +1,217 @@
+/*!
+\file GUIFontCache.h
+\brief
+*/
+
+#ifndef CGUILIB_GUIFONTCACHE_H
+#define CGUILIB_GUIFONTCACHE_H
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <cstddef>
+#include <cstring>
+#include <stdint.h>
+
+#include <algorithm>
+#include <vector>
+
+#include "boost/multi_index_container.hpp"
+#include "boost/multi_index/sequenced_index.hpp"
+#include "boost/multi_index/hashed_index.hpp"
+#include "boost/multi_index/member.hpp"
+
+#include "TransformMatrix.h"
+
+using namespace boost::multi_index;
+
+#define FONT_CACHE_TIME_LIMIT (1000)
+
+template<class Position, class Value> class CGUIFontCache;
+class CGUIFontTTFBase;
+
+template<class Position>
+struct CGUIFontCacheKey
+{
+  Position m_pos;
+  vecColors &m_colors;
+  vecText &m_text;
+  uint32_t m_alignment;
+  float m_maxPixelWidth;
+  bool m_scrolling;
+  const TransformMatrix &m_matrix;
+  float m_scaleX;
+  float m_scaleY;
+
+  CGUIFontCacheKey(Position pos,
+                   vecColors &colors, vecText &text,
+                   uint32_t alignment, float maxPixelWidth,
+                   bool scrolling, const TransformMatrix &matrix,
+                   float scaleX, float scaleY) :
+    m_pos(pos),
+    m_colors(colors), m_text(text),
+    m_alignment(alignment), m_maxPixelWidth(maxPixelWidth),
+    m_scrolling(scrolling), m_matrix(matrix),
+    m_scaleX(scaleX), m_scaleY(scaleY)
+  {}
+};
+
+template<class Position, class Value>
+struct CGUIFontCacheEntry
+{
+  const CGUIFontCache<Position, Value> &m_cache;
+  CGUIFontCacheKey<Position> m_key;
+  TransformMatrix m_matrix;
+
+  /* These need to be declared as mutable to get round the fact that only
+   * const iterators are available. These fields do not affect comparison or
+   * hash functors, so from the container's point of view, they are mutable. */
+  mutable unsigned int m_lastUsedMillis;
+  mutable Value m_value;
+
+  CGUIFontCacheEntry(const CGUIFontCache<Position, Value> &cache, const CGUIFontCacheKey<Position> &key, unsigned int nowMillis) :
+    m_cache(cache),
+    m_key(key.m_pos,
+          *new vecColors, *new vecText,
+          key.m_alignment, key.m_maxPixelWidth,
+          key.m_scrolling, m_matrix,
+          key.m_scaleX, key.m_scaleY),
+    m_lastUsedMillis(nowMillis)
+  {
+    m_key.m_colors.assign(key.m_colors.begin(), key.m_colors.end());
+    m_key.m_text.assign(key.m_text.begin(), key.m_text.end());
+    m_matrix = key.m_matrix;
+  }
+
+  CGUIFontCacheEntry(const CGUIFontCacheEntry &other) :
+    m_cache(other.m_cache),
+    m_key(other.m_key.m_pos,
+          *new vecColors, *new vecText,
+          other.m_key.m_alignment, other.m_key.m_maxPixelWidth,
+          other.m_key.m_scrolling, m_matrix,
+          other.m_key.m_scaleX, other.m_key.m_scaleY),
+    m_lastUsedMillis(other.m_lastUsedMillis),
+    m_value(other.m_value)
+  {
+    m_key.m_colors.assign(other.m_key.m_colors.begin(), other.m_key.m_colors.end());
+    m_key.m_text.assign(other.m_key.m_text.begin(), other.m_key.m_text.end());
+    m_matrix = other.m_key.m_matrix;
+  }
+
+  struct Reassign
+  {
+    Reassign(const CGUIFontCacheKey<Position> &key, unsigned int nowMillis) : m_key(key), m_nowMillis(nowMillis) {}
+    void operator()(CGUIFontCacheEntry &entry);
+  private:
+    const CGUIFontCacheKey<Position> &m_key;
+    unsigned int m_nowMillis;
+  };
+
+  ~CGUIFontCacheEntry();
+};
+
+template<class Position>
+struct CGUIFontCacheHash
+{
+  size_t operator()(const CGUIFontCacheKey<Position> &key) const
+  {
+    /* Not much effort has gone into choosing this hash function */
+    size_t hash = 0, i;
+    for (i = 0; i < 3 && i < key.m_text.size(); ++i)
+      hash += key.m_text[i];
+    if (key.m_colors.size())
+      hash += key.m_colors[0];
+    hash += MatrixHashContribution(key);
+    return hash;
+  }
+};
+
+template<class Position>
+struct CGUIFontCacheKeysMatch
+{
+  bool operator()(const CGUIFontCacheKey<Position> &a, const CGUIFontCacheKey<Position> &b) const
+  {
+    return a.m_text == b.m_text &&
+           a.m_colors == b.m_colors &&
+           a.m_alignment == b.m_alignment &&
+           a.m_scrolling == b.m_scrolling &&
+           a.m_maxPixelWidth == b.m_maxPixelWidth &&
+           Match(a.m_pos, a.m_matrix, b.m_pos, b.m_matrix, a.m_scrolling) &&
+           a.m_scaleX == b.m_scaleX &&
+           a.m_scaleY == b.m_scaleY;
+  }
+};
+
+template<class Position, class Value>
+class CGUIFontCache
+{
+  /* Empty structs used as tags to identify indexes */
+  struct Age {};
+  struct Hash {};
+
+  typedef multi_index_container<
+      CGUIFontCacheEntry<Position, Value>,
+      indexed_by<
+          sequenced<tag<Age> >,
+          hashed_unique<tag<Hash>, member<CGUIFontCacheEntry<Position, Value>, CGUIFontCacheKey<Position>, &CGUIFontCacheEntry<Position, Value>::m_key>, CGUIFontCacheHash<Position>, CGUIFontCacheKeysMatch<Position> >
+      >
+  > EntryList;
+
+  typedef typename EntryList::template index<Age>::type::iterator EntryAgeIterator;
+  typedef typename EntryList::template index<Hash>::type::iterator EntryHashIterator;
+
+  EntryList m_list;
+
+public:
+  const CGUIFontTTFBase &m_font;
+
+  CGUIFontCache(CGUIFontTTFBase &font) : m_font(font) {}
+  Value &Lookup(Position &pos,
+                const vecColors &colors, const vecText &text,
+                uint32_t alignment, float maxPixelWidth,
+                bool scrolling,
+                unsigned int nowMillis, bool &dirtyCache);
+  void Flush();
+};
+
+struct CGUIFontCacheStaticPosition
+{
+  float m_x;
+  float m_y;
+  CGUIFontCacheStaticPosition(float x, float y) : m_x(x), m_y(y) {}
+};
+
+typedef std::vector<SVertex> CGUIFontCacheStaticValue;
+
+inline bool Match(const CGUIFontCacheStaticPosition &a, const TransformMatrix &a_m,
+                  const CGUIFontCacheStaticPosition &b, const TransformMatrix &b_m,
+                  bool scrolling)
+{
+  return a.m_x == b.m_x && a.m_y == b.m_y && a_m == b_m;
+}
+
+inline float MatrixHashContribution(const CGUIFontCacheKey<CGUIFontCacheStaticPosition> &a)
+{
+  /* Ensure horizontally translated versions end up in different buckets */
+  return a.m_matrix.m[0][3];
+}
+
+#endif
diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 848c5c8..0290fc4 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -27,6 +27,7 @@
 #include "utils/MathUtils.h"
 #include "utils/log.h"
 #include "windowing/WindowingFactory.h"
+#include "threads/SystemClock.h"
 
 #include <math.h>
 
@@ -131,7 +132,7 @@ class CFreeTypeLibrary
 XBMC_GLOBAL_REF(CFreeTypeLibrary, g_freeTypeLibrary); // our freetype library
 #define g_freeTypeLibrary XBMC_GLOBAL_USE(CFreeTypeLibrary)
 
-CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName)
+CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName) : m_staticCache(*this)
 {
   m_texture = NULL;
   m_char = NULL;
@@ -329,108 +330,120 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
 {
   Begin();
 
-  std::vector<SVertex> &vertices = m_vertex;
-
-  // save the origin, which is scaled separately
-  m_originX = x;
-  m_originY = y;
-
-  // Check if we will really need to truncate or justify the text
-  if ( alignment & XBFONT_TRUNCATED )
+  bool dirtyCache;
+  CGUIFontCacheStaticPosition staticPos(x, y);
+  std::vector<SVertex> &vertices = m_staticCache.Lookup(staticPos,
+                                                        colors, text,
+                                                        alignment, maxPixelWidth,
+                                                        scrolling,
+                                                        XbmcThreads::SystemClockMillis(),
+                                                        dirtyCache);
+  if (dirtyCache)
   {
-    if ( maxPixelWidth <= 0.0f || GetTextWidthInternal(text.begin(), text.end()) <= maxPixelWidth)
-      alignment &= ~XBFONT_TRUNCATED;
-  }
-  else if ( alignment & XBFONT_JUSTIFIED )
-  {
-    if ( maxPixelWidth <= 0.0f )
-      alignment &= ~XBFONT_JUSTIFIED;
-  }
+    // save the origin, which is scaled separately
+    m_originX = x;
+    m_originY = y;
 
-  // calculate sizing information
-  float startX = 0;
-  float startY = (alignment & XBFONT_CENTER_Y) ? -0.5f*m_cellHeight : 0;  // vertical centering
+    // Check if we will really need to truncate or justify the text
+    if ( alignment & XBFONT_TRUNCATED )
+    {
+      if ( maxPixelWidth <= 0.0f || GetTextWidthInternal(text.begin(), text.end()) <= maxPixelWidth)
+        alignment &= ~XBFONT_TRUNCATED;
+    }
+    else if ( alignment & XBFONT_JUSTIFIED )
+    {
+      if ( maxPixelWidth <= 0.0f )
+        alignment &= ~XBFONT_JUSTIFIED;
+    }
 
-  if ( alignment & (XBFONT_RIGHT | XBFONT_CENTER_X) )
-  {
-    // Get the extent of this line
-    float w = GetTextWidthInternal( text.begin(), text.end() );
+    // calculate sizing information
+    float startX = 0;
+    float startY = (alignment & XBFONT_CENTER_Y) ? -0.5f*m_cellHeight : 0;  // vertical centering
 
-    if ( alignment & XBFONT_TRUNCATED && w > maxPixelWidth + 0.5f ) // + 0.5f due to rounding issues
-      w = maxPixelWidth;
+    if ( alignment & (XBFONT_RIGHT | XBFONT_CENTER_X) )
+    {
+      // Get the extent of this line
+      float w = GetTextWidthInternal( text.begin(), text.end() );
 
-    if ( alignment & XBFONT_CENTER_X)
-      w *= 0.5f;
-    // Offset this line's starting position
-    startX -= w;
-  }
+      if ( alignment & XBFONT_TRUNCATED && w > maxPixelWidth + 0.5f ) // + 0.5f due to rounding issues
+        w = maxPixelWidth;
 
-  float spacePerLetter = 0; // for justification effects
-  if ( alignment & XBFONT_JUSTIFIED )
-  {
-    // first compute the size of the text to render in both characters and pixels
-    unsigned int lineChars = 0;
-    float linePixels = 0;
-    for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
+      if ( alignment & XBFONT_CENTER_X)
+        w *= 0.5f;
+      // Offset this line's starting position
+      startX -= w;
+    }
+
+    float spacePerLetter = 0; // for justification effects
+    if ( alignment & XBFONT_JUSTIFIED )
     {
-      Character *ch = GetCharacter(*pos);
-      if (ch)
-      { // spaces have multiple times the justification spacing of normal letters
-        lineChars += ((*pos & 0xffff) == L' ') ? justification_word_weight : 1;
-        linePixels += ch->advance;
+      // first compute the size of the text to render in both characters and pixels
+      unsigned int lineChars = 0;
+      float linePixels = 0;
+      for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
+      {
+        Character *ch = GetCharacter(*pos);
+        if (ch)
+        { // spaces have multiple times the justification spacing of normal letters
+          lineChars += ((*pos & 0xffff) == L' ') ? justification_word_weight : 1;
+          linePixels += ch->advance;
+        }
       }
+      if (lineChars > 1)
+        spacePerLetter = (maxPixelWidth - linePixels) / (lineChars - 1);
     }
-    if (lineChars > 1)
-      spacePerLetter = (maxPixelWidth - linePixels) / (lineChars - 1);
-  }
-  float cursorX = 0; // current position along the line
-
-  for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
-  {
-    // If starting text on a new line, determine justification effects
-    // Get the current letter in the CStdString
-    color_t color = (*pos & 0xff0000) >> 16;
-    if (color >= colors.size())
-      color = 0;
-    color = colors[color];
+    float cursorX = 0; // current position along the line
 
-    // grab the next character
-    Character *ch = GetCharacter(*pos);
-    if (!ch) continue;
-
-    if ( alignment & XBFONT_TRUNCATED )
+    for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
     {
-      // Check if we will be exceeded the max allowed width
-      if ( cursorX + ch->advance + 3 * m_ellipsesWidth > maxPixelWidth )
-      {
-        // Yup. Let's draw the ellipses, then bail
-        // Perhaps we should really bail to the next line in this case??
-        Character *period = GetCharacter(L'.');
-        if (!period)
-          break;
+      // If starting text on a new line, determine justification effects
+      // Get the current letter in the CStdString
+      color_t color = (*pos & 0xff0000) >> 16;
+      if (color >= colors.size())
+        color = 0;
+      color = colors[color];
+
+      // grab the next character
+      Character *ch = GetCharacter(*pos);
+      if (!ch) continue;
 
-        for (int i = 0; i < 3; i++)
+      if ( alignment & XBFONT_TRUNCATED )
+      {
+        // Check if we will be exceeded the max allowed width
+        if ( cursorX + ch->advance + 3 * m_ellipsesWidth > maxPixelWidth )
         {
-          RenderCharacter(startX + cursorX, startY, period, color, !scrolling, vertices);
-          cursorX += period->advance;
+          // Yup. Let's draw the ellipses, then bail
+          // Perhaps we should really bail to the next line in this case??
+          Character *period = GetCharacter(L'.');
+          if (!period)
+            break;
+
+          for (int i = 0; i < 3; i++)
+          {
+            RenderCharacter(startX + cursorX, startY, period, color, !scrolling, vertices);
+            cursorX += period->advance;
+          }
+          break;
         }
-        break;
       }
-    }
-    else if (maxPixelWidth > 0 && cursorX > maxPixelWidth)
-      break;  // exceeded max allowed width - stop rendering
+      else if (maxPixelWidth > 0 && cursorX > maxPixelWidth)
+        break;  // exceeded max allowed width - stop rendering
 
-    RenderCharacter(startX + cursorX, startY, ch, color, !scrolling, vertices);
-    if ( alignment & XBFONT_JUSTIFIED )
-    {
-      if ((*pos & 0xffff) == L' ')
-        cursorX += ch->advance + spacePerLetter * justification_word_weight;
+      RenderCharacter(startX + cursorX, startY, ch, color, !scrolling, vertices);
+      if ( alignment & XBFONT_JUSTIFIED )
+      {
+        if ((*pos & 0xffff) == L' ')
+          cursorX += ch->advance + spacePerLetter * justification_word_weight;
+        else
+          cursorX += ch->advance + spacePerLetter;
+      }
       else
-        cursorX += ch->advance + spacePerLetter;
+        cursorX += ch->advance;
     }
-    else
-      cursorX += ch->advance;
   }
+  /* Append the new vertices (from the cache or otherwise) to the set collected
+   * since the first Begin() call */
+  m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
 
   End();
 }
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index dde0350..77111bc 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -64,6 +64,9 @@ struct SVertex
 };
 
 
+#include "GUIFontCache.h"
+
+
 class CGUIFontTTFBase
 {
   friend class CGUIFont;
@@ -165,6 +168,8 @@ class CGUIFontTTFBase
 
   CStdString m_strFileName;
 
+  CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue> m_staticCache;
+
 private:
   virtual bool FirstBegin() = 0;
   virtual void LastEnd() = 0;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index b76c6a5..9935ea4 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -221,6 +221,7 @@ CBaseTexture* CGUIFontTTFGL::ReallocTexture(unsigned int& newHeight)
   m_textureScaleX = 1.0f / m_textureWidth;
   if (m_textureHeight < newHeight)
     CLog::Log(LOGWARNING, "%s: allocated new texture with height of %d, requested %d", __FUNCTION__, m_textureHeight, newHeight);
+  m_staticCache.Flush();
 
   memset(newTexture->GetPixels(), 0, m_textureHeight * newTexture->GetPitch());
   if (m_texture)
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index 6c2dcd4..bab2457 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -146,6 +146,7 @@ class CGraphicContext : public CCriticalSection,
   inline void ScaleFinalCoords(float &x, float &y, float &z) const XBMC_FORCE_INLINE { m_finalTransform.matrix.TransformPosition(x, y, z); }
   bool RectIsAngled(float x1, float y1, float x2, float y2) const;
 
+  inline const TransformMatrix &GetGUIMatrix() const XBMC_FORCE_INLINE { return m_finalTransform.matrix; }
   inline float GetGUIScaleX() const XBMC_FORCE_INLINE { return m_finalTransform.scaleX; }
   inline float GetGUIScaleY() const XBMC_FORCE_INLINE { return m_finalTransform.scaleY; }
   inline color_t MergeAlpha(color_t color) const XBMC_FORCE_INLINE
diff --git a/xbmc/guilib/Makefile.in b/xbmc/guilib/Makefile.in
index 086fb0d..af82979 100644
--- a/xbmc/guilib/Makefile.in
+++ b/xbmc/guilib/Makefile.in
@@ -23,6 +23,7 @@ SRCS += GUIEditControl.cpp
 SRCS += GUIFadeLabelControl.cpp
 SRCS += GUIFixedListContainer.cpp
 SRCS += GUIFont.cpp
+SRCS += GUIFontCache.cpp
 SRCS += GUIFontManager.cpp
 SRCS += GUIFontTTF.cpp
 SRCS += GUIImage.cpp
diff --git a/xbmc/guilib/TransformMatrix.h b/xbmc/guilib/TransformMatrix.h
index f351c99..9036ba9 100644
--- a/xbmc/guilib/TransformMatrix.h
+++ b/xbmc/guilib/TransformMatrix.h
@@ -245,3 +245,14 @@ class TransformMatrix
   float alpha;
   bool identity;
 };
+
+inline bool operator==(const TransformMatrix &a, const TransformMatrix &b)
+{
+  return a.alpha == b.alpha && ((a.identity && b.identity) ||
+      (!a.identity && !b.identity && std::equal(&a.m[0][0], &a.m[0][0] + sizeof a.m / sizeof a.m[0][0], &b.m[0][0])));
+}
+
+inline bool operator!=(const TransformMatrix &a, const TransformMatrix &b)
+{
+  return !operator==(a, b);
+}

From 7a0a7b745d08f94b93ab789b33aa9447e9427e29 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 23 Jan 2014 22:24:17 +0000
Subject: [PATCH 22/77] Lay the groundwork for hardware clipping.

For glScissor() to replace CGraphicContext::ClipRect, a necessary condition
is that no shear or rotation is introduced between the coordinate systems
they use; this depends upon the settings of the GUI matrix m_finalTransform
as well as the OpenGL model-view and projection matrices. These all remain
unchanged between paired calls of CGUIShader::OnEnabled and
CGUIShader::OnDisabled, so we scan the matrices in CGUIShader::OnEnabled to
see whether hardware clipping is possible.

Then, in CGUIFontTTFBase::RenderCharacter, we don't apply software clipping
in such cases. However, because vertices arising from multiple
CGUIFontTTFBase::DrawTextInternal calls (each of which often uses a different
clip rectangle) get lumped into the same vector, which only at the end is
passed to OpenGL for rendering, we need to wait a few commits before we can
actually apply hardware clipping. In the meantime, expect to see rendering
errors.
---
 xbmc/guilib/GUIFontTTF.cpp               |  3 +-
 xbmc/guilib/GUIShader.cpp                | 80 +++++++++++++++++++++++++++++++-
 xbmc/guilib/GUIShader.h                  | 11 +++++
 xbmc/guilib/GraphicContext.cpp           | 10 ++++
 xbmc/guilib/GraphicContext.h             |  1 +
 xbmc/rendering/RenderSystem.h            |  2 +
 xbmc/rendering/gles/RenderSystemGLES.cpp | 22 +++++++++
 xbmc/rendering/gles/RenderSystemGLES.h   |  2 +
 8 files changed, 128 insertions(+), 3 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 0290fc4..e3808d9 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -709,7 +709,8 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
                (posY + ch->offsetY + height) * g_graphicsContext.GetGUIScaleY());
   vertex += CPoint(m_originX, m_originY);
   CRect texture(ch->left, ch->top, ch->right, ch->bottom);
-  g_graphicsContext.ClipRect(vertex, texture);
+  if (!g_Windowing.ScissorsCanEffectClipping())
+    g_graphicsContext.ClipRect(vertex, texture);
 
   // transform our positions - note, no scaling due to GUI calibration/resolution occurs
   float x[4], y[4], z[4];
diff --git a/xbmc/guilib/GUIShader.cpp b/xbmc/guilib/GUIShader.cpp
index 23cb84f..5d836cee 100644
--- a/xbmc/guilib/GUIShader.cpp
+++ b/xbmc/guilib/GUIShader.cpp
@@ -26,6 +26,8 @@
 #include "GUIShader.h"
 #include "MatrixGLES.h"
 #include "utils/log.h"
+#include "windowing/WindowingFactory.h"
+#include "guilib/GraphicContext.h"
 
 using namespace Shaders;
 
@@ -88,8 +90,82 @@ bool CGUIShader::OnEnabled()
 {
   // This is called after glUseProgram()
 
-  glUniformMatrix4fv(m_hProj,  1, GL_FALSE, g_matrices.GetMatrix(MM_PROJECTION));
-  glUniformMatrix4fv(m_hModel, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
+  GLfloat *projMatrix = g_matrices.GetMatrix(MM_PROJECTION);
+  GLfloat *modelMatrix = g_matrices.GetMatrix(MM_MODELVIEW);
+  glUniformMatrix4fv(m_hProj,  1, GL_FALSE, projMatrix);
+  glUniformMatrix4fv(m_hModel, 1, GL_FALSE, modelMatrix);
+
+  const TransformMatrix &guiMatrix = g_graphicsContext.GetGUIMatrix();
+  CRect viewPort; // absolute positions of corners
+  g_Windowing.GetViewPort(viewPort);
+
+  /* glScissor operates in window coordinates. In order that we can use it to
+   * perform clipping, we must ensure that there is an independent linear
+   * transformation from the coordinate system used by CGraphicContext::ClipRect
+   * to window coordinates, separately for X and Y (in other words, no
+   * rotation or shear is introduced at any stage). To do, this, we need to
+   * check that zeros are present in the following locations:
+   *
+   * GUI matrix:
+   * / * 0 * * \
+   * | 0 * * * |
+   * \ 0 0 * * /
+   *       ^ TransformMatrix::TransformX/Y/ZCoord are only ever called with
+   *         input z = 0, so this column doesn't matter
+   * Model-view matrix:
+   * / * 0 0 * \
+   * | 0 * 0 * |
+   * | 0 0 * * |
+   * \ * * * * /  <- eye w has no influence on window x/y (last column below
+   *                                                       is either 0 or ignored)
+   * Projection matrix:
+   * / * 0 0 0 \
+   * | 0 * 0 0 |
+   * | * * * * |  <- normalised device coordinate z has no influence on window x/y
+   * \ 0 0 * 0 /
+   *
+   * Some of these zeros are not strictly required to ensure this, but they tend
+   * to be zeroed in the common case, so by checking for zeros here, we simplify
+   * the calculation of the window x/y coordinates further down the line.
+   *
+   * (Minor detail: we don't quite deal in window coordinates as defined by
+   * OpenGL, because CRenderSystemGLES::SetScissors flips the Y axis. But all
+   * that's needed to handle that is an effective negation at the stage where
+   * Y is in normalised device coordinates.)
+   */
+  m_clipPossible = guiMatrix.m[0][1] == 0 &&
+      guiMatrix.m[1][0] == 0 &&
+      guiMatrix.m[2][0] == 0 &&
+      guiMatrix.m[2][1] == 0 &&
+      modelMatrix[0+1*4] == 0 &&
+      modelMatrix[0+2*4] == 0 &&
+      modelMatrix[1+0*4] == 0 &&
+      modelMatrix[1+2*4] == 0 &&
+      modelMatrix[2+0*4] == 0 &&
+      modelMatrix[2+1*4] == 0 &&
+      projMatrix[0+1*4] == 0 &&
+      projMatrix[0+2*4] == 0 &&
+      projMatrix[0+3*4] == 0 &&
+      projMatrix[1+0*4] == 0 &&
+      projMatrix[1+2*4] == 0 &&
+      projMatrix[1+3*4] == 0 &&
+      projMatrix[3+0*4] == 0 &&
+      projMatrix[3+1*4] == 0 &&
+      projMatrix[3+3*4] == 0;
+  if (m_clipPossible)
+  {
+    m_clipXFactor = guiMatrix.m[0][0] * modelMatrix[0+0*4] * projMatrix[0+0*4];
+    m_clipXOffset = (guiMatrix.m[0][3] * modelMatrix[0+0*4] + modelMatrix[0+3*4]) * projMatrix[0+0*4];
+    m_clipYFactor = guiMatrix.m[1][1] * modelMatrix[1+1*4] * projMatrix[1+1*4];
+    m_clipYOffset = (guiMatrix.m[1][3] * modelMatrix[1+1*4] + modelMatrix[1+3*4]) * projMatrix[1+1*4];
+    float clipW = (guiMatrix.m[2][3] * modelMatrix[2+2*4] + modelMatrix[2+3*4]) * projMatrix[3+2*4];
+    float xMult = (viewPort.x2 - viewPort.x1) / (2 * clipW);
+    float yMult = (viewPort.y1 - viewPort.y2) / (2 * clipW); // correct for inverted window coordinate scheme
+    m_clipXFactor = m_clipXFactor * xMult;
+    m_clipXOffset = m_clipXOffset * xMult + (viewPort.x2 + viewPort.x1) / 2;
+    m_clipYFactor = m_clipYFactor * yMult;
+    m_clipYOffset = m_clipYOffset * yMult + (viewPort.y2 + viewPort.y1) / 2;
+  }
 
   return true;
 }
diff --git a/xbmc/guilib/GUIShader.h b/xbmc/guilib/GUIShader.h
index f7b5d9a..fdf7452 100644
--- a/xbmc/guilib/GUIShader.h
+++ b/xbmc/guilib/GUIShader.h
@@ -39,6 +39,11 @@ class CGUIShader : public Shaders::CGLSLShaderProgram
   GLint GetCord1Loc() { return m_hCord1; }
   GLint GetUniColLoc() { return m_hUniCol; }
   GLint GetCoord0MatrixLoc() { return m_hCoord0Matrix; }
+  bool HardwareClipIsPossible() { return m_clipPossible; }
+  GLfloat GetClipXFactor() { return m_clipXFactor; }
+  GLfloat GetClipXOffset() { return m_clipXOffset; }
+  GLfloat GetClipYFactor() { return m_clipYFactor; }
+  GLfloat GetClipYOffset() { return m_clipYOffset; }
 
 protected:
   GLint m_hTex0;
@@ -54,6 +59,12 @@ class CGUIShader : public Shaders::CGLSLShaderProgram
 
   GLfloat *m_proj;
   GLfloat *m_model;
+
+  bool m_clipPossible;
+  GLfloat m_clipXFactor;
+  GLfloat m_clipXOffset;
+  GLfloat m_clipYFactor;
+  GLfloat m_clipYOffset;
 };
 
 #endif // GUI_SHADER_H
diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 38f17a7..5bffdf5 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -167,6 +167,16 @@ void CGraphicContext::ClipRect(CRect &vertex, CRect &texture, CRect *texture2)
   }
 }
 
+CRect CGraphicContext::GetClipRegion()
+{
+  if (m_clipRegions.empty())
+    return CRect(0, 0, m_iScreenWidth, m_iScreenHeight);
+  CRect clipRegion(m_clipRegions.top());
+  if (!m_origins.empty())
+    clipRegion -= m_origins.top();
+  return clipRegion;
+}
+
 bool CGraphicContext::SetViewPort(float fx, float fy, float fwidth, float fheight, bool intersectPrevious /* = false */)
 {
   // transform coordinates - we may have a rotation which changes the positioning of the
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index bab2457..0a27643 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -199,6 +199,7 @@ class CGraphicContext : public CCriticalSection,
   void ApplyHardwareTransform();
   void RestoreHardwareTransform();
   void ClipRect(CRect &vertex, CRect &texture, CRect *diffuse = NULL);
+  CRect GetClipRegion();
   inline void AddGUITransform()
   {
     m_transforms.push(m_finalTransform);
diff --git a/xbmc/rendering/RenderSystem.h b/xbmc/rendering/RenderSystem.h
index fa64eba..c1dfb93 100644
--- a/xbmc/rendering/RenderSystem.h
+++ b/xbmc/rendering/RenderSystem.h
@@ -110,6 +110,8 @@ class CRenderSystemBase
   virtual void GetViewPort(CRect& viewPort) = 0;
   virtual void RestoreViewPort() {};
 
+  virtual bool ScissorsCanEffectClipping() { return false; }
+  virtual CRect ClipRectToScissorRect(const CRect &rect) { return CRect(); }
   virtual void SetScissors(const CRect &rect) = 0;
   virtual void ResetScissors() = 0;
 
diff --git a/xbmc/rendering/gles/RenderSystemGLES.cpp b/xbmc/rendering/gles/RenderSystemGLES.cpp
index 653c9ec..deb3afc 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.cpp
+++ b/xbmc/rendering/gles/RenderSystemGLES.cpp
@@ -533,6 +533,28 @@ void CRenderSystemGLES::SetViewPort(CRect& viewPort)
   m_viewPort[3] = viewPort.Height();
 }
 
+bool CRenderSystemGLES::ScissorsCanEffectClipping()
+{
+  if (m_pGUIshader[m_method])
+    return m_pGUIshader[m_method]->HardwareClipIsPossible();
+
+  return false;
+}
+
+CRect CRenderSystemGLES::ClipRectToScissorRect(const CRect &rect)
+{
+  if (!m_pGUIshader[m_method])
+    return CRect();
+  float xFactor = m_pGUIshader[m_method]->GetClipXFactor();
+  float xOffset = m_pGUIshader[m_method]->GetClipXOffset();
+  float yFactor = m_pGUIshader[m_method]->GetClipYFactor();
+  float yOffset = m_pGUIshader[m_method]->GetClipYOffset();
+  return CRect(rect.x1 * xFactor + xOffset,
+               rect.y1 * yFactor + yOffset,
+               rect.x2 * xFactor + xOffset,
+               rect.y2 * yFactor + yOffset);
+}
+
 void CRenderSystemGLES::SetScissors(const CRect &rect)
 {
   if (!m_bRenderCreated)
diff --git a/xbmc/rendering/gles/RenderSystemGLES.h b/xbmc/rendering/gles/RenderSystemGLES.h
index 98e398a..81ee49e 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.h
+++ b/xbmc/rendering/gles/RenderSystemGLES.h
@@ -63,6 +63,8 @@ class CRenderSystemGLES : public CRenderSystemBase
   virtual void SetViewPort(CRect& viewPort);
   virtual void GetViewPort(CRect& viewPort);
 
+  virtual bool ScissorsCanEffectClipping();
+  virtual CRect ClipRectToScissorRect(const CRect &rect);
   virtual void SetScissors(const CRect& rect);
   virtual void ResetScissors();
 

From a5604966904a4e2fc856bd7c34175a71ca530dfe Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 23 Jan 2014 16:42:22 +0000
Subject: [PATCH 23/77] Increase font cache hit rate by keying on the
 fractional part of m_originX and m_originY *after* they have been through the
 graphics context's transformation matrix, plus the scale/rotation elements of
 the matrix, rather than the origin in the original frame of reference plus
 the complete transformation matrix. All vertices of individual glyph bounding
 boxes are a constant offset from this position, and when the fractional part
 of the translation is a match, the rounding of each vertex will be in the
 same direction; this permits us to calculate the desired vertices from the
 cached ones simply by adding the integer parts of the translations with no
 additional rounding steps.

Note that this requires that software clipping is *not* performed.
---
 xbmc/guilib/GUIFontCache.cpp |  8 +++++++
 xbmc/guilib/GUIFontCache.h   | 43 +++++++++++++++++++++++++++++++++++
 xbmc/guilib/GUIFontTTF.cpp   | 53 +++++++++++++++++++++++++++++++++++---------
 xbmc/guilib/GUIFontTTF.h     |  1 +
 4 files changed, 95 insertions(+), 10 deletions(-)

diff --git a/xbmc/guilib/GUIFontCache.cpp b/xbmc/guilib/GUIFontCache.cpp
index 2c72f9c..df466a5 100644
--- a/xbmc/guilib/GUIFontCache.cpp
+++ b/xbmc/guilib/GUIFontCache.cpp
@@ -85,6 +85,9 @@ Value &CGUIFontCache<Position, Value>::Lookup(Position &pos,
   else
   {
     /* Cache hit */
+    /* Update the translation arguments so that they hold the offset to apply
+     * to the cached values (but only in the dynamic case) */
+    pos.UpdateWithOffsets(i->m_key.m_pos, scrolling);
     /* Update time in entry and move to the back of the list */
     i->m_lastUsedMillis = nowMillis;
     m_list.template get<Age>().relocate(m_list.template get<Age>().end(), m_list.template project<Age>(i));
@@ -103,3 +106,8 @@ template void CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStati
 template CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::~CGUIFontCacheEntry();
 template CGUIFontCacheStaticValue &CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Lookup(CGUIFontCacheStaticPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
 template void CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Flush();
+
+template void CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Reassign::operator()(CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue> &entry);
+template CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::~CGUIFontCacheEntry();
+template CGUIFontCacheDynamicValue &CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Lookup(CGUIFontCacheDynamicPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
+template void CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Flush();
diff --git a/xbmc/guilib/GUIFontCache.h b/xbmc/guilib/GUIFontCache.h
index ef65845..d913dee 100644
--- a/xbmc/guilib/GUIFontCache.h
+++ b/xbmc/guilib/GUIFontCache.h
@@ -44,6 +44,7 @@
 using namespace boost::multi_index;
 
 #define FONT_CACHE_TIME_LIMIT (1000)
+#define FONT_CACHE_DIST_LIMIT (0.01)
 
 template<class Position, class Value> class CGUIFontCache;
 class CGUIFontTTFBase;
@@ -197,6 +198,7 @@ struct CGUIFontCacheStaticPosition
   float m_x;
   float m_y;
   CGUIFontCacheStaticPosition(float x, float y) : m_x(x), m_y(y) {}
+  void UpdateWithOffsets(const CGUIFontCacheStaticPosition &cached, bool scrolling) {}
 };
 
 typedef std::vector<SVertex> CGUIFontCacheStaticValue;
@@ -214,4 +216,45 @@ inline float MatrixHashContribution(const CGUIFontCacheKey<CGUIFontCacheStaticPo
   return a.m_matrix.m[0][3];
 }
 
+struct CGUIFontCacheDynamicPosition
+{
+  float m_x;
+  float m_y;
+  float m_z;
+  CGUIFontCacheDynamicPosition() {}
+  CGUIFontCacheDynamicPosition(float x, float y, float z) : m_x(x), m_y(y), m_z(z) {}
+  void UpdateWithOffsets(const CGUIFontCacheDynamicPosition &cached, bool scrolling)
+  {
+    if (scrolling)
+      m_x = m_x - cached.m_x;
+    else
+      m_x = floorf(m_x - cached.m_x + FONT_CACHE_DIST_LIMIT);
+    m_y = floorf(m_y - cached.m_y + FONT_CACHE_DIST_LIMIT);
+    m_z = floorf(m_z - cached.m_z + FONT_CACHE_DIST_LIMIT);
+  }
+};
+
+typedef std::vector<SVertex> CGUIFontCacheDynamicValue;
+
+inline bool Match(const CGUIFontCacheDynamicPosition &a, const TransformMatrix &a_m,
+                  const CGUIFontCacheDynamicPosition &b, const TransformMatrix &b_m,
+                  bool scrolling)
+{
+  float diffX = a.m_x - b.m_x + FONT_CACHE_DIST_LIMIT;
+  float diffY = a.m_y - b.m_y + FONT_CACHE_DIST_LIMIT;
+  float diffZ = a.m_z - b.m_z + FONT_CACHE_DIST_LIMIT;
+  return (scrolling || diffX - floorf(diffX) < 2 * FONT_CACHE_DIST_LIMIT) &&
+          diffY - floorf(diffY) < 2 * FONT_CACHE_DIST_LIMIT &&
+          diffZ - floorf(diffZ) < 2 * FONT_CACHE_DIST_LIMIT &&
+          a_m.m[0][0] == b_m.m[0][0] &&
+          a_m.m[1][1] == b_m.m[1][1] &&
+          a_m.m[2][2] == b_m.m[2][2];
+          // We already know the first 3 columns of both matrices are diagonal, so no need to check the other elements
+}
+
+inline float MatrixHashContribution(const CGUIFontCacheKey<CGUIFontCacheDynamicPosition> &a)
+{
+  return 0;
+}
+
 #endif
diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index e3808d9..412f47a 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -132,7 +132,7 @@ class CFreeTypeLibrary
 XBMC_GLOBAL_REF(CFreeTypeLibrary, g_freeTypeLibrary); // our freetype library
 #define g_freeTypeLibrary XBMC_GLOBAL_USE(CFreeTypeLibrary)
 
-CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName) : m_staticCache(*this)
+CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName) : m_staticCache(*this), m_dynamicCache(*this)
 {
   m_texture = NULL;
   m_char = NULL;
@@ -331,13 +331,28 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
   Begin();
 
   bool dirtyCache;
+  bool hardwareClipping = g_Windowing.ScissorsCanEffectClipping();
   CGUIFontCacheStaticPosition staticPos(x, y);
-  std::vector<SVertex> &vertices = m_staticCache.Lookup(staticPos,
-                                                        colors, text,
-                                                        alignment, maxPixelWidth,
-                                                        scrolling,
-                                                        XbmcThreads::SystemClockMillis(),
-                                                        dirtyCache);
+  CGUIFontCacheDynamicPosition dynamicPos;
+  if (hardwareClipping)
+  {
+    dynamicPos = CGUIFontCacheDynamicPosition(g_graphicsContext.ScaleFinalXCoord(x, y),
+                                              g_graphicsContext.ScaleFinalYCoord(x, y),
+                                              g_graphicsContext.ScaleFinalZCoord(x, y));
+  }
+  std::vector<SVertex> &vertices = hardwareClipping ?
+      m_dynamicCache.Lookup(dynamicPos,
+                            colors, text,
+                            alignment, maxPixelWidth,
+                            scrolling,
+                            XbmcThreads::SystemClockMillis(),
+                            dirtyCache) :
+      m_staticCache.Lookup(staticPos,
+                           colors, text,
+                           alignment, maxPixelWidth,
+                           scrolling,
+                           XbmcThreads::SystemClockMillis(),
+                           dirtyCache);
   if (dirtyCache)
   {
     // save the origin, which is scaled separately
@@ -440,10 +455,28 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
       else
         cursorX += ch->advance;
     }
+    if (hardwareClipping)
+      /* Append the new vertices (which we have just constructed in the cache)
+       * to the set collected since the first Begin() call */
+      m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+  }
+  else if (hardwareClipping)
+  {
+    /* Apply the translation offset to the vertices from the cache after
+     * appending them to the set collected since the first Begin() call */
+    m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+    SVertex *v;
+    for (v = &*m_vertex.end() - vertices.size(); v != &*m_vertex.end(); v++)
+    {
+      v->x += dynamicPos.m_x;
+      v->y += dynamicPos.m_y;
+      v->z += dynamicPos.m_z;
+    }
   }
-  /* Append the new vertices (from the cache or otherwise) to the set collected
-   * since the first Begin() call */
-  m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+  if (!hardwareClipping)
+    /* Append the new vertices (from the cache or otherwise) to the set collected
+     * since the first Begin() call */
+    m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
 
   End();
 }
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 77111bc..39bfa52 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -169,6 +169,7 @@ class CGUIFontTTFBase
   CStdString m_strFileName;
 
   CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue> m_staticCache;
+  CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue> m_dynamicCache;
 
 private:
   virtual bool FirstBegin() = 0;

From 37f4f936fe6d927b8c556a46d812cebbbe5475d7 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 8 Jan 2014 12:16:33 +0000
Subject: [PATCH 24/77] Rewrite of scrolling text code.

No longer shuffles the string round to minimise the number of characters
before the clipping rectangle; this doesn't save much on rendering time but
does harm the effectiveness of the cache. Now uses a pixel offset into the
string rather than a character + pixel offset, and plots the entire string
every time (execpt when the wrap point is visible, in which case the entire
string is plotted twice).

It also makes motion smoother, because (possibly unintentionally) the
previous code preferred to align the scroll offset with character boundaries.
This would lead to uneven changes of position, especially when the width of
the character currently being scrolled off the edge was only slightly more
than an integral multiple of the scroll increment.
---
 xbmc/guilib/GUIFadeLabelControl.cpp |   8 +--
 xbmc/guilib/GUIFont.cpp             | 123 +++++++++++++-----------------------
 xbmc/guilib/GUIFont.h               |  17 ++---
 xbmc/guilib/GUIRSSControl.cpp       |   6 +-
 xbmc/utils/RssReader.cpp            |   2 +-
 xbmc/utils/RssReader.h              |   2 +-
 6 files changed, 58 insertions(+), 100 deletions(-)

diff --git a/xbmc/guilib/GUIFadeLabelControl.cpp b/xbmc/guilib/GUIFadeLabelControl.cpp
index 844f960..5859d9f 100644
--- a/xbmc/guilib/GUIFadeLabelControl.cpp
+++ b/xbmc/guilib/GUIFadeLabelControl.cpp
@@ -109,18 +109,14 @@ void CGUIFadeLabelControl::Process(unsigned int currentTime, CDirtyRegionList &d
     bool moveToNextLabel = false;
     if (!m_scrollOut)
     {
-      vecText text;
-      m_textLayout.GetFirstText(text);
-      if (m_scrollInfo.characterPos && m_scrollInfo.characterPos < text.size())
-        text.erase(text.begin(), text.begin() + min((int)m_scrollInfo.characterPos - 1, (int)text.size()));
-      if (m_label.font->GetTextWidth(text) < m_width)
+      if (m_scrollInfo.pixelPos + m_width > m_scrollInfo.m_textWidth)
       {
         if (m_fadeAnim.GetProcess() != ANIM_PROCESS_NORMAL)
           m_fadeAnim.QueueAnimation(ANIM_PROCESS_NORMAL);
         moveToNextLabel = true;
       }
     }
-    else if (m_scrollInfo.characterPos > m_textLayout.GetTextLength())
+    else if (m_scrollInfo.pixelPos > m_scrollInfo.m_textWidth)
       moveToNextLabel = true;
     
     // apply the fading animation
diff --git a/xbmc/guilib/GUIFont.cpp b/xbmc/guilib/GUIFont.cpp
index a7ee668..eb8efdb 100644
--- a/xbmc/guilib/GUIFont.cpp
+++ b/xbmc/guilib/GUIFont.cpp
@@ -36,7 +36,12 @@ CScrollInfo::CScrollInfo(unsigned int wait /* = 50 */, float pos /* = 0 */,
     initialWait = wait;
     initialPos = pos;
     SetSpeed(speed ? speed : defaultSpeed);
-    g_charsetConverter.utf8ToW(scrollSuffix, suffix);
+    CStdStringW wsuffix;
+    g_charsetConverter.utf8ToW(scrollSuffix, wsuffix);
+    suffix.clear();
+    suffix.reserve(wsuffix.size());
+    for (vecText::size_type i = 0; i < wsuffix.size(); i++)
+      suffix.push_back(wsuffix[i]);
     Reset();
 }
 
@@ -115,11 +120,12 @@ bool CGUIFont::UpdateScrollInfo(const vecText &text, CScrollInfo &scrollInfo)
 {
   // draw at our scroll position
   // we handle the scrolling as follows:
-  //   We scroll on a per-pixel basis up until we have scrolled the first character outside
-  //   of our viewport, whereby we cycle the string around, and reset the scroll position.
-  //
-  //   pixelPos is the amount in pixels to move the string by.
-  //   characterPos is the amount in characters to rotate the string by.
+  //   We scroll on a per-pixel basis (eschewing the use of character indices
+  //   which were also in use previously). The complete string, including suffix,
+  //   is plotted to achieve the desired effect - normally just the one time, but
+  //   if there is a wrap point within the viewport then it will be plotted twice.
+  //   If the string is smaller than the viewport, then it may be plotted even
+  //   more times than that.
   //
   if (scrollInfo.waitTime)
   {
@@ -135,54 +141,19 @@ bool CGUIFont::UpdateScrollInfo(const vecText &text, CScrollInfo &scrollInfo)
   // move along by the appropriate scroll amount
   float scrollAmount = fabs(scrollInfo.GetPixelsPerFrame() * g_graphicsContext.GetGUIScaleX());
 
-  if (scrollInfo.pixelSpeed > 0)
+  if (!scrollInfo.m_widthValid)
   {
-    // we want to move scrollAmount, grab the next character
-    float charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-    if (scrollInfo.pixelPos + scrollAmount < charWidth)
-      scrollInfo.pixelPos += scrollAmount;  // within the current character
-    else
-    { // past the current character, decrement scrollAmount by the charWidth and move to the next character
-      while (scrollInfo.pixelPos + scrollAmount >= charWidth)
-      {
-        scrollAmount -= (charWidth - scrollInfo.pixelPos);
-        scrollInfo.pixelPos = 0;
-        scrollInfo.characterPos++;
-        if (scrollInfo.characterPos >= text.size() + scrollInfo.suffix.size())
-        {
-          scrollInfo.Reset();
-          break;
-        }
-        charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-      }
-    }
-  }
-  else if (scrollInfo.pixelSpeed < 0)
-  { // scrolling backwards
-    // we want to move scrollAmount, grab the next character
-    float charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-    if (scrollInfo.pixelPos + scrollAmount < charWidth)
-      scrollInfo.pixelPos += scrollAmount;  // within the current character
-    else
-    { // past the current character, decrement scrollAmount by the charWidth and move to the next character
-      while (scrollInfo.pixelPos + scrollAmount >= charWidth)
-      {
-        scrollAmount -= (charWidth - scrollInfo.pixelPos);
-        scrollInfo.pixelPos = 0;
-        if (scrollInfo.characterPos == 0)
-        {
-          scrollInfo.Reset();
-          scrollInfo.characterPos = text.size() + scrollInfo.suffix.size() - 1;
-          break;
-        }
-        scrollInfo.characterPos--;
-        charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-      }
-    }
+    /* Calculate the pixel width of the complete string */
+    scrollInfo.m_textWidth = GetTextWidth(text);
+    scrollInfo.m_totalWidth = scrollInfo.m_textWidth + GetTextWidth(scrollInfo.suffix);
+    scrollInfo.m_widthValid = true;
   }
+  scrollInfo.pixelPos += scrollAmount;
+  assert(scrollInfo.m_totalWidth != 0);
+  while (scrollInfo.pixelPos >= scrollInfo.m_totalWidth)
+    scrollInfo.pixelPos -= scrollInfo.m_totalWidth;
 
-  if(scrollInfo.characterPos != old.characterPos
-  || scrollInfo.pixelPos     != old.pixelPos)
+  if (scrollInfo.pixelPos != old.pixelPos)
     return true;
   else
     return false;
@@ -194,39 +165,27 @@ void CGUIFont::DrawScrollingText(float x, float y, const vecColors &colors, colo
   if (!m_font) return;
   if (!shadowColor) shadowColor = m_shadowColor;
 
-  float spaceWidth = GetCharWidth(L' ');
-  // max chars on screen + extra margin chars
-  vecText::size_type maxChars =
-    std::min<vecText::size_type>(
-      (text.size() + (vecText::size_type)scrollInfo.suffix.size()),
-      (vecText::size_type)((maxWidth * 1.05f) / spaceWidth));
-
   if (!text.size() || ClippedRegionIsEmpty(x, y, maxWidth, alignment))
     return; // nothing to render
 
-  maxWidth = ROUND((maxWidth + scrollInfo.pixelPos) / g_graphicsContext.GetGUIScaleX());
+  if (!scrollInfo.m_widthValid)
+  {
+    /* Calculate the pixel width of the complete string */
+    scrollInfo.m_textWidth = GetTextWidth(text);
+    scrollInfo.m_totalWidth = scrollInfo.m_textWidth + GetTextWidth(scrollInfo.suffix);
+    scrollInfo.m_widthValid = true;
+  }
+
+  assert(scrollInfo.m_totalWidth != 0);
+
+  float textPixelWidth = ROUND(scrollInfo.m_textWidth / g_graphicsContext.GetGUIScaleX());
+  float suffixPixelWidth = ROUND((scrollInfo.m_totalWidth - scrollInfo.m_textWidth) / g_graphicsContext.GetGUIScaleX());
 
-  float charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
   float offset;
   if(scrollInfo.pixelSpeed >= 0)
     offset = scrollInfo.pixelPos;
   else
-    offset = charWidth - scrollInfo.pixelPos;
-
-  // Now rotate our string as needed, only take a slightly larger then visible part of the text.
-  unsigned int pos = scrollInfo.characterPos;
-  vecText renderText;
-  renderText.reserve(maxChars);
-  for (vecText::size_type i = 0; i < maxChars; i++)
-  {
-    if (pos >= text.size() + scrollInfo.suffix.size())
-      pos = 0;
-    if (pos < text.size())
-      renderText.push_back(text[pos]);
-    else
-      renderText.push_back(scrollInfo.suffix[pos - text.size()]);
-    pos++;
-  }
+    offset = scrollInfo.m_totalWidth - scrollInfo.pixelPos;
 
   vecColors renderColors;
   for (unsigned int i = 0; i < colors.size(); i++)
@@ -239,9 +198,17 @@ void CGUIFont::DrawScrollingText(float x, float y, const vecColors &colors, colo
     vecColors shadowColors;
     for (unsigned int i = 0; i < renderColors.size(); i++)
       shadowColors.push_back((renderColors[i] & 0xff000000) != 0 ? shadowColor : 0);
-    m_font->DrawTextInternal(x - offset + 1, y + 1, shadowColors, renderText, alignment, maxWidth + m_font->GetLineHeight(2.0f), scroll);
+    for (float dx = -offset; dx < maxWidth; dx += scrollInfo.m_totalWidth)
+    {
+      m_font->DrawTextInternal(x + dx + 1, y + 1, shadowColors, text, alignment, textPixelWidth, scroll);
+      m_font->DrawTextInternal(x + dx + scrollInfo.m_textWidth + 1, y + 1, shadowColors, scrollInfo.suffix, alignment, suffixPixelWidth, scroll);
+    }
+  }
+  for (float dx = -offset; dx < maxWidth; dx += scrollInfo.m_totalWidth)
+  {
+    m_font->DrawTextInternal(x + dx, y, renderColors, text, alignment, textPixelWidth, scroll);
+    m_font->DrawTextInternal(x + dx + scrollInfo.m_textWidth, y, renderColors, scrollInfo.suffix, alignment, suffixPixelWidth, scroll);
   }
-  m_font->DrawTextInternal(x - offset, y, renderColors, renderText, alignment, maxWidth + m_font->GetLineHeight(2.0f), scroll);
 
   g_graphicsContext.RestoreClipRegion();
 }
diff --git a/xbmc/guilib/GUIFont.h b/xbmc/guilib/GUIFont.h
index c55db48..09cf9b3 100644
--- a/xbmc/guilib/GUIFont.h
+++ b/xbmc/guilib/GUIFont.h
@@ -64,7 +64,6 @@ class CScrollInfo
   void Reset()
   {
     waitTime = initialWait;
-    characterPos = 0;
     // pixelPos is where we start the current letter, so is measured
     // to the left of the text rendering's left edge.  Thus, a negative
     // value will mean the text starts to the right
@@ -72,25 +71,19 @@ class CScrollInfo
     // privates:
     m_averageFrameTime = 1000.f / abs(defaultSpeed);
     m_lastFrameTime = 0;
-  }
-  uint32_t GetCurrentChar(const vecText &text) const
-  {
-    assert(text.size());
-    if (characterPos < text.size())
-      return text[characterPos];
-    else if (characterPos < text.size() + suffix.size())
-      return suffix[characterPos - text.size()];
-    return text[0];
+    m_widthValid = false;
   }
   float GetPixelsPerFrame();
 
   float pixelPos;
   float pixelSpeed;
   unsigned int waitTime;
-  unsigned int characterPos;
   unsigned int initialWait;
   float initialPos;
-  CStdStringW suffix;
+  vecText suffix;
+  mutable float m_textWidth;
+  mutable float m_totalWidth;
+  mutable bool m_widthValid;
 
   static const int defaultSpeed = 60;
 private:
diff --git a/xbmc/guilib/GUIRSSControl.cpp b/xbmc/guilib/GUIRSSControl.cpp
index 8d985cf..a8e20fc 100644
--- a/xbmc/guilib/GUIRSSControl.cpp
+++ b/xbmc/guilib/GUIRSSControl.cpp
@@ -119,7 +119,9 @@ void CGUIRSSControl::Process(unsigned int currentTime, CDirtyRegionList &dirtyre
       dirty = true;
 
       if (CRssManager::Get().GetReader(GetID(), GetParentID(), this, m_pReader))
-        m_scrollInfo.characterPos = m_pReader->m_SavedScrollPos;
+      {
+        m_scrollInfo.pixelPos = m_pReader->m_savedScrollPixelPos;
+      }
       else
       {
         if (m_strRSSTags != "")
@@ -174,7 +176,7 @@ void CGUIRSSControl::Render()
     if (m_pReader)
     {
       m_pReader->CheckForUpdates();
-      m_pReader->m_SavedScrollPos = m_scrollInfo.characterPos;
+      m_pReader->m_savedScrollPixelPos = m_scrollInfo.pixelPos;
     }
   }
   CGUIControl::Render();
diff --git a/xbmc/utils/RssReader.cpp b/xbmc/utils/RssReader.cpp
index 5383156..41f9bc2 100644
--- a/xbmc/utils/RssReader.cpp
+++ b/xbmc/utils/RssReader.cpp
@@ -55,7 +55,7 @@ CRssReader::CRssReader() : CThread("RSSReader")
   m_pObserver = NULL;
   m_spacesBetweenFeeds = 0;
   m_bIsRunning = false;
-  m_SavedScrollPos = 0;
+  m_savedScrollPixelPos = 0;
   m_rtlText = false;
   m_requestRefresh = false;
 }
diff --git a/xbmc/utils/RssReader.h b/xbmc/utils/RssReader.h
index 2cda726..fbc579e 100644
--- a/xbmc/utils/RssReader.h
+++ b/xbmc/utils/RssReader.h
@@ -43,7 +43,7 @@ class CRssReader : public CThread
   void SetObserver(IRssObserver* observer);
   void CheckForUpdates();
   void requestRefresh();
-  unsigned int m_SavedScrollPos;
+  float m_savedScrollPixelPos;
 
 private:
   void Process();

From 7bedebd03ff7a7986f178714a3586a07c3d5a9b5 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Mon, 27 Jan 2014 23:21:10 +0000
Subject: [PATCH 25/77] Move the application of the translation offsets into
 the GLES code.

Still all pure software at this stage. Main change is in the data types at
the interface between CGUIFontTTFBase and CGUIFontTTFGL. The old way
(array of vertices in m_vertex) are retained in addition, for the sake`of
cases that need to use software clipping on GLES, as well as for DX and GL
support where the new scheme is not (yet?) used.
---
 xbmc/guilib/GUIFontTTF.cpp   | 19 +++---------
 xbmc/guilib/GUIFontTTF.h     | 17 +++++++++++
 xbmc/guilib/GUIFontTTFGL.cpp | 72 ++++++++++++++++++++++++++++++++------------
 3 files changed, 73 insertions(+), 35 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 412f47a..b0e69c0 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -214,6 +214,7 @@ void CGUIFontTTFBase::Clear()
     g_freeTypeLibrary.ReleaseStroker(m_stroker);
   m_stroker = NULL;
 
+  m_vertexTrans.clear();
   m_vertex.clear();
 }
 
@@ -309,6 +310,7 @@ void CGUIFontTTFBase::Begin()
 {
   if (m_nestedBeginCount == 0 && m_texture != NULL && FirstBegin())
   {
+    m_vertexTrans.clear();
     m_vertex.clear();
   }
   // Keep track of the nested begin/end calls.
@@ -456,23 +458,10 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
         cursorX += ch->advance;
     }
     if (hardwareClipping)
-      /* Append the new vertices (which we have just constructed in the cache)
-       * to the set collected since the first Begin() call */
-      m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices));
   }
   else if (hardwareClipping)
-  {
-    /* Apply the translation offset to the vertices from the cache after
-     * appending them to the set collected since the first Begin() call */
-    m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
-    SVertex *v;
-    for (v = &*m_vertex.end() - vertices.size(); v != &*m_vertex.end(); v++)
-    {
-      v->x += dynamicPos.m_x;
-      v->y += dynamicPos.m_y;
-      v->z += dynamicPos.m_z;
-    }
-  }
+    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices));
   if (!hardwareClipping)
     /* Append the new vertices (from the cache or otherwise) to the set collected
      * since the first Begin() call */
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 39bfa52..e8afc1c 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -61,6 +61,14 @@ struct SVertex
   unsigned char r, g, b, a;
 #endif
   float u, v;
+  struct SVertex Offset(float translate[3]) const
+  {
+    SVertex out = *this;
+    out.x += translate[0];
+    out.y += translate[1];
+    out.z += translate[2];
+    return out;
+  }
 };
 
 
@@ -159,6 +167,15 @@ class CGUIFontTTFBase
 
   unsigned int m_nTexture;
 
+  struct CTranslatedVertices
+  {
+    float translateX;
+    float translateY;
+    float translateZ;
+    const std::vector<SVertex> *vertexBuffer;
+    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer) {}
+  };
+  std::vector<CTranslatedVertices> m_vertexTrans;
   std::vector<SVertex> m_vertex;
 
   float    m_textureScaleX;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 9935ea4..18c9358 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -167,34 +167,65 @@ void CGUIFontTTFGL::LastEnd()
   GLint colLoc  = g_Windowing.GUIShaderGetCol();
   GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
 
-  // stack object until VBOs will be used
-  std::vector<SVertex> vecVertices( 6 * (m_vertex.size() / 4) );
-  SVertex *vertices = &vecVertices[0];
+  // Enable the attributes used by this shader
+  glEnableVertexAttribArray(posLoc);
+  glEnableVertexAttribArray(colLoc);
+  glEnableVertexAttribArray(tex0Loc);
 
-  for (size_t i=0; i<m_vertex.size(); i+=4)
+  if (m_vertex.size() > 0)
   {
-    *vertices++ = m_vertex[i];
-    *vertices++ = m_vertex[i+1];
-    *vertices++ = m_vertex[i+2];
+    // Deal with vertices that had to use software clipping
+    std::vector<SVertex> vecVertices( 6 * (m_vertex.size() / 4) );
+    SVertex *vertices = &vecVertices[0];
 
-    *vertices++ = m_vertex[i+1];
-    *vertices++ = m_vertex[i+3];
-    *vertices++ = m_vertex[i+2];
-  }
+    for (size_t i=0; i<m_vertex.size(); i+=4)
+    {
+      *vertices++ = m_vertex[i];
+      *vertices++ = m_vertex[i+1];
+      *vertices++ = m_vertex[i+2];
 
-  vertices = &vecVertices[0];
+      *vertices++ = m_vertex[i+1];
+      *vertices++ = m_vertex[i+3];
+      *vertices++ = m_vertex[i+2];
+    }
 
-  glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
-  // Normalize color values. Does not affect Performance at all.
-  glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
-  glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+    vertices = &vecVertices[0];
 
-  glEnableVertexAttribArray(posLoc);
-  glEnableVertexAttribArray(colLoc);
-  glEnableVertexAttribArray(tex0Loc);
+    glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
+    // Normalize color values. Does not affect Performance at all.
+    glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
+    glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+
+    glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+  }
+  if (m_vertexTrans.size() > 0)
+  {
+    // Deal with the vertices that can be hardware clipped and therefore translated
+    std::vector<SVertex> vecVertices;
+    for (size_t i = 0; i < m_vertexTrans.size(); i++)
+    {
+      float translate[3] = { m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ };
+      for (size_t j = 0; j < m_vertexTrans[i].vertexBuffer->size(); j += 4)
+      {
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
+      }
+    }
+    SVertex *vertices = &vecVertices[0];
 
-  glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+    glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
+    // Normalize color values. Does not affect Performance at all.
+    glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
+    glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+
+    glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+  }
 
+  // Disable the attributes used by this shader
   glDisableVertexAttribArray(posLoc);
   glDisableVertexAttribArray(colLoc);
   glDisableVertexAttribArray(tex0Loc);
@@ -222,6 +253,7 @@ CBaseTexture* CGUIFontTTFGL::ReallocTexture(unsigned int& newHeight)
   if (m_textureHeight < newHeight)
     CLog::Log(LOGWARNING, "%s: allocated new texture with height of %d, requested %d", __FUNCTION__, m_textureHeight, newHeight);
   m_staticCache.Flush();
+  m_dynamicCache.Flush();
 
   memset(newTexture->GetPixels(), 0, m_textureHeight * newTexture->GetPitch());
   if (m_texture)

From e0abdac7367737366a3d1054a2cef8568f6cd6ad Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 15:28:06 +0000
Subject: [PATCH 26/77] Rather than applying the translation offsets to the
 vertices, now applies them to the model view matrix from the top of the
 matrix stack and pushes it over to OpenGL. The vertices themselves are still
 all held client-side.

---
 xbmc/guilib/GUIFontTTF.h                 |  8 -------
 xbmc/guilib/GUIFontTTFGL.cpp             | 40 +++++++++++++++++++++-----------
 xbmc/guilib/GUIShader.h                  |  1 +
 xbmc/rendering/gles/RenderSystemGLES.cpp |  8 +++++++
 xbmc/rendering/gles/RenderSystemGLES.h   |  1 +
 5 files changed, 36 insertions(+), 22 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index e8afc1c..573039d 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -61,14 +61,6 @@ struct SVertex
   unsigned char r, g, b, a;
 #endif
   float u, v;
-  struct SVertex Offset(float translate[3]) const
-  {
-    SVertex out = *this;
-    out.x += translate[0];
-    out.y += translate[1];
-    out.z += translate[2];
-    return out;
-  }
 };
 
 
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 18c9358..ea08bf4 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -29,6 +29,7 @@
 #include "utils/log.h"
 #include "utils/GLUtils.h"
 #include "windowing/WindowingFactory.h"
+#include "guilib/MatrixGLES.h"
 
 // stuff for freetype
 #include <ft2build.h>
@@ -166,6 +167,7 @@ void CGUIFontTTFGL::LastEnd()
   GLint posLoc  = g_Windowing.GUIShaderGetPos();
   GLint colLoc  = g_Windowing.GUIShaderGetCol();
   GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
+  GLint modelLoc = g_Windowing.GUIShaderGetModel();
 
   // Enable the attributes used by this shader
   glEnableVertexAttribArray(posLoc);
@@ -204,25 +206,35 @@ void CGUIFontTTFGL::LastEnd()
     std::vector<SVertex> vecVertices;
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
-      float translate[3] = { m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ };
+      // Apply the translation to the currently active (top-of-stack) model view matrix
+      g_matrices.MatrixMode(MM_MODELVIEW);
+      g_matrices.PushMatrix();
+      g_matrices.Translatef(m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ);
+      glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
+
+      vecVertices.clear();
       for (size_t j = 0; j < m_vertexTrans[i].vertexBuffer->size(); j += 4)
       {
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
       }
-    }
-    SVertex *vertices = &vecVertices[0];
+      SVertex *vertices = &vecVertices[0];
 
-    glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
-    // Normalize color values. Does not affect Performance at all.
-    glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
-    glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
+      // Normalize color values. Does not affect Performance at all.
+      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
+      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
 
-    glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+      glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+
+      g_matrices.PopMatrix();
+    }
+    // Restore the original model view matrix
+    glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
   }
 
   // Disable the attributes used by this shader
diff --git a/xbmc/guilib/GUIShader.h b/xbmc/guilib/GUIShader.h
index fdf7452..abbe21c 100644
--- a/xbmc/guilib/GUIShader.h
+++ b/xbmc/guilib/GUIShader.h
@@ -39,6 +39,7 @@ class CGUIShader : public Shaders::CGLSLShaderProgram
   GLint GetCord1Loc() { return m_hCord1; }
   GLint GetUniColLoc() { return m_hUniCol; }
   GLint GetCoord0MatrixLoc() { return m_hCoord0Matrix; }
+  GLint GetModelLoc() { return m_hModel; }
   bool HardwareClipIsPossible() { return m_clipPossible; }
   GLfloat GetClipXFactor() { return m_clipXFactor; }
   GLfloat GetClipXOffset() { return m_clipXOffset; }
diff --git a/xbmc/rendering/gles/RenderSystemGLES.cpp b/xbmc/rendering/gles/RenderSystemGLES.cpp
index deb3afc..0904d1f 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.cpp
+++ b/xbmc/rendering/gles/RenderSystemGLES.cpp
@@ -691,4 +691,12 @@ bool CRenderSystemGLES::SupportsStereo(RENDER_STEREO_MODE mode)
   }
 }
 
+GLint CRenderSystemGLES::GUIShaderGetModel()
+{
+  if (m_pGUIshader[m_method])
+    return m_pGUIshader[m_method]->GetModelLoc();
+
+  return -1;
+}
+
 #endif
diff --git a/xbmc/rendering/gles/RenderSystemGLES.h b/xbmc/rendering/gles/RenderSystemGLES.h
index 81ee49e..d2f9cd1 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.h
+++ b/xbmc/rendering/gles/RenderSystemGLES.h
@@ -91,6 +91,7 @@ class CRenderSystemGLES : public CRenderSystemBase
   GLint GUIShaderGetCoord1();
   GLint GUIShaderGetUniCol();
   GLint GUIShaderGetCoord0Matrix();
+  GLint GUIShaderGetModel();
 
 protected:
   virtual void SetVSyncImpl(bool enable) = 0;

From 54e3057566feeaea70e61b7d5173857a37cfad23 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 29 Jan 2014 13:21:19 +0000
Subject: [PATCH 27/77] Enable hardware clipping.

---
 xbmc/guilib/GUIFontTTF.cpp   | 4 ++--
 xbmc/guilib/GUIFontTTF.h     | 5 ++++-
 xbmc/guilib/GUIFontTTFGL.cpp | 6 ++++++
 3 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index b0e69c0..3ea1051 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -458,10 +458,10 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
         cursorX += ch->advance;
     }
     if (hardwareClipping)
-      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices));
+      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices, g_graphicsContext.GetClipRegion()));
   }
   else if (hardwareClipping)
-    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices));
+    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices, g_graphicsContext.GetClipRegion()));
   if (!hardwareClipping)
     /* Append the new vertices (from the cache or otherwise) to the set collected
      * since the first Begin() call */
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 573039d..a6931c1 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -27,6 +27,8 @@
  *
  */
 
+#include "Geometry.h"
+
 // forward definition
 class CBaseTexture;
 
@@ -165,7 +167,8 @@ class CGUIFontTTFBase
     float translateY;
     float translateZ;
     const std::vector<SVertex> *vertexBuffer;
-    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer) {}
+    CRect clip;
+    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer, const CRect &clip) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer), clip(clip) {}
   };
   std::vector<CTranslatedVertices> m_vertexTrans;
   std::vector<SVertex> m_vertex;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index ea08bf4..b63e337 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -206,6 +206,10 @@ void CGUIFontTTFGL::LastEnd()
     std::vector<SVertex> vecVertices;
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
+      // Apply the clip rectangle
+      CRect clip = g_Windowing.ClipRectToScissorRect(m_vertexTrans[i].clip);
+      g_Windowing.SetScissors(clip);
+
       // Apply the translation to the currently active (top-of-stack) model view matrix
       g_matrices.MatrixMode(MM_MODELVIEW);
       g_matrices.PushMatrix();
@@ -233,6 +237,8 @@ void CGUIFontTTFGL::LastEnd()
 
       g_matrices.PopMatrix();
     }
+    // Restore the original scissor rectangle
+    g_Windowing.ResetScissors();
     // Restore the original model view matrix
     glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
   }

From 73c558a08f0441236fb44e408c4ad507d27e056a Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 15:32:51 +0000
Subject: [PATCH 28/77] Move the vertex data across to a vertex buffer object
 just prior to drawing.

---
 xbmc/guilib/GUIFontTTFGL.cpp | 24 +++++++++++++++++++-----
 1 file changed, 19 insertions(+), 5 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index b63e337..b00055d 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -228,12 +228,24 @@ void CGUIFontTTFGL::LastEnd()
       }
       SVertex *vertices = &vecVertices[0];
 
-      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
-      // Normalize color values. Does not affect Performance at all.
-      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
-      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
-
+      // Generate a unique buffer object name and put it in vertexBuffer
+      GLuint vertexBuffer;
+      glGenBuffers(1, &vertexBuffer);
+      // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
+      glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
+      // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
+      // binding point (i.e. our buffer object) and initialise it from the
+      // specified client-side pointer
+      glBufferData(GL_ARRAY_BUFFER, vecVertices.size() * sizeof *vertices, vertices, GL_STATIC_DRAW);
+      // Set up the offsets of the various vertex attributes within the buffer
+      // object bound to GL_ARRAY_BUFFER
+      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, x));
+      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) offsetof(SVertex, r));
+      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, u));
+      // Do the actual drawing operation, using the full set of vertices in the buffer
       glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+      // Release the buffer name for reuse
+      glDeleteBuffers(1, &vertexBuffer);
 
       g_matrices.PopMatrix();
     }
@@ -241,6 +253,8 @@ void CGUIFontTTFGL::LastEnd()
     g_Windowing.ResetScissors();
     // Restore the original model view matrix
     glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
+    // Unbind GL_ARRAY_BUFFER
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
   }
 
   // Disable the attributes used by this shader

From 1bdbf7a657217a2974e830f711a84d843f9f574f Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 16:04:04 +0000
Subject: [PATCH 29/77] Move vertex data into an OpenGL VBO when the font cache
 entry is populated.

The font cache now stores the "name" (handle) of the VBO, rather than a vector
of vertices.
---
 xbmc/guilib/GUIFontCache.cpp |  6 ++++
 xbmc/guilib/GUIFontCache.h   | 30 +++++++++++++++++-
 xbmc/guilib/GUIFontTTF.cpp   | 15 +++++++--
 xbmc/guilib/GUIFontTTF.h     |  7 +++--
 xbmc/guilib/GUIFontTTFGL.cpp | 74 ++++++++++++++++++++++++++++++--------------
 xbmc/guilib/GUIFontTTFGL.h   |  5 +++
 6 files changed, 107 insertions(+), 30 deletions(-)

diff --git a/xbmc/guilib/GUIFontCache.cpp b/xbmc/guilib/GUIFontCache.cpp
index df466a5..bd84b9a 100644
--- a/xbmc/guilib/GUIFontCache.cpp
+++ b/xbmc/guilib/GUIFontCache.cpp
@@ -111,3 +111,9 @@ template void CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDyna
 template CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::~CGUIFontCacheEntry();
 template CGUIFontCacheDynamicValue &CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Lookup(CGUIFontCacheDynamicPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
 template void CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Flush();
+
+void CVertexBuffer::clear()
+{
+  if (m_font != NULL)
+    m_font->DestroyVertexBuffer(*this);
+}
diff --git a/xbmc/guilib/GUIFontCache.h b/xbmc/guilib/GUIFontCache.h
index d913dee..ff766bf 100644
--- a/xbmc/guilib/GUIFontCache.h
+++ b/xbmc/guilib/GUIFontCache.h
@@ -234,7 +234,35 @@ struct CGUIFontCacheDynamicPosition
   }
 };
 
-typedef std::vector<SVertex> CGUIFontCacheDynamicValue;
+struct CVertexBuffer
+{
+  void *bufferHandle;
+  size_t size;
+  CVertexBuffer() : bufferHandle(NULL), size(0), m_font(NULL) {}
+  CVertexBuffer(void *bufferHandle, size_t size, const CGUIFontTTFBase *font) : bufferHandle(bufferHandle), size(size), m_font(font) {}
+  CVertexBuffer(const CVertexBuffer &other) : bufferHandle(other.bufferHandle), size(other.size), m_font(other.m_font)
+  {
+    /* In practice, the copy constructor is only called before a vertex buffer
+     * has been attached. If this should ever change, we'll need another support
+     * function in GUIFontTTFGL/DX to duplicate a buffer, given its handle. */
+    assert(other.bufferHandle == 0);
+  }
+  CVertexBuffer &operator=(CVertexBuffer &other)
+  {
+    /* This is used with move-assignment semantics for initialising the object in the font cache */
+    assert(bufferHandle == 0);
+    bufferHandle = other.bufferHandle;
+    other.bufferHandle = 0;
+    size = other.size;
+    m_font = other.m_font;
+    return *this;
+  }
+  void clear();
+private:
+  const CGUIFontTTFBase *m_font;
+};
+
+typedef CVertexBuffer CGUIFontCacheDynamicValue;
 
 inline bool Match(const CGUIFontCacheDynamicPosition &a, const TransformMatrix &a_m,
                   const CGUIFontCacheDynamicPosition &b, const TransformMatrix &b_m,
diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 3ea1051..ea510f4 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -342,13 +342,18 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
                                               g_graphicsContext.ScaleFinalYCoord(x, y),
                                               g_graphicsContext.ScaleFinalZCoord(x, y));
   }
-  std::vector<SVertex> &vertices = hardwareClipping ?
+  CVertexBuffer unusedVertexBuffer;
+  CVertexBuffer &vertexBuffer = hardwareClipping ?
       m_dynamicCache.Lookup(dynamicPos,
                             colors, text,
                             alignment, maxPixelWidth,
                             scrolling,
                             XbmcThreads::SystemClockMillis(),
                             dirtyCache) :
+      unusedVertexBuffer;
+  std::vector<SVertex> tempVertices;
+  std::vector<SVertex> &vertices = hardwareClipping ?
+      tempVertices :
       m_staticCache.Lookup(staticPos,
                            colors, text,
                            alignment, maxPixelWidth,
@@ -458,10 +463,14 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
         cursorX += ch->advance;
     }
     if (hardwareClipping)
-      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices, g_graphicsContext.GetClipRegion()));
+    {
+      CVertexBuffer newVertexBuffer = CreateVertexBuffer(tempVertices);
+      vertexBuffer = newVertexBuffer;
+      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertexBuffer, g_graphicsContext.GetClipRegion()));
+    }
   }
   else if (hardwareClipping)
-    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices, g_graphicsContext.GetClipRegion()));
+    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertexBuffer, g_graphicsContext.GetClipRegion()));
   if (!hardwareClipping)
     /* Append the new vertices (from the cache or otherwise) to the set collected
      * since the first Begin() call */
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index a6931c1..9a35ac4 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -84,6 +84,9 @@ class CGUIFontTTFBase
 
   void Begin();
   void End();
+  /* The next two should only be called if we've declared we can do hardware clipping */
+  virtual CVertexBuffer CreateVertexBuffer(const std::vector<SVertex> &vertices) const { assert(false); return CVertexBuffer(); }
+  virtual void DestroyVertexBuffer(CVertexBuffer &bufferHandle) const {}
 
   const CStdString& GetFileName() const { return m_strFileName; };
 
@@ -166,9 +169,9 @@ class CGUIFontTTFBase
     float translateX;
     float translateY;
     float translateZ;
-    const std::vector<SVertex> *vertexBuffer;
+    const CVertexBuffer *vertexBuffer;
     CRect clip;
-    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer, const CRect &clip) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer), clip(clip) {}
+    CTranslatedVertices(float translateX, float translateY, float translateZ, const CVertexBuffer *vertexBuffer, const CRect &clip) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer), clip(clip) {}
   };
   std::vector<CTranslatedVertices> m_vertexTrans;
   std::vector<SVertex> m_vertex;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index b00055d..aabb9a6 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -52,6 +52,10 @@ CGUIFontTTFGL::CGUIFontTTFGL(const CStdString& strFileName)
 
 CGUIFontTTFGL::~CGUIFontTTFGL(void)
 {
+  // It's important that all the CGUIFontCacheEntry objects are
+  // destructed before the CGUIFontTTFGL goes out of scope, because
+  // our virtual methods won't be accessible after this point
+  m_dynamicCache.Flush();
 }
 
 bool CGUIFontTTFGL::FirstBegin()
@@ -203,7 +207,6 @@ void CGUIFontTTFGL::LastEnd()
   if (m_vertexTrans.size() > 0)
   {
     // Deal with the vertices that can be hardware clipped and therefore translated
-    std::vector<SVertex> vecVertices;
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
       // Apply the clip rectangle
@@ -216,36 +219,17 @@ void CGUIFontTTFGL::LastEnd()
       g_matrices.Translatef(m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ);
       glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
 
-      vecVertices.clear();
-      for (size_t j = 0; j < m_vertexTrans[i].vertexBuffer->size(); j += 4)
-      {
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
-      }
-      SVertex *vertices = &vecVertices[0];
-
-      // Generate a unique buffer object name and put it in vertexBuffer
-      GLuint vertexBuffer;
-      glGenBuffers(1, &vertexBuffer);
       // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
-      glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
-      // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
-      // binding point (i.e. our buffer object) and initialise it from the
-      // specified client-side pointer
-      glBufferData(GL_ARRAY_BUFFER, vecVertices.size() * sizeof *vertices, vertices, GL_STATIC_DRAW);
+      glBindBuffer(GL_ARRAY_BUFFER, (GLuint) m_vertexTrans[i].vertexBuffer->bufferHandle);
+
       // Set up the offsets of the various vertex attributes within the buffer
       // object bound to GL_ARRAY_BUFFER
       glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, x));
       glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) offsetof(SVertex, r));
       glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, u));
+
       // Do the actual drawing operation, using the full set of vertices in the buffer
-      glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
-      // Release the buffer name for reuse
-      glDeleteBuffers(1, &vertexBuffer);
+      glDrawArrays(GL_TRIANGLES, 0, 6 * m_vertexTrans[i].vertexBuffer->size);
 
       g_matrices.PopMatrix();
     }
@@ -266,6 +250,48 @@ void CGUIFontTTFGL::LastEnd()
 #endif
 }
 
+#if HAS_GLES
+CVertexBuffer CGUIFontTTFGL::CreateVertexBuffer(const std::vector<SVertex> &vertices) const
+{
+  // Rearrange the vertices to describe triangles
+  std::vector<SVertex> triangleVertices;
+  triangleVertices.reserve(vertices.size() * 6 / 4);
+  for (size_t i = 0; i < vertices.size(); i += 4)
+  {
+    triangleVertices.push_back(vertices[i]);
+    triangleVertices.push_back(vertices[i+1]);
+    triangleVertices.push_back(vertices[i+2]);
+    triangleVertices.push_back(vertices[i+1]);
+    triangleVertices.push_back(vertices[i+3]);
+    triangleVertices.push_back(vertices[i+2]);
+  }
+
+  // Generate a unique buffer object name and put it in bufferHandle
+  GLuint bufferHandle;
+  glGenBuffers(1, &bufferHandle);
+  // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
+  glBindBuffer(GL_ARRAY_BUFFER, bufferHandle);
+  // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
+  // binding point (i.e. our buffer object) and initialise it from the
+  // specified client-side pointer
+  glBufferData(GL_ARRAY_BUFFER, triangleVertices.size() * sizeof (SVertex), &triangleVertices[0], GL_STATIC_DRAW);
+  // Unbind GL_ARRAY_BUFFER
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+
+  return CVertexBuffer((void *) bufferHandle, vertices.size() / 4, this);
+}
+
+void CGUIFontTTFGL::DestroyVertexBuffer(CVertexBuffer &buffer) const
+{
+  if (buffer.bufferHandle != 0)
+  {
+    // Release the buffer name for reuse
+    glDeleteBuffers(1, (GLuint *) &buffer.bufferHandle);
+    buffer.bufferHandle = 0;
+  }
+}
+#endif
+
 CBaseTexture* CGUIFontTTFGL::ReallocTexture(unsigned int& newHeight)
 {
   newHeight = CBaseTexture::PadPow2(newHeight);
diff --git a/xbmc/guilib/GUIFontTTFGL.h b/xbmc/guilib/GUIFontTTFGL.h
index 735fb3a..6102c90 100644
--- a/xbmc/guilib/GUIFontTTFGL.h
+++ b/xbmc/guilib/GUIFontTTFGL.h
@@ -29,6 +29,7 @@
 
 
 #include "GUIFontTTF.h"
+#include "system.h"
 
 
 /*!
@@ -43,6 +44,10 @@ class CGUIFontTTFGL : public CGUIFontTTFBase
 
   virtual bool FirstBegin();
   virtual void LastEnd();
+#if HAS_GLES
+  virtual CVertexBuffer CreateVertexBuffer(const std::vector<SVertex> &vertices) const;
+  virtual void DestroyVertexBuffer(CVertexBuffer &bufferHandle) const;
+#endif
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);

From 774a3446b96a8c39b7a98a5e0663564893d50965 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 16 Jan 2014 16:29:42 +0000
Subject: [PATCH 30/77] Switch from glDrawArrays() to glDrawElements().

This involves setting up a static VBO containing the indexes necessary to
convert from quads to triangles on the fly in the GPU.
---
 xbmc/guilib/GUIFontTTFGL.cpp        | 72 +++++++++++++++++++++++++------------
 xbmc/guilib/GUIFontTTFGL.h          | 11 +++++-
 xbmc/windowing/egl/WinSystemEGL.cpp | 17 +++++++++
 3 files changed, 77 insertions(+), 23 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index aabb9a6..812662c 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -207,6 +207,10 @@ void CGUIFontTTFGL::LastEnd()
   if (m_vertexTrans.size() > 0)
   {
     // Deal with the vertices that can be hardware clipped and therefore translated
+
+    // Bind our pre-calculated array to GL_ELEMENT_ARRAY_BUFFER
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_elementArrayHandle);
+
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
       // Apply the clip rectangle
@@ -222,14 +226,21 @@ void CGUIFontTTFGL::LastEnd()
       // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
       glBindBuffer(GL_ARRAY_BUFFER, (GLuint) m_vertexTrans[i].vertexBuffer->bufferHandle);
 
-      // Set up the offsets of the various vertex attributes within the buffer
-      // object bound to GL_ARRAY_BUFFER
-      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, x));
-      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) offsetof(SVertex, r));
-      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, u));
+      // Do the actual drawing operation, split into groups of characters no
+      // larger than the pre-determined size of the element array
+      for (size_t character = 0; m_vertexTrans[i].vertexBuffer->size > character; character += ELEMENT_ARRAY_MAX_CHAR_INDEX)
+      {
+        size_t count = m_vertexTrans[i].vertexBuffer->size - character;
+        count = std::min<size_t>(count, ELEMENT_ARRAY_MAX_CHAR_INDEX);
+
+        // Set up the offsets of the various vertex attributes within the buffer
+        // object bound to GL_ARRAY_BUFFER
+        glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) (character*sizeof(SVertex)*4 + offsetof(SVertex, x)));
+        glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) (character*sizeof(SVertex)*4 + offsetof(SVertex, r)));
+        glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) (character*sizeof(SVertex)*4 + offsetof(SVertex, u)));
 
-      // Do the actual drawing operation, using the full set of vertices in the buffer
-      glDrawArrays(GL_TRIANGLES, 0, 6 * m_vertexTrans[i].vertexBuffer->size);
+        glDrawElements(GL_TRIANGLES, 6 * count, GL_UNSIGNED_SHORT, 0);
+      }
 
       g_matrices.PopMatrix();
     }
@@ -237,8 +248,9 @@ void CGUIFontTTFGL::LastEnd()
     g_Windowing.ResetScissors();
     // Restore the original model view matrix
     glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
-    // Unbind GL_ARRAY_BUFFER
+    // Unbind GL_ARRAY_BUFFER and GL_ELEMENT_ARRAY_BUFFER
     glBindBuffer(GL_ARRAY_BUFFER, 0);
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
   }
 
   // Disable the attributes used by this shader
@@ -253,19 +265,6 @@ void CGUIFontTTFGL::LastEnd()
 #if HAS_GLES
 CVertexBuffer CGUIFontTTFGL::CreateVertexBuffer(const std::vector<SVertex> &vertices) const
 {
-  // Rearrange the vertices to describe triangles
-  std::vector<SVertex> triangleVertices;
-  triangleVertices.reserve(vertices.size() * 6 / 4);
-  for (size_t i = 0; i < vertices.size(); i += 4)
-  {
-    triangleVertices.push_back(vertices[i]);
-    triangleVertices.push_back(vertices[i+1]);
-    triangleVertices.push_back(vertices[i+2]);
-    triangleVertices.push_back(vertices[i+1]);
-    triangleVertices.push_back(vertices[i+3]);
-    triangleVertices.push_back(vertices[i+2]);
-  }
-
   // Generate a unique buffer object name and put it in bufferHandle
   GLuint bufferHandle;
   glGenBuffers(1, &bufferHandle);
@@ -274,7 +273,7 @@ CVertexBuffer CGUIFontTTFGL::CreateVertexBuffer(const std::vector<SVertex> &vert
   // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
   // binding point (i.e. our buffer object) and initialise it from the
   // specified client-side pointer
-  glBufferData(GL_ARRAY_BUFFER, triangleVertices.size() * sizeof (SVertex), &triangleVertices[0], GL_STATIC_DRAW);
+  glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof (SVertex), &vertices[0], GL_STATIC_DRAW);
   // Unbind GL_ARRAY_BUFFER
   glBindBuffer(GL_ARRAY_BUFFER, 0);
 
@@ -393,4 +392,33 @@ void CGUIFontTTFGL::DeleteHardwareTexture()
   }
 }
 
+#if HAS_GLES
+void CGUIFontTTFGL::CreateStaticVertexBuffers(void)
+{
+  // Bind a new buffer to the OpenGL context's GL_ELEMENT_ARRAY_BUFFER binding point
+  glGenBuffers(1, &m_elementArrayHandle);
+  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_elementArrayHandle);
+  // Create an array holding the mesh indices to convert quads to triangles
+  GLushort index[ELEMENT_ARRAY_MAX_CHAR_INDEX][6];
+  for (size_t i = 0; i < ELEMENT_ARRAY_MAX_CHAR_INDEX; i++)
+  {
+    index[i][0] = 4*i;
+    index[i][1] = 4*i+1;
+    index[i][2] = 4*i+2;
+    index[i][3] = 4*i+1;
+    index[i][4] = 4*i+3;
+    index[i][5] = 4*i+2;
+  }
+  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof index, index, GL_STATIC_DRAW);
+  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+}
+
+void CGUIFontTTFGL::DestroyStaticVertexBuffers(void)
+{
+  glDeleteBuffers(1, &m_elementArrayHandle);
+}
+
+GLuint CGUIFontTTFGL::m_elementArrayHandle;
+#endif
+
 #endif
diff --git a/xbmc/guilib/GUIFontTTFGL.h b/xbmc/guilib/GUIFontTTFGL.h
index 6102c90..dcf9ca1 100644
--- a/xbmc/guilib/GUIFontTTFGL.h
+++ b/xbmc/guilib/GUIFontTTFGL.h
@@ -30,6 +30,7 @@
 
 #include "GUIFontTTF.h"
 #include "system.h"
+#include "system_gl.h"
 
 
 /*!
@@ -47,13 +48,21 @@ class CGUIFontTTFGL : public CGUIFontTTFBase
 #if HAS_GLES
   virtual CVertexBuffer CreateVertexBuffer(const std::vector<SVertex> &vertices) const;
   virtual void DestroyVertexBuffer(CVertexBuffer &bufferHandle) const;
+  static void CreateStaticVertexBuffers(void);
+  static void DestroyStaticVertexBuffers(void);
 #endif
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);
   virtual bool CopyCharToTexture(FT_BitmapGlyph bitGlyph, unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2);
   virtual void DeleteHardwareTexture();
-    
+
+#if HAS_GLES
+#define ELEMENT_ARRAY_MAX_CHAR_INDEX (1000)
+
+  static GLuint m_elementArrayHandle;
+#endif
+
 private:
   unsigned int m_updateY1;
   unsigned int m_updateY2;
diff --git a/xbmc/windowing/egl/WinSystemEGL.cpp b/xbmc/windowing/egl/WinSystemEGL.cpp
index 6de3532..258a293 100644
--- a/xbmc/windowing/egl/WinSystemEGL.cpp
+++ b/xbmc/windowing/egl/WinSystemEGL.cpp
@@ -29,6 +29,7 @@
 #include "settings/AdvancedSettings.h"
 #include "settings/Settings.h"
 #include "settings/DisplaySettings.h"
+#include "guilib/GUIFontTTFGL.h"
 #include "utils/log.h"
 #include "EGLWrapper.h"
 #include "EGLQuirks.h"
@@ -193,6 +194,9 @@ bool CWinSystemEGL::CreateWindow(RESOLUTION_INFO &res)
     return false;
   }
 
+#if HAS_GLES
+  bool newContext = false;
+#endif
   if (m_context == EGL_NO_CONTEXT)
   {
     if (!m_egl->CreateContext(m_display, m_config, contextAttrs, &m_context))
@@ -200,6 +204,9 @@ bool CWinSystemEGL::CreateWindow(RESOLUTION_INFO &res)
       CLog::Log(LOGERROR, "%s: Could not create context",__FUNCTION__);
       return false;
     }
+#if HAS_GLES
+    newContext = true;
+#endif
   }
 
   if (!m_egl->BindContext(m_display, m_surface, m_context))
@@ -208,6 +215,11 @@ bool CWinSystemEGL::CreateWindow(RESOLUTION_INFO &res)
     return false;
   }
 
+#if HAS_GLES
+  if (newContext)
+    CGUIFontTTFGL::CreateStaticVertexBuffers();
+#endif
+
   // for the non-trivial dirty region modes, we need the EGL buffer to be preserved across updates
   if (g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION ||
       g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION)
@@ -229,7 +241,12 @@ bool CWinSystemEGL::DestroyWindowSystem()
   DestroyWindow();
 
   if (m_context != EGL_NO_CONTEXT)
+  {
+#if HAS_GLES
+    CGUIFontTTFGL::DestroyStaticVertexBuffers();
+#endif
     m_egl->DestroyContext(m_display, m_context);
+  }
   m_context = EGL_NO_CONTEXT;
 
   if (m_display != EGL_NO_DISPLAY)

From 09468bf68f2b5047849b0731d46bb5528cee6d4d Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 1 May 2014 16:28:39 +0100
Subject: [PATCH 31/77] Improved file buffering in CArchive

Even though memcpy is typically inlined by the compiler into byte/word loads
and stores (at least for release builds), the frequency with which 1, 2 and 4
byte loads/stores are encountered in cases where the size is *not*
determinable at compile time is still high enough that it's worth handling
these specially. On the ARM1176JZF-S in the Raspberry Pi, this improves the
total time to open a library (in the case where it's fetched from a CArchive)
by around 4%.

It should be noted that this code uses 16-bit and 32-bit word loads and
stores that are not necessarily aligned to their respective widths. It is
possible that there are some architectures out there which do not support
this, although all ARMs since ARMv6 have supported it (and ARMs earlier than
that are probably not powerful enough to be good targets for XBMC).
---
 xbmc/utils/Archive.h | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/xbmc/utils/Archive.h b/xbmc/utils/Archive.h
index 6ed0f8f..8506d95 100644
--- a/xbmc/utils/Archive.h
+++ b/xbmc/utils/Archive.h
@@ -154,9 +154,17 @@ class CArchive
      * than waiting until we attempt to put more data into an already full buffer */
     if (m_BufferRemain > size)
     {
+      switch (size)
+      {
+      case 1: *m_BufferPos++ = *ptr; m_BufferRemain--; break;
+      case 2: *(uint16_t *) m_BufferPos = *(const uint16_t *) ptr; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) m_BufferPos = *(const uint32_t *) ptr; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(m_BufferPos, ptr, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
     else
@@ -171,9 +179,17 @@ class CArchive
     /* Note, refilling the buffer is deferred until we know we need to read more from it */
     if (m_BufferRemain >= size)
     {
+      switch (size)
+      {
+      case 1: *ptr = *m_BufferPos++; m_BufferRemain--; break;
+      case 2: *(uint16_t *) ptr = *(const uint16_t *) m_BufferPos; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) ptr = *(const uint32_t *) m_BufferPos; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(ptr, m_BufferPos, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
     else

From 6ce2c7d35b7ca4355b7cd687ecbc29238d28808c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 9 Jul 2014 01:14:23 +0100
Subject: [PATCH 32/77] [omxcodec] Switch to MMAL decoder with MMAL renderer

---
 configure.in                                       |   23 +-
 language/English/strings.po                        |    2 +-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp    |   78 -
 xbmc/cores/VideoRenderers/LinuxRendererGLES.h      |    8 +-
 xbmc/cores/VideoRenderers/Makefile.in              |    1 +
 xbmc/cores/VideoRenderers/OMXRenderer.cpp          |  784 +++++++++
 xbmc/cores/VideoRenderers/OMXRenderer.h            |  129 ++
 xbmc/cores/VideoRenderers/RenderManager.cpp        |    6 +-
 xbmc/cores/VideoRenderers/RenderManager.h          |    3 +
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp |    9 +-
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |    7 +-
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.cpp       |  301 +---
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.h         |   38 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in   |    1 -
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp     | 1727 ++++++++++----------
 .../cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |  165 +-
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |    2 +-
 17 files changed, 1975 insertions(+), 1309 deletions(-)
 create mode 100644 xbmc/cores/VideoRenderers/OMXRenderer.cpp
 create mode 100644 xbmc/cores/VideoRenderers/OMXRenderer.h

diff --git a/configure.in b/configure.in
index fcb7b62..c0ea777 100644
--- a/configure.in
+++ b/configure.in
@@ -1003,7 +1003,7 @@ if test "$use_gles" = "yes"; then
       AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
       AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
       AC_MSG_RESULT(== WARNING: OpenGLES support is assumed.)
-      LIBS="$LIBS -lEGL -lGLESv2 -lbcm_host -lvcos -lvchiq_arm"
+      LIBS="$LIBS -lEGL -lGLESv2 -lbcm_host -lvcos -lvchiq_arm -lvchiq_arm -lmmal -lmmal_core -lmmal_util"
     else
       AC_CHECK_LIB([EGL],   [main],, AC_MSG_ERROR($missing_library))
       AC_CHECK_LIB([GLESv2],[main],, AC_MSG_ERROR($missing_library))
@@ -1865,9 +1865,24 @@ if test "$host_vendor" = "apple" ; then
   USE_OPENMAX=0
   AC_MSG_NOTICE($openmax_disabled)
 elif test "$target_platform" = "target_raspberry_pi"; then
-  use_openmax="no"
-  USE_OPENMAX=0
-  AC_MSG_NOTICE($openmax_disabled)
+  if test "$use_gles" = "yes" && test "$use_openmax" = "auto"; then
+    use_openmax="yes"
+    USE_OPENMAX=1
+    HAVE_LIBOPENMAX=1
+    AC_DEFINE([HAVE_LIBOPENMAX], [1], [Define to 1 if you have the 'LIBOPENMAX' library.])
+    AC_DEFINE([OMX_SKIP64BIT], [1], [Define to 1 if you have the 'LIBOPENMAX' library.])
+    AC_MSG_NOTICE($openmax_enabled)
+  elif test "$use_gles" = "yes" && test "$use_openmax" = "yes"; then
+    use_openmax="yes"
+    USE_OPENMAX=1
+    HAVE_LIBOPENMAX=1
+    AC_DEFINE([HAVE_LIBOPENMAX], [1], [Define to 1 if you have the 'LIBOPENMAX' library.])
+    AC_MSG_NOTICE($openmax_enabled)
+  else
+    AC_MSG_NOTICE($openmax_disabled)
+    use_openmax=no
+    USE_OPENMAX=0
+  fi
 else
   if test "$use_gles" = "yes" && test "$use_openmax" = "auto"; then
     PKG_CHECK_MODULES([OPENMAX], [libomxil-bellagio],
diff --git a/language/English/strings.po b/language/English/strings.po
index fea6e08..ade855e 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -13864,7 +13864,7 @@ msgstr ""
 #. Description of setting "Videos -> Playback -> Allow hardware acceleration (OpenMax)" with label #13430
 #: system/settings/settings.xml
 msgctxt "#36161"
-msgid "Enable OpenMax hardware decoding of video files."
+msgid "Enable OpenMax hardware decoding of video files (using DVDPlayer)."
 msgstr ""
 
 #. Description of setting "Videos -> Playback -> Allow hardware acceleration (VideoToolbox)" with label #13432
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 8db4ea1..d946e03 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -101,9 +101,6 @@ CLinuxRendererGLES::YUVBUFFER::YUVBUFFER()
   memset(&fields, 0, sizeof(fields));
   memset(&image , 0, sizeof(image));
   flipindex = 0;
-#ifdef HAVE_LIBOPENMAX
-  openMaxBuffer = NULL;
-#endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   cvBufferRef = NULL;
 #endif
@@ -616,9 +613,6 @@ unsigned int CLinuxRendererGLES::PreInit()
   m_formats.push_back(RENDER_FMT_YUV420P);
   m_formats.push_back(RENDER_FMT_NV12);
   m_formats.push_back(RENDER_FMT_BYPASS);
-#if defined(HAVE_LIBOPENMAX)
-  m_formats.push_back(RENDER_FMT_OMXEGL);
-#endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   m_formats.push_back(RENDER_FMT_CVBREF);
 #endif
@@ -1369,67 +1363,6 @@ void CLinuxRendererGLES::RenderSoftware(int index, int field)
   VerifyGLState();
 }
 
-void CLinuxRendererGLES::RenderOpenMax(int index, int field)
-{
-#if defined(HAVE_LIBOPENMAX)
-  GLuint textureId = m_buffers[index].openMaxBuffer->texture_id;
-
-  glDisable(GL_DEPTH_TEST);
-
-  // Y
-  glEnable(m_textureTarget);
-  glActiveTexture(GL_TEXTURE0);
-  glBindTexture(m_textureTarget, textureId);
-
-  g_Windowing.EnableGUIShader(SM_TEXTURE_RGBA);
-
-  GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
-  GLfloat ver[4][4];
-  GLfloat tex[4][2];
-  GLfloat col[3] = {1.0f, 1.0f, 1.0f};
-
-  GLint   posLoc = g_Windowing.GUIShaderGetPos();
-  GLint   texLoc = g_Windowing.GUIShaderGetCoord0();
-  GLint   colLoc = g_Windowing.GUIShaderGetCol();
-
-  glVertexAttribPointer(posLoc, 4, GL_FLOAT, 0, 0, ver);
-  glVertexAttribPointer(texLoc, 2, GL_FLOAT, 0, 0, tex);
-  glVertexAttribPointer(colLoc, 3, GL_FLOAT, 0, 0, col);
-
-  glEnableVertexAttribArray(posLoc);
-  glEnableVertexAttribArray(texLoc);
-  glEnableVertexAttribArray(colLoc);
-
-  // Set vertex coordinates
-  for(int i = 0; i < 4; i++)
-  {
-    ver[i][0] = m_rotatedDestCoords[i].x;
-    ver[i][1] = m_rotatedDestCoords[i].y;
-    ver[i][2] = 0.0f;// set z to 0
-    ver[i][3] = 1.0f;
-  }
-
-  // Set texture coordinates
-  tex[0][0] = tex[3][0] = 0;
-  tex[0][1] = tex[1][1] = 0;
-  tex[1][0] = tex[2][0] = 1;
-  tex[2][1] = tex[3][1] = 1;
-
-  glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, idx);
-
-  glDisableVertexAttribArray(posLoc);
-  glDisableVertexAttribArray(texLoc);
-  glDisableVertexAttribArray(colLoc);
-
-  g_Windowing.DisableGUIShader();
-
-  VerifyGLState();
-
-  glDisable(m_textureTarget);
-  VerifyGLState();
-#endif
-}
-
 void CLinuxRendererGLES::RenderEglImage(int index, int field)
 {
 #if defined(HAS_LIBSTAGEFRIGHT)
@@ -1786,11 +1719,7 @@ void CLinuxRendererGLES::UploadYV12Texture(int source)
   YUVFIELDS& fields =  buf.fields;
 
 
-#if defined(HAVE_LIBOPENMAX)
-  if (!(im->flags&IMAGE_FLAG_READY) || m_buffers[source].openMaxBuffer)
-#else
   if (!(im->flags&IMAGE_FLAG_READY))
-#endif
   {
     return;
   }
@@ -2904,13 +2833,6 @@ unsigned int CLinuxRendererGLES::GetProcessorSize()
     return 0;
 }
 
-#ifdef HAVE_LIBOPENMAX
-void CLinuxRendererGLES::AddProcessor(COpenMax* openMax, DVDVideoPicture *picture, int index)
-{
-  YUVBUFFER &buf = m_buffers[index];
-  buf.openMaxBuffer = picture->openMaxBuffer;
-}
-#endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
 void CLinuxRendererGLES::AddProcessor(struct __CVBuffer *cvBufferRef, int index)
 {
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index 1e89ecf..2cc5821 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -39,7 +39,7 @@ class CRenderCapture;
 class CBaseTexture;
 namespace Shaders { class BaseYUV2RGBShader; }
 namespace Shaders { class BaseVideoFilterShader; }
-class COpenMaxVideo;
+class COpenMaxVideoBuffer;
 class CDVDVideoCodecStageFright;
 class CDVDMediaCodecInfo;
 typedef std::vector<int>     Features;
@@ -158,9 +158,6 @@ class CLinuxRendererGLES : public CBaseRenderer
 
   virtual std::vector<ERenderFormat> SupportedFormats() { return m_formats; }
 
-#ifdef HAVE_LIBOPENMAX
-  virtual void         AddProcessor(COpenMax* openMax, DVDVideoPicture *picture, int index);
-#endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   virtual void         AddProcessor(struct __CVBuffer *cvBufferRef, int index);
 #endif
@@ -280,9 +277,6 @@ class CLinuxRendererGLES : public CBaseRenderer
     YV12Image image;
     unsigned  flipindex; /* used to decide if this has been uploaded */
 
-#ifdef HAVE_LIBOPENMAX
-    OpenMaxVideoBuffer *openMaxBuffer;
-#endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
     struct __CVBuffer *cvBufferRef;
 #endif
diff --git a/xbmc/cores/VideoRenderers/Makefile.in b/xbmc/cores/VideoRenderers/Makefile.in
index d964285..5b78852 100644
--- a/xbmc/cores/VideoRenderers/Makefile.in
+++ b/xbmc/cores/VideoRenderers/Makefile.in
@@ -18,6 +18,7 @@ endif
 ifeq (@USE_OPENGLES@,1)
 SRCS += LinuxRendererGLES.cpp
 SRCS += OverlayRendererGL.cpp
+SRCS += OMXRenderer.cpp
 endif
 
 LIB = VideoRenderer.a
diff --git a/xbmc/cores/VideoRenderers/OMXRenderer.cpp b/xbmc/cores/VideoRenderers/OMXRenderer.cpp
new file mode 100644
index 0000000..ceaec7a
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/OMXRenderer.cpp
@@ -0,0 +1,784 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifdef TARGET_RASPBERRY_PI
+
+#include "Util.h"
+#include "OMXRenderer.h"
+#include "cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "filesystem/File.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/DisplaySettings.h"
+#include "settings/MediaSettings.h"
+#include "settings/Settings.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "utils/MathUtils.h"
+#include "windowing/WindowingFactory.h"
+#include "cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h"
+#include "xbmc/Application.h"
+
+#define CLASSNAME "COMXRenderer"
+
+#ifdef _DEBUG
+#define OMX_DEBUG_VERBOSE
+#endif
+
+static void vout_control_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+{
+  mmal_buffer_header_release(buffer);
+}
+
+void COMXRenderer::vout_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+{
+  COpenMaxVideoBuffer *omvb = (COpenMaxVideoBuffer *)buffer->user_data;
+
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s port:%p buffer %p (%p), len %d cmd:%x", CLASSNAME, __func__, port, buffer, omvb, buffer->length, buffer->cmd);
+  #endif
+
+  if (m_format == RENDER_FMT_OMXEGL)
+  {
+    #if defined(HAVE_LIBOPENMAX)
+    mmal_queue_put(m_release_queue, buffer);
+    #endif
+  }
+  else if (m_format == RENDER_FMT_YUV420P)
+  {
+    mmal_buffer_header_release(buffer);
+  }
+  else assert(0);
+}
+
+static void vout_input_port_cb_static(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+{
+  COMXRenderer *omx = reinterpret_cast<COMXRenderer*>(port->userdata);
+  omx->vout_input_port_cb(port, buffer);
+}
+
+bool COMXRenderer::init_vout(MMAL_ES_FORMAT_T *format)
+{
+  MMAL_STATUS_T status;
+  // todo: deinterlace
+
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  /* Create video renderer */
+  status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_RENDERER, &m_vout);
+  if(status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to create vout component (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  m_vout->control->userdata = (struct MMAL_PORT_USERDATA_T *)this;
+  status = mmal_port_enable(m_vout->control, vout_control_port_cb);
+  if(status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to enable vout control port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+  m_vout_input = m_vout->input[0];
+  m_vout_input->userdata = (struct MMAL_PORT_USERDATA_T *)this;
+  mmal_format_full_copy(m_vout_input->format, format);
+  status = mmal_port_format_commit(m_vout_input);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to commit vout input format (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  if (m_format == RENDER_FMT_YUV420P)
+    m_vout_input->buffer_num = m_NumYV12Buffers;
+  else
+    m_vout_input->buffer_num = m_vout_input->buffer_num_min;
+  m_vout_input->buffer_size = m_vout_input->buffer_size_recommended;
+
+  status = mmal_port_enable(m_vout_input, vout_input_port_cb_static);
+  if(status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to vout enable input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  status = mmal_component_enable(m_vout);
+  if(status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to enable vout component (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  if (m_format == RENDER_FMT_YUV420P)
+  {
+    m_vout_input_pool = mmal_pool_create(m_vout_input->buffer_num, m_vout_input->buffer_size);
+    if (!m_vout_input_pool)
+    {
+      CLog::Log(LOGERROR, "%s::%s Failed to create pool for decoder input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+      return false;
+    }
+  }
+  return true;
+}
+
+bool COMXRenderer::change_vout_input_format(MMAL_ES_FORMAT_T *format)
+{
+  MMAL_STATUS_T status;
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  status = mmal_port_disable(m_vout_input);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to disable vout input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  mmal_format_full_copy(m_vout_input->format, format);
+  status = mmal_port_format_commit(m_vout_input);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to commit vout input format (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  m_vout_input->buffer_size = m_vout_input->buffer_size_min;
+  status = mmal_port_enable(m_vout_input, vout_input_port_cb_static);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to enable vout input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+  return true;
+}
+
+
+static void *vout_worker(void *p)
+{
+  MMAL_QUEUE_T *queue = (MMAL_QUEUE_T *)p;
+
+  while (true)
+  {
+    MMAL_BUFFER_HEADER_T *buffer = mmal_queue_wait(queue);
+    COpenMaxVideoBuffer *omvb = (COpenMaxVideoBuffer *)buffer->user_data;
+    omvb->Release();
+  }
+  return NULL;
+}
+
+COMXRenderer::COMXRenderer()
+{
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  m_vout = NULL;
+  m_vout_input = NULL;
+  m_vout_input_pool = NULL;
+  memset(m_buffers, 0, sizeof m_buffers);
+  m_release_queue = mmal_queue_create();
+  pthread_create(&m_worker, NULL, vout_worker, (void *)m_release_queue);
+}
+
+COMXRenderer::~COMXRenderer()
+{
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  UnInit();
+}
+
+void COMXRenderer::AddProcessor(COpenMaxVideoBuffer *openMaxBuffer, int index)
+{
+#if defined(HAVE_LIBOPENMAX)
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %p (%p) %i", CLASSNAME, __func__, openMaxBuffer, openMaxBuffer->mmal_buffer, index);
+#endif
+
+  YUVBUFFER &buf = m_buffers[index];
+  assert(!buf.openMaxBuffer);
+  memset(&buf, 0, sizeof buf);
+  buf.openMaxBuffer = openMaxBuffer->Acquire();
+#endif
+}
+
+bool COMXRenderer::Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format, unsigned int orientation)
+{
+  ReleaseBuffers();
+
+  m_sourceWidth  = width;
+  m_sourceHeight = height;
+  m_renderOrientation = orientation;
+
+  m_fps = fps;
+  m_iFlags = flags;
+  m_format = format;
+
+  CLog::Log(LOGDEBUG, "%s::%s - %dx%d->%dx%d@%.2f flags:%x format:%d ext:%x orient:%d", CLASSNAME, __func__, width, height, d_width, d_height, fps, flags, format, extended_format, orientation);
+
+  m_RenderUpdateCallBackFn = NULL;
+  m_RenderUpdateCallBackCtx = NULL;
+  if ((m_format == RENDER_FMT_BYPASS) && g_application.GetCurrentPlayer())
+  {
+    m_renderFeatures.clear();
+    m_scalingMethods.clear();
+    m_deinterlaceModes.clear();
+    m_deinterlaceMethods.clear();
+
+    if (m_RenderFeaturesCallBackFn)
+    {
+      (*m_RenderFeaturesCallBackFn)(m_RenderFeaturesCallBackCtx, m_renderFeatures);
+      // after setting up m_renderFeatures, we are done with the callback
+      m_RenderFeaturesCallBackFn = NULL;
+      m_RenderFeaturesCallBackCtx = NULL;
+    }
+    g_application.m_pPlayer->GetRenderFeatures(m_renderFeatures);
+    g_application.m_pPlayer->GetDeinterlaceMethods(m_deinterlaceMethods);
+    g_application.m_pPlayer->GetDeinterlaceModes(m_deinterlaceModes);
+    g_application.m_pPlayer->GetScalingMethods(m_scalingMethods);
+  }
+
+  // calculate the input frame aspect ratio
+  CalculateFrameAspectRatio(d_width, d_height);
+  ChooseBestResolution(fps);
+  m_destWidth = g_graphicsContext.GetResInfo(m_resolution).iWidth;
+  m_destHeight = g_graphicsContext.GetResInfo(m_resolution).iHeight;
+  SetViewMode(CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode);
+  ManageDisplay();
+
+  m_bConfigured = true;
+
+  return true;
+}
+
+int COMXRenderer::GetImage(YV12Image *image, int source, bool readonly)
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %p %d %d", CLASSNAME, __func__, image, source, readonly);
+#endif
+  if (!image) return -1;
+
+  if( source < 0)
+    return -1;
+
+  if (m_format == RENDER_FMT_OMXEGL)
+  {
+  }
+  else if (m_format == RENDER_FMT_YUV420P)
+  {
+    const int pitch = ALIGN_UP(m_sourceWidth, 32);
+    const int aligned_height = ALIGN_UP(m_sourceHeight, 16);
+    MMAL_BUFFER_HEADER_T *buffer = NULL;
+    if (!m_vout)
+    {
+      MMAL_ES_FORMAT_T *m_es_format = mmal_format_alloc();
+      m_es_format->encoding = MMAL_ENCODING_I420;
+      m_es_format->type = MMAL_ES_TYPE_VIDEO;
+      m_es_format->es->video.width = pitch;
+      m_es_format->es->video.height = aligned_height;
+      m_es_format->es->video.crop.width = m_sourceWidth;
+      m_es_format->es->video.crop.height = m_sourceHeight;
+
+      if (CONF_FLAGS_YUVCOEF_MASK(m_iFlags) == CONF_FLAGS_YUVCOEF_BT709)
+        m_es_format->es->video.color_space = MMAL_COLOR_SPACE_ITUR_BT709;
+      else if (CONF_FLAGS_YUVCOEF_MASK(m_iFlags) == CONF_FLAGS_YUVCOEF_BT601)
+        m_es_format->es->video.color_space = MMAL_COLOR_SPACE_ITUR_BT601;
+      else if (CONF_FLAGS_YUVCOEF_MASK(m_iFlags) == CONF_FLAGS_YUVCOEF_240M)
+        m_es_format->es->video.color_space = MMAL_COLOR_SPACE_SMPTE240M;
+
+      if (!m_vout && init_vout(m_es_format))
+      {
+         mmal_format_free(m_es_format);
+         return -1;
+      }
+      mmal_format_free(m_es_format);
+    }
+
+    buffer = mmal_queue_timedwait(m_vout_input_pool->queue, 500);
+    if (!buffer)
+    {
+      CLog::Log(LOGERROR, "%s::%s - mmal_queue_get failed", CLASSNAME, __func__);
+      return -1;
+    }
+
+    mmal_buffer_header_reset(buffer);
+
+    buffer->length = 3 * pitch * aligned_height >> 1;
+    assert(buffer->length <= buffer->alloc_size);
+
+    image->width    = m_sourceWidth;
+    image->height   = m_sourceHeight;
+    image->flags    = 0;
+    image->cshift_x = 1;
+    image->cshift_y = 1;
+    image->bpp      = 1;
+
+    image->stride[0] = pitch;
+    image->stride[1] = image->stride[2] = pitch>>image->cshift_x;
+
+    image->planesize[0] = pitch * aligned_height;
+    image->planesize[1] = image->planesize[2] = (pitch>>image->cshift_x)*(aligned_height>>image->cshift_y);
+
+    image->plane[0] = (uint8_t *)buffer->data;
+    image->plane[1] = image->plane[0] + image->planesize[0];
+    image->plane[2] = image->plane[1] + image->planesize[1];
+
+    CLog::Log(LOGDEBUG, "%s::%s - %p %d", CLASSNAME, __func__, buffer, source);
+    YUVBUFFER &buf = m_buffers[source];
+    memset(&buf, 0, sizeof buf);
+    buf.mmal_buffer = buffer;
+    //return -1;
+  }
+  else assert(0);
+
+  return source;
+}
+
+void COMXRenderer::ReleaseBuffer(int idx)
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %d", CLASSNAME, __func__, idx);
+#endif
+  YUVBUFFER &buf = m_buffers[idx];
+  SAFE_RELEASE(buf.openMaxBuffer);
+}
+
+void COMXRenderer::ReleaseImage(int source, bool preserve)
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %d %d", CLASSNAME, __func__, source, preserve);
+#endif
+}
+
+void COMXRenderer::Reset()
+{
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+}
+
+void COMXRenderer::Flush()
+{
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+}
+
+void COMXRenderer::Update()
+{
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  if (!m_bConfigured) return;
+  ManageDisplay();
+}
+
+void COMXRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %d %x %d", CLASSNAME, __func__, clear, flags, alpha);
+#endif
+
+  if (!m_bConfigured) return;
+
+  CSingleLock lock(g_graphicsContext);
+
+  ManageDisplay();
+
+  // if running bypass, then the player might need the src/dst rects
+  // for sizing video playback on a layer other than the gles layer.
+  if (m_RenderUpdateCallBackFn)
+    (*m_RenderUpdateCallBackFn)(m_RenderUpdateCallBackCtx, m_sourceRect, m_destRect);
+
+  SetVideoRect(m_sourceRect, m_destRect);
+
+  CRect old = g_graphicsContext.GetScissors();
+
+  g_graphicsContext.BeginPaint();
+  g_graphicsContext.SetScissors(m_destRect);
+
+  glEnable(GL_BLEND);
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+  glClearColor(0, 0, 0, 0);
+  glClear(GL_COLOR_BUFFER_BIT);
+
+  g_graphicsContext.SetScissors(old);
+  g_graphicsContext.EndPaint();
+}
+
+void COMXRenderer::FlipPage(int source)
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %d", CLASSNAME, __func__, source);
+#endif
+
+  if (!m_bConfigured || m_format == RENDER_FMT_BYPASS)
+    return;
+
+  YUVBUFFER *buffer = &m_buffers[source];
+  // we only want to upload frames once
+  if (buffer->flipindex++)
+    return;
+  if (m_format == RENDER_FMT_OMXEGL)
+  {
+    COpenMaxVideoBuffer *omvb = buffer->openMaxBuffer;
+    if (omvb)
+    {
+#if defined(HAVE_LIBOPENMAX)
+#if defined(OMX_DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, "%s::%s %p (%p) frame:%d(%d)", CLASSNAME, __func__, omvb, omvb->mmal_buffer, m_changed_count_vout, omvb->m_changed_count);
+#endif
+
+
+      MMAL_ES_FORMAT_T *m_es_format = mmal_format_alloc();
+      m_es_format->encoding = MMAL_ENCODING_OPAQUE;
+      m_es_format->type = MMAL_ES_TYPE_VIDEO;
+      m_es_format->es->video.width = m_sourceWidth;
+      m_es_format->es->video.height = m_sourceHeight;
+      m_es_format->es->video.crop.width = m_sourceWidth;
+      m_es_format->es->video.crop.height = m_sourceHeight;
+
+      if (!m_vout && init_vout(m_es_format))
+      {
+         mmal_format_free(m_es_format);
+         return;
+      }
+      mmal_format_free(m_es_format);
+
+      /*if (m_changed_count_vout != omvb->m_changed_count)
+      {
+        CLog::Log(LOGDEBUG, "%s::%s format changed frame:%d(%d)", CLASSNAME, __func__, m_changed_count_vout, omvb->m_changed_count);
+        change_vout_input_format(omvb->GetFormat());
+        m_changed_count_vout = omvb->m_changed_count;
+      }*/
+      omvb->Acquire();
+      mmal_port_send_buffer(m_vout_input, omvb->mmal_buffer);
+    } else assert(0);
+#endif
+  }
+  else if (m_format == RENDER_FMT_YUV420P)
+  {
+    CLog::Log(LOGDEBUG, "%s::%s - %p %d", CLASSNAME, __func__, buffer->mmal_buffer, source);
+    if (buffer->mmal_buffer)
+      mmal_port_send_buffer(m_vout_input, buffer->mmal_buffer);
+    else assert(0);
+  }
+  else assert(0);
+}
+
+unsigned int COMXRenderer::PreInit()
+{
+  CSingleLock lock(g_graphicsContext);
+  m_bConfigured = false;
+  UnInit();
+
+  m_changed_count_vout = 0;
+
+  m_iFlags = 0;
+  m_src_rect.SetRect(0, 0, 0, 0);
+  m_dst_rect.SetRect(0, 0, 0, 0);
+  m_video_stereo_mode = RENDER_STEREO_MODE_OFF;
+  m_display_stereo_mode = RENDER_STEREO_MODE_OFF;
+  m_StereoInvert = false;
+
+  m_resolution = CDisplaySettings::Get().GetCurrentResolution();
+  if ( m_resolution == RES_WINDOW )
+    m_resolution = RES_DESKTOP;
+
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  m_formats.clear();
+  m_formats.push_back(RENDER_FMT_YUV420P);
+  m_formats.push_back(RENDER_FMT_OMXEGL);
+  m_formats.push_back(RENDER_FMT_BYPASS);
+
+  m_NumYV12Buffers = 3;
+
+  return 0;
+}
+
+void COMXRenderer::ReleaseBuffers()
+{
+#if defined(HAVE_LIBOPENMAX)
+  for (int i=0; i<NUM_BUFFERS; i++)
+    ReleaseBuffer(i);
+#endif
+}
+
+void COMXRenderer::UnInit()
+{
+  CSingleLock lock(g_graphicsContext);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  if (m_vout)
+  {
+    mmal_component_disable(m_vout);
+    mmal_port_disable(m_vout->control);
+  }
+
+  if (m_vout_input)
+  {
+    mmal_port_flush(m_vout_input);
+    mmal_port_disable(m_vout_input);
+    m_vout_input = NULL;
+  }
+
+  if (m_vout_input_pool)
+  {
+    mmal_pool_destroy(m_vout_input_pool);
+    m_vout_input_pool = NULL;
+  }
+
+  if (m_vout)
+  {
+    mmal_component_release(m_vout);
+    m_vout = NULL;
+  }
+  ReleaseBuffers();
+
+  m_RenderUpdateCallBackFn = NULL;
+  m_RenderUpdateCallBackCtx = NULL;
+  m_RenderFeaturesCallBackFn = NULL;
+  m_RenderFeaturesCallBackCtx = NULL;
+
+  m_bConfigured = false;
+}
+
+bool COMXRenderer::RenderCapture(CRenderCapture* capture)
+{
+  if (!m_bConfigured)
+    return false;
+
+  CLog::Log(LOGDEBUG, "%s::%s - %p", CLASSNAME, __func__, capture);
+
+  capture->BeginRender();
+  capture->EndRender();
+
+  return true;
+}
+
+//********************************************************************************************************
+// YV12 Texture creation, deletion, copying + clearing
+//********************************************************************************************************
+
+bool COMXRenderer::Supports(EDEINTERLACEMODE mode)
+{
+  // Player controls render, let it dictate available deinterlace modes
+  if (m_format == RENDER_FMT_BYPASS)
+  {
+    Features::iterator itr = std::find(m_deinterlaceModes.begin(),m_deinterlaceModes.end(), mode);
+    return itr != m_deinterlaceModes.end();
+  }
+
+  if(mode == VS_DEINTERLACEMODE_OFF
+  || mode == VS_DEINTERLACEMODE_AUTO
+  || mode == VS_DEINTERLACEMODE_FORCE)
+    return true;
+
+  return false;
+}
+
+bool COMXRenderer::Supports(EINTERLACEMETHOD method)
+{
+  // Player controls render, let it dictate available deinterlace methods
+  if (m_format == RENDER_FMT_BYPASS)
+  {
+    Features::iterator itr = std::find(m_deinterlaceMethods.begin(),m_deinterlaceMethods.end(), method);
+    return itr != m_deinterlaceMethods.end();
+  }
+
+  if (method == VS_INTERLACEMETHOD_DEINTERLACE_HALF)
+    return true;
+
+  return false;
+}
+
+bool COMXRenderer::Supports(ERENDERFEATURE feature)
+{
+  // Player controls render, let it dictate available render features
+  if (m_format == RENDER_FMT_BYPASS)
+  {
+    Features::iterator itr = std::find(m_renderFeatures.begin(),m_renderFeatures.end(), feature);
+    return itr != m_renderFeatures.end();
+  }
+
+  if (feature == RENDERFEATURE_STRETCH         ||
+      feature == RENDERFEATURE_CROP            ||
+      feature == RENDERFEATURE_ZOOM            ||
+      feature == RENDERFEATURE_ROTATION        ||
+      feature == RENDERFEATURE_VERTICAL_SHIFT  ||
+      feature == RENDERFEATURE_PIXEL_RATIO)
+    return true;
+
+  return false;
+}
+
+bool COMXRenderer::Supports(ESCALINGMETHOD method)
+{
+  // Player controls render, let it dictate available scaling methods
+  if (m_format == RENDER_FMT_BYPASS)
+  {
+    Features::iterator itr = std::find(m_scalingMethods.begin(),m_scalingMethods.end(), method);
+    return itr != m_scalingMethods.end();
+  }
+  return false;
+}
+
+EINTERLACEMETHOD COMXRenderer::AutoInterlaceMethod()
+{
+  return VS_INTERLACEMETHOD_DEINTERLACE_HALF;
+}
+
+unsigned int COMXRenderer::GetProcessorSize()
+{
+  if (m_format == RENDER_FMT_OMXEGL)
+    return 1;
+  else
+    return 0;
+}
+
+#endif
+
+void COMXRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect)
+{
+  // we get called twice a frame for left/right. Can ignore the rights.
+  if (g_graphicsContext.GetStereoView() == RENDER_STEREO_VIEW_RIGHT)
+    return;
+
+  if (!m_vout)
+    return;
+
+  CRect SrcRect = InSrcRect, DestRect = InDestRect;
+  RENDER_STEREO_MODE video_stereo_mode = (m_iFlags & CONF_FLAGS_STEREO_MODE_SBS) ? RENDER_STEREO_MODE_SPLIT_VERTICAL :
+                                         (m_iFlags & CONF_FLAGS_STEREO_MODE_TAB) ? RENDER_STEREO_MODE_SPLIT_HORIZONTAL : RENDER_STEREO_MODE_OFF;
+  bool stereo_invert                   = (m_iFlags & CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT) ? true : false;
+  RENDER_STEREO_MODE display_stereo_mode = g_graphicsContext.GetStereoMode();
+
+  // fix up transposed video
+  if (m_renderOrientation == 90 || m_renderOrientation == 270)
+  {
+    float diff = (DestRect.Height() - DestRect.Width()) * 0.5f;
+    DestRect.x1 -= diff;
+    DestRect.x2 += diff;
+    DestRect.y1 += diff;
+    DestRect.y2 -= diff;
+  }
+
+  // check if destination rect or video view mode has changed
+  if (!(m_dst_rect != DestRect) && !(m_src_rect != SrcRect) && m_video_stereo_mode == video_stereo_mode && m_display_stereo_mode == display_stereo_mode && m_StereoInvert == stereo_invert)
+    return;
+
+  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d (o:%d v:%d d:%d i:%d)", CLASSNAME, __func__,
+      (int)SrcRect.x1, (int)SrcRect.y1, (int)SrcRect.x2, (int)SrcRect.y2,
+      (int)DestRect.x1, (int)DestRect.y1, (int)DestRect.x2, (int)DestRect.y2,
+      m_renderOrientation, video_stereo_mode, display_stereo_mode, stereo_invert);
+
+  m_src_rect = SrcRect;
+  m_dst_rect = DestRect;
+  m_video_stereo_mode = video_stereo_mode;
+  m_display_stereo_mode = display_stereo_mode;
+  m_StereoInvert = stereo_invert;
+
+  // might need to scale up m_dst_rect to display size as video decodes
+  // to separate video plane that is at display size.
+  RESOLUTION res = g_graphicsContext.GetVideoResolution();
+  CRect gui(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iWidth, CDisplaySettings::Get().GetResolutionInfo(res).iHeight);
+  CRect display(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight);
+
+  if (display_stereo_mode != RENDER_STEREO_MODE_OFF && display_stereo_mode != RENDER_STEREO_MODE_MONO)
+  switch (video_stereo_mode)
+  {
+  case RENDER_STEREO_MODE_SPLIT_VERTICAL:
+    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
+    if (video_stereo_mode == display_stereo_mode && DestRect.x1 == 0.0f && DestRect.x2 * 2.0f == gui.Width() && !stereo_invert)
+    {
+      SrcRect.x2 *= 2.0f;
+      DestRect.x2 *= 2.0f;
+      video_stereo_mode = RENDER_STEREO_MODE_OFF;
+      display_stereo_mode = RENDER_STEREO_MODE_OFF;
+    }
+    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)
+    {
+      SrcRect.x2 *= 2.0f;
+    }
+    break;
+
+  case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
+    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
+    if (video_stereo_mode == display_stereo_mode && DestRect.y1 == 0.0f && DestRect.y2 * 2.0f == gui.Height() && !stereo_invert)
+    {
+      SrcRect.y2 *= 2.0f;
+      DestRect.y2 *= 2.0f;
+      video_stereo_mode = RENDER_STEREO_MODE_OFF;
+      display_stereo_mode = RENDER_STEREO_MODE_OFF;
+    }
+    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)
+    {
+      SrcRect.y2 *= 2.0f;
+    }
+    break;
+
+  default: break;
+  }
+
+  if (gui != display)
+  {
+    float xscale = display.Width()  / gui.Width();
+    float yscale = display.Height() / gui.Height();
+    DestRect.x1 *= xscale;
+    DestRect.x2 *= xscale;
+    DestRect.y1 *= yscale;
+    DestRect.y2 *= yscale;
+  }
+
+  MMAL_DISPLAYREGION_T region;
+  memset(&region, 0, sizeof region);
+
+  region.set                 = MMAL_DISPLAY_SET_DEST_RECT|MMAL_DISPLAY_SET_SRC_RECT|MMAL_DISPLAY_SET_FULLSCREEN|MMAL_DISPLAY_SET_NOASPECT|MMAL_DISPLAY_SET_MODE;
+  region.dest_rect.x         = lrintf(DestRect.x1);
+  region.dest_rect.y         = lrintf(DestRect.y1);
+  region.dest_rect.width     = lrintf(DestRect.Width());
+  region.dest_rect.height    = lrintf(DestRect.Height());
+
+  region.src_rect.x          = lrintf(SrcRect.x1);
+  region.src_rect.y          = lrintf(SrcRect.y1);
+  region.src_rect.width      = lrintf(SrcRect.Width());
+  region.src_rect.height     = lrintf(SrcRect.Height());
+
+  region.fullscreen = MMAL_FALSE;
+  region.noaspect = MMAL_TRUE;
+
+  if (m_renderOrientation)
+  {
+    region.set |= MMAL_DISPLAY_SET_TRANSFORM;
+    if (m_renderOrientation == 90)
+      region.transform = MMAL_DISPLAY_ROT90;
+    else if (m_renderOrientation == 180)
+      region.transform = MMAL_DISPLAY_ROT180;
+    else if (m_renderOrientation == 270)
+      region.transform = MMAL_DISPLAY_ROT270;
+    else assert(0);
+  }
+
+  if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    region.mode = MMAL_DISPLAY_MODE_STEREO_TOP_TO_TOP;
+  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    region.mode = MMAL_DISPLAY_MODE_STEREO_TOP_TO_LEFT;
+  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    region.mode = MMAL_DISPLAY_MODE_STEREO_LEFT_TO_TOP;
+  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    region.mode = MMAL_DISPLAY_MODE_STEREO_LEFT_TO_LEFT;
+  else
+    region.mode = MMAL_DISPLAY_MODE_LETTERBOX;
+
+  MMAL_STATUS_T status = mmal_util_set_display_region(m_vout_input, &region);
+  if (status != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "%s::%s Failed to set display region (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+
+  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d mode:%d", CLASSNAME, __func__,
+      region.src_rect.x, region.src_rect.y, region.src_rect.width, region.src_rect.height,
+      region.dest_rect.x, region.dest_rect.y, region.dest_rect.width, region.dest_rect.height, region.mode);
+}
diff --git a/xbmc/cores/VideoRenderers/OMXRenderer.h b/xbmc/cores/VideoRenderers/OMXRenderer.h
new file mode 100644
index 0000000..724342a
--- /dev/null
+++ b/xbmc/cores/VideoRenderers/OMXRenderer.h
@@ -0,0 +1,129 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(TARGET_RASPBERRY_PI)
+
+#include "guilib/GraphicContext.h"
+#include "RenderFlags.h"
+#include "RenderFormats.h"
+#include "BaseRenderer.h"
+#include "RenderCapture.h"
+#include "settings/VideoSettings.h"
+#include "cores/dvdplayer/DVDStreamInfo.h"
+#include "guilib/Geometry.h"
+
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_util_params.h>
+
+#define AUTOSOURCE -1
+
+class CBaseTexture;
+class COpenMaxVideoBuffer;
+
+struct DVDVideoPicture;
+
+class COMXRenderer : public CBaseRenderer
+{
+  struct YUVBUFFER
+  {
+    COpenMaxVideoBuffer *openMaxBuffer; // used for hw decoded buffers
+    MMAL_BUFFER_HEADER_T *mmal_buffer;  // used for sw decoded buffers
+    unsigned flipindex; /* used to decide if this has been uploaded */
+  };
+public:
+  COMXRenderer();
+  ~COMXRenderer();
+
+  virtual void Update();
+  virtual void SetupScreenshot() {};
+
+  bool RenderCapture(CRenderCapture* capture);
+
+  // Player functions
+  virtual bool         Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format, unsigned int orientation);
+  virtual int          GetImage(YV12Image *image, int source = AUTOSOURCE, bool readonly = false);
+  virtual void         ReleaseImage(int source, bool preserve = false);
+  virtual void         ReleaseBuffer(int idx);
+  virtual void         FlipPage(int source);
+  virtual unsigned int PreInit();
+  virtual void         UnInit();
+  virtual void         Reset(); /* resets renderer after seek for example */
+  virtual void         Flush();
+  virtual bool         IsConfigured() { return m_bConfigured; }
+  virtual void         AddProcessor(COpenMaxVideoBuffer *openMaxVideoBuffer, int index);
+  virtual std::vector<ERenderFormat> SupportedFormats() { return m_formats; }
+
+  virtual bool         Supports(ERENDERFEATURE feature);
+  virtual bool         Supports(EDEINTERLACEMODE mode);
+  virtual bool         Supports(EINTERLACEMETHOD method);
+  virtual bool         Supports(ESCALINGMETHOD method);
+
+  virtual EINTERLACEMETHOD AutoInterlaceMethod();
+
+  void                 RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
+
+  virtual void         SetBufferSize(int numBuffers) { m_NumYV12Buffers = numBuffers; }
+  virtual unsigned int GetMaxBufferSize() { return NUM_BUFFERS; }
+  virtual unsigned int GetProcessorSize();
+  virtual void SetVideoRect(const CRect& SrcRect, const CRect& DestRect);
+
+  void vout_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
+protected:
+  int m_NumYV12Buffers;
+
+  std::vector<ERenderFormat> m_formats;
+
+  YUVBUFFER            m_buffers[NUM_BUFFERS];
+  bool                 m_bConfigured;
+  unsigned int         m_extended_format;
+  unsigned int         m_destWidth;
+  unsigned int         m_destHeight;
+  int                  m_neededBuffers;
+
+  Features m_renderFeatures;
+  Features m_deinterlaceMethods;
+  Features m_deinterlaceModes;
+  Features m_scalingMethods;
+
+  CRect                     m_src_rect;
+  CRect                     m_dst_rect;
+  RENDER_STEREO_MODE        m_video_stereo_mode;
+  RENDER_STEREO_MODE        m_display_stereo_mode;
+  bool                      m_StereoInvert;
+
+  MMAL_COMPONENT_T *m_vout;
+  MMAL_PORT_T *m_vout_input;
+  MMAL_POOL_T *m_vout_input_pool;
+
+  uint32_t          m_changed_count_vout;
+  pthread_t         m_worker;
+  MMAL_QUEUE_T     *m_release_queue;
+  bool change_vout_input_format(MMAL_ES_FORMAT_T *m_format);
+  bool init_vout(MMAL_ES_FORMAT_T *m_format);
+  void ReleaseBuffers();
+};
+
+#else
+#include "LinuxRenderer.h"
+#endif
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 568c8b2..f770146 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -41,6 +41,8 @@
 
 #if defined(HAS_GL)
   #include "LinuxRendererGL.h"
+#elif defined(TARGET_RASPBERRY_PI)
+  #include "OMXRenderer.h"
 #elif HAS_GLES == 2
   #include "LinuxRendererGLES.h"
 #elif defined(HAS_DX)
@@ -424,6 +426,8 @@ unsigned int CXBMCRenderManager::PreInit()
   {
 #if defined(HAS_GL)
     m_pRenderer = new CLinuxRendererGL();
+#elif defined(TARGET_RASPBERRY_PI)
+    m_pRenderer = new COMXRenderer();
 #elif HAS_GLES == 2
     m_pRenderer = new CLinuxRendererGLES();
 #elif defined(HAS_DX)
@@ -921,7 +925,7 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
 #endif
 #ifdef HAVE_LIBOPENMAX
   else if(pic.format == RENDER_FMT_OMXEGL)
-    m_pRenderer->AddProcessor(pic.openMax, &pic, index);
+    m_pRenderer->AddProcessor(pic.openMaxBuffer, index);
 #endif
 #ifdef TARGET_DARWIN
   else if(pic.format == RENDER_FMT_CVBREF)
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index e8d4ca2..1b54c79 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -42,6 +42,7 @@ struct DVDVideoPicture;
 #define ERRORBUFFSIZE 30
 
 class CWinRenderer;
+class COMXRenderer;
 class CLinuxRenderer;
 class CLinuxRendererGL;
 class CLinuxRendererGLES;
@@ -146,6 +147,8 @@ class CXBMCRenderManager
 
 #ifdef HAS_GL
   CLinuxRendererGL    *m_pRenderer;
+#elif defined(TARGET_RASPBERRY_PI)
+  COMXRenderer        *m_pRenderer;
 #elif HAS_GLES == 2
   CLinuxRendererGLES  *m_pRenderer;
 #elif defined(HAS_DX)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index f8a5635..3a11154 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -191,6 +191,10 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
 #endif
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
+#if defined(HAVE_LIBOPENMAX)
+  // libopenmax can handle dvd playback including stills
+  if (!CSettings::Get().GetBool("videoplayer.useomx"))
+#endif
   if (hint.stills && (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO))
   {
      // If dvd is an mpeg2 and hint.stills
@@ -252,7 +256,10 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
 #if defined(HAVE_LIBOPENMAX)
   if (CSettings::Get().GetBool("videoplayer.useomx") && !hint.software )
   {
-      if (hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_VC1)
+    if (hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_H263 || hint.codec == AV_CODEC_ID_MPEG4 ||
+        hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO ||
+        hint.codec == AV_CODEC_ID_VP6 || hint.codec == AV_CODEC_ID_VP6F || hint.codec == AV_CODEC_ID_VP6A || hint.codec == AV_CODEC_ID_VP8 ||
+        hint.codec == AV_CODEC_ID_THEORA || hint.codec == AV_CODEC_ID_MJPEG || hint.codec == AV_CODEC_ID_MJPEGB || hint.codec == AV_CODEC_ID_VC1 || hint.codec == AV_CODEC_ID_WMV3)
     {
       if ( (pCodec = OpenCodec(new CDVDVideoCodecOpenMax(), hint, options)) ) return pCodec;
     }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index b236ad7..10b38d4 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -50,9 +50,7 @@ struct DVDCodecAvailableType
 namespace DXVA { class CSurfaceContext; }
 namespace VAAPI { class CVaapiRenderPicture; }
 namespace VDPAU { class CVdpauRenderPicture; }
-class COpenMax;
-class COpenMaxVideo;
-struct OpenMaxVideoBuffer;
+class COpenMaxVideoBuffer;
 class CDVDVideoCodecStageFright;
 class CDVDMediaCodecInfo;
 class CDVDVideoCodecIMXBuffer;
@@ -82,8 +80,7 @@ struct DVDVideoPicture
     };
 
     struct {
-      COpenMax *openMax;
-      OpenMaxVideoBuffer *openMaxBuffer;
+      COpenMaxVideoBuffer *openMaxBuffer;
     };
 
     struct {
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
index b2e7816..8323497 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
@@ -28,114 +28,37 @@
 #include "DVDClock.h"
 #include "DVDStreamInfo.h"
 #include "DVDVideoCodecOpenMax.h"
-#include "OpenMaxVideo.h"
+#include "settings/Settings.h"
 #include "utils/log.h"
 
-#define CLASSNAME "COpenMax"
+#define CLASSNAME "CDVDVideoCodecOpenMax"
 ////////////////////////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////////////////////////
-CDVDVideoCodecOpenMax::CDVDVideoCodecOpenMax() : CDVDVideoCodec()
+CDVDVideoCodecOpenMax::CDVDVideoCodecOpenMax()
+ : m_omx_decoder( new COpenMaxVideo )
 {
-  m_omx_decoder = NULL;
-  m_pFormatName = "omx-xxxx";
-
-  m_convert_bitstream = false;
-  memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
+  CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
 }
 
 CDVDVideoCodecOpenMax::~CDVDVideoCodecOpenMax()
 {
+  CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
   Dispose();
 }
 
 bool CDVDVideoCodecOpenMax::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  // we always qualify even if DVDFactoryCodec does this too.
-  if (CSettings::Get().GetBool("videoplayer.useomx") && !hints.software)
-  {
-    m_convert_bitstream = false;
-
-    switch (hints.codec)
-    {
-      case AV_CODEC_ID_H264:
-      {
-        m_pFormatName = "omx-h264";
-        if (hints.extrasize < 7 || hints.extradata == NULL)
-        {
-          CLog::Log(LOGNOTICE,
-            "%s::%s - avcC data too small or missing", CLASSNAME, __func__);
-          return false;
-        }
-        // valid avcC data (bitstream) always starts with the value 1 (version)
-        if ( *(char*)hints.extradata == 1 )
-          m_convert_bitstream = bitstream_convert_init(hints.extradata, hints.extrasize);
-      }
-      break;
-      case AV_CODEC_ID_MPEG4:
-        m_pFormatName = "omx-mpeg4";
-      break;
-      case AV_CODEC_ID_MPEG2VIDEO:
-        m_pFormatName = "omx-mpeg2";
-      break;
-      case AV_CODEC_ID_VC1:
-        m_pFormatName = "omx-vc1";
-      break;
-      default:
-        return false;
-      break;
-    }
-
-    m_omx_decoder = new COpenMaxVideo;
-    if (!m_omx_decoder->Open(hints))
-    {
-      CLog::Log(LOGERROR,
-        "%s::%s - failed to open, codec(%d), profile(%d), level(%d)", 
-        CLASSNAME, __func__, hints.codec, hints.profile, hints.level);
-      return false;
-    }
-
-    // allocate a YV12 DVDVideoPicture buffer.
-    // first make sure all properties are reset.
-    memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
-
-    m_videobuffer.dts = DVD_NOPTS_VALUE;
-    m_videobuffer.pts = DVD_NOPTS_VALUE;
-    //m_videobuffer.format = RENDER_FMT_YUV420P;
-    m_videobuffer.format = RENDER_FMT_OMXEGL;
-    m_videobuffer.color_range  = 0;
-    m_videobuffer.color_matrix = 4;
-    m_videobuffer.iFlags  = DVP_FLAG_ALLOCATED;
-    m_videobuffer.iWidth  = hints.width;
-    m_videobuffer.iHeight = hints.height;
-    m_videobuffer.iDisplayWidth  = hints.width;
-    m_videobuffer.iDisplayHeight = hints.height;
-
-    return true;
-  }
+  return m_omx_decoder->Open(hints, options, m_omx_decoder);
+}
 
-  return false;
+const char* CDVDVideoCodecOpenMax::GetName(void)
+{
+  return m_omx_decoder ? m_omx_decoder->GetName() : "omx-xxx";
 }
 
 void CDVDVideoCodecOpenMax::Dispose()
 {
-  if (m_omx_decoder)
-  {
-    m_omx_decoder->Close();
-    delete m_omx_decoder;
-    m_omx_decoder = NULL;
-  }
-  if (m_videobuffer.iFlags & DVP_FLAG_ALLOCATED)
-  {
-    m_videobuffer.iFlags = 0;
-  }
-  if (m_convert_bitstream)
-  {
-    if (m_sps_pps_context.sps_pps_data)
-    {
-      free(m_sps_pps_context.sps_pps_data);
-      m_sps_pps_context.sps_pps_data = NULL;
-    }
-  }
+  m_omx_decoder->Dispose();
 }
 
 void CDVDVideoCodecOpenMax::SetDropState(bool bDrop)
@@ -145,37 +68,12 @@ void CDVDVideoCodecOpenMax::SetDropState(bool bDrop)
 
 int CDVDVideoCodecOpenMax::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
-  if (pData)
-  {
-    int rtn;
-    int demuxer_bytes = iSize;
-    uint8_t *demuxer_content = pData;
-    bool bitstream_convered  = false;
-
-    if (m_convert_bitstream)
-    {
-      // convert demuxer packet from bitstream to bytestream (AnnexB)
-      int bytestream_size = 0;
-      uint8_t *bytestream_buff = NULL;
-
-      bitstream_convert(demuxer_content, demuxer_bytes, &bytestream_buff, &bytestream_size);
-      if (bytestream_buff && (bytestream_size > 0))
-      {
-        bitstream_convered = true;
-        demuxer_bytes = bytestream_size;
-        demuxer_content = bytestream_buff;
-      }
-    }
-
-    rtn = m_omx_decoder->Decode(demuxer_content, demuxer_bytes, dts, pts);
-
-    if (bitstream_convered)
-      free(demuxer_content);
+  return m_omx_decoder->Decode(pData, iSize, dts, pts);
+}
 
-    return rtn;
-  }
-  
-  return VC_BUFFER;
+unsigned CDVDVideoCodecOpenMax::GetAllowedReferences()
+{
+  return m_omx_decoder->GetAllowedReferences();
 }
 
 void CDVDVideoCodecOpenMax::Reset(void)
@@ -185,172 +83,17 @@ void CDVDVideoCodecOpenMax::Reset(void)
 
 bool CDVDVideoCodecOpenMax::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  m_omx_decoder->GetPicture(&m_videobuffer);
-  *pDvdVideoPicture = m_videobuffer;
-
-  return VC_PICTURE | VC_BUFFER;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-bool CDVDVideoCodecOpenMax::bitstream_convert_init(void *in_extradata, int in_extrasize)
-{
-  // based on h264_mp4toannexb_bsf.c (ffmpeg)
-  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
-  // and Licensed GPL 2.1 or greater
-
-  m_sps_pps_size = 0;
-  m_sps_pps_context.sps_pps_data = NULL;
-  
-  // nothing to filter
-  if (!in_extradata || in_extrasize < 6)
-    return false;
-
-  uint16_t unit_size;
-  uint32_t total_size = 0;
-  uint8_t *out = NULL, unit_nb, sps_done = 0;
-  const uint8_t *extradata = (uint8_t*)in_extradata + 4;
-  static const uint8_t nalu_header[4] = {0, 0, 0, 1};
-
-  // retrieve length coded size
-  m_sps_pps_context.length_size = (*extradata++ & 0x3) + 1;
-  if (m_sps_pps_context.length_size == 3)
-    return false;
-
-  // retrieve sps and pps unit(s)
-  unit_nb = *extradata++ & 0x1f;  // number of sps unit(s)
-  if (!unit_nb)
-  {
-    unit_nb = *extradata++;       // number of pps unit(s)
-    sps_done++;
-  }
-  while (unit_nb--)
-  {
-    unit_size = extradata[0] << 8 | extradata[1];
-    total_size += unit_size + 4;
-    if ( (extradata + 2 + unit_size) > ((uint8_t*)in_extradata + in_extrasize) )
-    {
-      free(out);
-      return false;
-    }
-    uint8_t* new_out = (uint8_t*)realloc(out, total_size);
-    if (new_out)
-    {
-      out = new_out;
-    }
-    else
-    {
-      CLog::Log(LOGERROR, "bitstream_convert_init failed - %s : could not realloc the buffer out",  __FUNCTION__);
-      free(out);
-      return false;
-    }
-
-    memcpy(out + total_size - unit_size - 4, nalu_header, 4);
-    memcpy(out + total_size - unit_size, extradata + 2, unit_size);
-    extradata += 2 + unit_size;
-
-    if (!unit_nb && !sps_done++)
-      unit_nb = *extradata++;     // number of pps unit(s)
-  }
-
-  m_sps_pps_context.sps_pps_data = out;
-  m_sps_pps_context.size = total_size;
-  m_sps_pps_context.first_idr = 1;
-
-  return true;
+  return m_omx_decoder->GetPicture(pDvdVideoPicture);
 }
 
-bool CDVDVideoCodecOpenMax::bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
+bool CDVDVideoCodecOpenMax::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  // based on h264_mp4toannexb_bsf.c (ffmpeg)
-  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
-  // and Licensed GPL 2.1 or greater
-
-  uint8_t *buf = pData;
-  uint32_t buf_size = iSize;
-  uint8_t  unit_type;
-  int32_t  nal_size;
-  uint32_t cumul_size = 0;
-  const uint8_t *buf_end = buf + buf_size;
-
-  do
-  {
-    if (buf + m_sps_pps_context.length_size > buf_end)
-      goto fail;
-
-    if (m_sps_pps_context.length_size == 1)
-      nal_size = buf[0];
-    else if (m_sps_pps_context.length_size == 2)
-      nal_size = buf[0] << 8 | buf[1];
-    else
-      nal_size = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];
-
-    buf += m_sps_pps_context.length_size;
-    unit_type = *buf & 0x1f;
-
-    if (buf + nal_size > buf_end || nal_size < 0)
-      goto fail;
-
-    // prepend only to the first type 5 NAL unit of an IDR picture
-    if (m_sps_pps_context.first_idr && unit_type == 5)
-    {
-      bitstream_alloc_and_copy(poutbuf, poutbuf_size,
-        m_sps_pps_context.sps_pps_data, m_sps_pps_context.size, buf, nal_size);
-      m_sps_pps_context.first_idr = 0;
-    }
-    else
-    {
-      bitstream_alloc_and_copy(poutbuf, poutbuf_size, NULL, 0, buf, nal_size);
-      if (!m_sps_pps_context.first_idr && unit_type == 1)
-          m_sps_pps_context.first_idr = 1;
-    }
-
-    buf += nal_size;
-    cumul_size += nal_size + m_sps_pps_context.length_size;
-  } while (cumul_size < buf_size);
-
-  return true;
-
-fail:
-  free(*poutbuf);
-  *poutbuf = NULL;
-  *poutbuf_size = 0;
-  return false;
+  return m_omx_decoder->ClearPicture(pDvdVideoPicture);
 }
 
-void CDVDVideoCodecOpenMax::bitstream_alloc_and_copy(
-  uint8_t **poutbuf,      int *poutbuf_size,
-  const uint8_t *sps_pps, uint32_t sps_pps_size,
-  const uint8_t *in,      uint32_t in_size)
+bool CDVDVideoCodecOpenMax::GetCodecStats(double &pts, int &droppedPics)
 {
-  // based on h264_mp4toannexb_bsf.c (ffmpeg)
-  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
-  // and Licensed GPL 2.1 or greater
-
-  #define CHD_WB32(p, d) { \
-    ((uint8_t*)(p))[3] = (d); \
-    ((uint8_t*)(p))[2] = (d) >> 8; \
-    ((uint8_t*)(p))[1] = (d) >> 16; \
-    ((uint8_t*)(p))[0] = (d) >> 24; }
-
-  uint32_t offset = *poutbuf_size;
-  uint8_t nal_header_size = offset ? 3 : 4;
-
-  *poutbuf_size += sps_pps_size + in_size + nal_header_size;
-  *poutbuf = (uint8_t*)realloc(*poutbuf, *poutbuf_size);
-  if (sps_pps)
-    memcpy(*poutbuf + offset, sps_pps, sps_pps_size);
-
-  memcpy(*poutbuf + sps_pps_size + nal_header_size + offset, in, in_size);
-  if (!offset)
-  {
-    CHD_WB32(*poutbuf + sps_pps_size, 1);
-  }
-  else
-  {
-    (*poutbuf + offset + sps_pps_size)[0] = 0;
-    (*poutbuf + offset + sps_pps_size)[1] = 0;
-    (*poutbuf + offset + sps_pps_size)[2] = 1;
-  }
+  return m_omx_decoder->GetCodecStats(pts, droppedPics);
 }
 
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
index fb80d02..4f243df 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
@@ -22,8 +22,9 @@
 #if defined(HAVE_LIBOPENMAX)
 
 #include "DVDVideoCodec.h"
+#include "OpenMaxVideo.h"
 
-class COpenVideoMax;
+class COpenMaxVideo;
 class CDVDVideoCodecOpenMax : public CDVDVideoCodec
 {
 public:
@@ -36,39 +37,14 @@ class CDVDVideoCodecOpenMax : public CDVDVideoCodec
   virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   virtual void Reset(void);
   virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual unsigned GetAllowedReferences();
   virtual void SetDropState(bool bDrop);
-  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+  virtual const char* GetName(void);
+  virtual bool GetCodecStats(double &pts, int &droppedPics);
   
 protected:
-  const char        *m_pFormatName;
-  COpenMaxVideo     *m_omx_decoder;
-  DVDVideoPicture   m_videobuffer;
-
-  // bitstream to bytestream (Annex B) conversion support.
-  bool bitstream_convert_init(void *in_extradata, int in_extrasize);
-  bool bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size);
-  static void bitstream_alloc_and_copy( uint8_t **poutbuf, int *poutbuf_size,
-    const uint8_t *sps_pps, uint32_t sps_pps_size, const uint8_t *in, uint32_t in_size);
-
-  typedef struct omx_bitstream_ctx {
-      uint8_t  length_size;
-      uint8_t  first_idr;
-      uint8_t *sps_pps_data;
-      uint32_t size;
-
-      omx_bitstream_ctx()
-      {
-        length_size = 0;
-        first_idr = 0;
-        sps_pps_data = NULL;
-        size = 0;
-      }
-
-  } omx_bitstream_ctx;
-
-  uint32_t          m_sps_pps_size;
-  omx_bitstream_ctx m_sps_pps_context;
-  bool              m_convert_bitstream;
+  OpenMaxVideoPtr m_omx_decoder;
 };
 
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
index 50dc8b7..b4ae0bb 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
@@ -16,7 +16,6 @@ SRCS += DVDVideoCodecVDA.cpp
 SRCS += VDA.cpp
 endif
 ifeq (@USE_OPENMAX@,1)
-SRCS += OpenMax.cpp
 SRCS += OpenMaxVideo.cpp
 SRCS += DVDVideoCodecOpenMax.cpp
 endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index dcbdb1e..3218b63 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -32,1019 +32,1068 @@
 #include "DVDVideoCodec.h"
 #include "utils/log.h"
 #include "utils/TimeUtils.h"
+#include "settings/Settings.h"
+#include "settings/MediaSettings.h"
 #include "ApplicationMessenger.h"
 #include "Application.h"
+#include "threads/Atomics.h"
+#include "guilib/GUIWindowManager.h"
+#include "cores/VideoRenderers/RenderFlags.h"
+#include "settings/DisplaySettings.h"
+#include "cores/VideoRenderers/RenderManager.h"
 
-#include <OMX_Core.h>
-#include <OMX_Component.h>
-#include <OMX_Index.h>
-#include <OMX_Image.h>
+#include "linux/RBP.h"
 
+#define DTS_QUEUE
 
-#define CLASSNAME "COpenMaxVideo"
+#ifdef _DEBUG
+#define OMX_DEBUG_VERBOSE
+#endif
 
-// TODO: These are Nvidia Tegra2 dependent, need to dynamiclly find the
-// right codec matched to video format.
-#define OMX_H264BASE_DECODER    "OMX.Nvidia.h264.decode"
-// OMX.Nvidia.h264ext.decode segfaults, not sure why.
-//#define OMX_H264MAIN_DECODER  "OMX.Nvidia.h264ext.decode"
-#define OMX_H264MAIN_DECODER    "OMX.Nvidia.h264.decode"
-#define OMX_H264HIGH_DECODER    "OMX.Nvidia.h264ext.decode"
-#define OMX_MPEG4_DECODER       "OMX.Nvidia.mp4.decode"
-#define OMX_MPEG4EXT_DECODER    "OMX.Nvidia.mp4ext.decode"
-#define OMX_MPEG2V_DECODER      "OMX.Nvidia.mpeg2v.decode"
-#define OMX_VC1_DECODER         "OMX.Nvidia.vc1.decode"
-
-// EGL extension functions
-static PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
-static PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR;
-#define GETEXTENSION(type, ext) \
-do \
-{ \
-    ext = (type) eglGetProcAddress(#ext); \
-    if (!ext) \
-    { \
-        CLog::Log(LOGERROR, "%s::%s - ERROR getting proc addr of " #ext "\n", CLASSNAME, __func__); \
-    } \
-} while (0);
-
-#define OMX_INIT_STRUCTURE(a) \
-  memset(&(a), 0, sizeof(a)); \
-  (a).nSize = sizeof(a); \
-  (a).nVersion.s.nVersionMajor = OMX_VERSION_MAJOR; \
-  (a).nVersion.s.nVersionMinor = OMX_VERSION_MINOR; \
-  (a).nVersion.s.nRevision = OMX_VERSION_REVISION; \
-  (a).nVersion.s.nStep = OMX_VERSION_STEP
+#define CLASSNAME "COpenMaxVideoBuffer"
 
+COpenMaxVideoBuffer::COpenMaxVideoBuffer(COpenMaxVideo *omv)
+    : m_omv(omv), m_refs(0)
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
+#endif
+  mmal_buffer = NULL;
+  width = 0;
+  height = 0;
+  index = 0;
+  m_aspect_ratio = 0.0f;
+  m_changed_count = 0;
+  dts = DVD_NOPTS_VALUE;
+}
 
-COpenMaxVideo::COpenMaxVideo()
+COpenMaxVideoBuffer::~COpenMaxVideoBuffer()
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
+#endif
+}
+
+
+COpenMaxVideoBuffer* COpenMaxVideoBuffer::Acquire()
 {
-  m_portChanging = false;
+  long count = AtomicIncrement(&m_refs);
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p (%p) ref:%ld", CLASSNAME, __func__, this, mmal_buffer, count);
+  #endif
+  (void)count;
+  return this;
+}
 
-  pthread_mutex_init(&m_omx_input_mutex, NULL);
+long COpenMaxVideoBuffer::Release()
+{
+  long count = AtomicDecrement(&m_refs);
+#if defined(OMX_DEBUG_VERBOSE)
+CLog::Log(LOGDEBUG, "%s::%s %p (%p) ref:%ld", CLASSNAME, __func__, this, mmal_buffer, count);
+#endif
+  if (count == 0)
+  {
+    m_omv->ReleaseOpenMaxBuffer(this);
+  }
+  return count;
+}
+
+#undef CLASSNAME
+#define CLASSNAME "COpenMaxVideo"
+
+COpenMaxVideo::COpenMaxVideo()
+{
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
+  #endif
   pthread_mutex_init(&m_omx_output_mutex, NULL);
 
-  m_omx_decoder_state_change = (sem_t*)malloc(sizeof(sem_t));
-  sem_init(m_omx_decoder_state_change, 0, 0);
-  memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
   m_drop_state = false;
   m_decoded_width = 0;
   m_decoded_height = 0;
-  m_omx_input_eos = false;
-  m_omx_input_port = 0;
-  m_omx_output_eos = false;
-  m_omx_output_port = 0;
-  m_videoplayback_done = false;
+
+  m_finished = false;
+  m_pFormatName = "mmal-xxxx";
+
+  //m_interlace_mode = MMAL_InterlaceProgressive;
+  m_startframe = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
+  m_droppedPics = 0;
+  m_decode_frame_number = 1;
+
+  m_dec = NULL;
+  m_dec_input = NULL;
+  m_dec_output = NULL;
+  m_dec_input_pool = NULL;
+  m_dec_output_pool = NULL;
+
+  m_deint = NULL;
+  m_deint_connection = NULL;
+
+  m_codingType = 0;
+
+  m_changed_count = 0;
+  m_changed_count_dec = 0;
+  m_omx_output_busy = 0;
+  m_es_format = mmal_format_alloc();
 }
 
 COpenMaxVideo::~COpenMaxVideo()
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
   #endif
-  if (m_is_open)
-    Close();
-  pthread_mutex_destroy(&m_omx_input_mutex);
+  assert(m_finished);
+  Reset();
+
   pthread_mutex_destroy(&m_omx_output_mutex);
-  sem_destroy(m_omx_decoder_state_change);
-  free(m_omx_decoder_state_change);
-}
 
-bool COpenMaxVideo::Open(CDVDStreamInfo &hints)
-{
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
-  #endif
+  if (m_deint && m_deint->control && m_deint->control->is_enabled)
+    mmal_port_disable(m_deint->control);
 
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  std::string decoder_name;
+  if (m_dec && m_dec->control && m_dec->control->is_enabled)
+    mmal_port_disable(m_dec->control);
 
-  m_decoded_width  = hints.width;
-  m_decoded_height = hints.height;
+  if (m_dec_input && m_dec_input->is_enabled)
+    mmal_port_disable(m_dec_input);
+  m_dec_input = NULL;
 
-  switch (hints.codec)
-  {
-    case AV_CODEC_ID_H264:
-    {
-      switch(hints.profile)
-      {
-        case FF_PROFILE_H264_BASELINE:
-          // (role name) video_decoder.avc
-          // H.264 Baseline profile
-          decoder_name = OMX_H264BASE_DECODER;
-        break;
-        case FF_PROFILE_H264_MAIN:
-          // (role name) video_decoder.avc
-          // H.264 Main profile
-          decoder_name = OMX_H264MAIN_DECODER;
-        break;
-        case FF_PROFILE_H264_HIGH:
-          // (role name) video_decoder.avc
-          // H.264 Main profile
-          decoder_name = OMX_H264HIGH_DECODER;
-        break;
-        default:
-          return false;
-        break;
-      }
-    }
-    break;
-    case AV_CODEC_ID_MPEG4:
-      // (role name) video_decoder.mpeg4
-      // MPEG-4, DivX 4/5 and Xvid compatible
-      decoder_name = OMX_MPEG4_DECODER;
-    break;
-    /*
-    TODO: what mpeg4 formats are "ext" ????
-    case NvxStreamType_MPEG4Ext:
-      // (role name) video_decoder.mpeg4
-      // MPEG-4, DivX 4/5 and Xvid compatible
-      decoder_name = OMX_MPEG4EXT_DECODER;
-      m_pFormatName = "omx-mpeg4";
-    break;
-    */
-    case AV_CODEC_ID_MPEG2VIDEO:
-      // (role name) video_decoder.mpeg2
-      // MPEG-2
-      decoder_name = OMX_MPEG2V_DECODER;
-    break;
-    case AV_CODEC_ID_VC1:
-      // (role name) video_decoder.vc1
-      // VC-1, WMV9
-      decoder_name = OMX_VC1_DECODER;
-    break;
-    default:
-      return false;
-    break;
-  }
+  if (m_dec_output && m_dec_output->is_enabled)
+    mmal_port_disable(m_dec_output);
+  m_dec_output = NULL;
 
-  // initialize OpenMAX.
-  if (!Initialize(decoder_name))
-  {
-    return false;
-  }
+  if (m_deint_connection)
+    mmal_connection_destroy(m_deint_connection);
+  m_deint_connection = NULL;
 
-  // TODO: Find component from role name.
-  // Get the port information. This will obtain information about the
-  // number of ports and index of the first port.
-  OMX_PORT_PARAM_TYPE port_param;
-  OMX_INIT_STRUCTURE(port_param);
-  omx_err = OMX_GetParameter(m_omx_decoder, OMX_IndexParamVideoInit, &port_param);
-  if (omx_err)
-  {
-    Deinitialize();
-    return false;
-  }
-  m_omx_input_port = port_param.nStartPortNumber;
-  m_omx_output_port = m_omx_input_port + 1;
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "%s::%s - decoder_component(0x%p), input_port(0x%x), output_port(0x%x)\n",
-    CLASSNAME, __func__, m_omx_decoder, m_omx_input_port, m_omx_output_port);
-  #endif
+  if (m_deint && m_deint->is_enabled)
+    mmal_component_disable(m_deint);
 
-  // TODO: Set role for the component because components could have multiple roles.
-  //QueryCodec();
+  if (m_dec && m_dec->is_enabled)
+      mmal_component_disable(m_dec);
 
-  // Component will be in OMX_StateLoaded now so we can alloc omx input/output buffers.
-  // we can only alloc them in OMX_StateLoaded state or if the component port is disabled
-  // Alloc buffers for the omx input port.
-  omx_err = AllocOMXInputBuffers();
-  if (omx_err)
-  {
-    Deinitialize();
-    return false;
-  }
-  // Alloc buffers for the omx output port.
-  m_egl_display = g_Windowing.GetEGLDisplay();
-  m_egl_context = g_Windowing.GetEGLContext();
-  omx_err = AllocOMXOutputBuffers();
-  if (omx_err)
-  {
-    FreeOMXInputBuffers(false);
-    Deinitialize();
-    return false;
-  }
+  if (m_dec_input_pool)
+    mmal_pool_destroy(m_dec_input_pool);
+  m_dec_input_pool = NULL;
 
-  m_is_open = true;
-  m_drop_state = false;
-  m_videoplayback_done = false;
+  if (m_dec_output_pool)
+    mmal_pool_destroy(m_dec_output_pool);
+  m_dec_output_pool = NULL;
 
-  // crank it up.
-  StartDecoder();
+  if (m_deint)
+    mmal_component_destroy(m_deint);
+  m_deint = NULL;
 
-  return true;
+  if (m_dec)
+    mmal_component_destroy(m_dec);
+  m_dec = NULL;
+  mmal_format_free(m_es_format);
+  m_es_format = NULL;
 }
 
-void COpenMaxVideo::Close()
+void COpenMaxVideo::PortSettingsChanged(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
-  #endif
-  if (m_omx_decoder)
+  MMAL_EVENT_FORMAT_CHANGED_T *fmt = mmal_event_format_changed_get(buffer);
+  mmal_format_copy(m_es_format, fmt->format);
+  m_changed_count++;
+
+  if (m_es_format->es->video.crop.width && m_es_format->es->video.crop.height)
   {
-    if (m_omx_decoder_state != OMX_StateLoaded)
-      StopDecoder();
-    Deinitialize();
+    if (m_es_format->es->video.par.num && m_es_format->es->video.par.den)
+      m_aspect_ratio = (float)(m_es_format->es->video.par.num * m_es_format->es->video.crop.width) / (m_es_format->es->video.par.den * m_es_format->es->video.crop.height);
+    m_decoded_width = m_es_format->es->video.crop.width;
+    m_decoded_height = m_es_format->es->video.crop.height;
+    CLog::Log(LOGDEBUG, "%s::%s format changed: %dx%d %.2f frame:%d", CLASSNAME, __func__, m_decoded_width, m_decoded_height, m_aspect_ratio, m_changed_count);
   }
-  m_is_open = false;
+  else
+    CLog::Log(LOGERROR, "%s::%s format changed: Unexpected %dx%d", CLASSNAME, __func__, m_es_format->es->video.crop.width, m_es_format->es->video.crop.height);
 }
 
-void COpenMaxVideo::SetDropState(bool bDrop)
+void COpenMaxVideo::dec_control_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
-  m_drop_state = bDrop;
+  MMAL_STATUS_T status;
 
-  if (m_drop_state)
+  if (buffer->cmd == MMAL_EVENT_ERROR)
+  {
+    status = (MMAL_STATUS_T)*(uint32_t *)buffer->data;
+    CLog::Log(LOGERROR, "%s::%s Error (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+  }
+  else if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED)
   {
-    OMX_ERRORTYPE omx_err;
+    CLog::Log(LOGDEBUG, "%s::%s format changed", CLASSNAME, __func__);
+    PortSettingsChanged(port, buffer);
+  }
+  else
+    CLog::Log(LOGERROR, "%s::%s other (cmd:%x data:%x)", CLASSNAME, __func__, buffer->cmd, *(uint32_t *)buffer->data);
 
-    // blow all but the last ready video frame
-    pthread_mutex_lock(&m_omx_output_mutex);
-    while (m_omx_output_ready.size() > 1)
-    {
-      m_dts_queue.pop();
-      OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_output_ready.front()->omx_buffer;
-      m_omx_output_ready.pop();
-      // return the omx buffer back to OpenMax to fill.
-      omx_err = OMX_FillThisBuffer(m_omx_decoder, omx_buffer);
-      if (omx_err)
-        CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer, omx_err(0x%x)\n",
-          CLASSNAME, __func__, omx_err);
-    }
-    pthread_mutex_unlock(&m_omx_output_mutex);
+  mmal_buffer_header_release(buffer);
+}
 
-    #if defined(OMX_DEBUG_VERBOSE)
-    CLog::Log(LOGDEBUG, "%s::%s - m_drop_state(%d)\n",
-      CLASSNAME, __func__, m_drop_state);
-    #endif
-  }
+static void dec_control_port_cb_static(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+{
+  COpenMaxVideo *omx = reinterpret_cast<COpenMaxVideo*>(port->userdata);
+  omx->dec_control_port_cb(port, buffer);
 }
 
-int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
+
+static void dec_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
-  if (pData)
-  {
-    int demuxer_bytes = iSize;
-    uint8_t *demuxer_content = pData;
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s port:%p buffer %p, len %d cmd:%x", CLASSNAME, __func__, port, buffer, buffer->length, buffer->cmd);
+#endif
+  mmal_buffer_header_release(buffer);
+}
 
-    // we need to queue then de-queue the demux packet, seems silly but
-    // omx might not have a omx input buffer avaliable when we are called
-    // and we must store the demuxer packet and try again later.
-    omx_demux_packet demux_packet;
-    demux_packet.dts = dts;
-    demux_packet.pts = pts;
 
-    demux_packet.size = demuxer_bytes;
-    demux_packet.buff = new OMX_U8[demuxer_bytes];
-    memcpy(demux_packet.buff, demuxer_content, demuxer_bytes);
-    m_demux_queue.push(demux_packet);
+void COpenMaxVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  if (!(buffer->cmd == 0 && buffer->length > 0))
+    CLog::Log(LOGDEBUG, "%s::%s port:%p buffer %p, len %d cmd:%x", CLASSNAME, __func__, port, buffer, buffer->length, buffer->cmd);
+#endif
+  bool kept = false;
 
-    // we can look at m_omx_input_avaliable.empty without needing to lock/unlock
-    // try to send any/all demux packets to omx decoder.
-    while (!m_omx_input_avaliable.empty() && !m_demux_queue.empty() )
+  if (buffer->cmd == 0)
+  {
+    if (buffer->length > 0)
     {
-      OMX_ERRORTYPE omx_err;
-      OMX_BUFFERHEADERTYPE* omx_buffer;
-
-      demux_packet = m_demux_queue.front();
-      m_demux_queue.pop();
-      // need to lock here to retreve an input buffer and pop the queue
-      pthread_mutex_lock(&m_omx_input_mutex);
-      omx_buffer = m_omx_input_avaliable.front();
-      m_omx_input_avaliable.pop();
-      pthread_mutex_unlock(&m_omx_input_mutex);
-
-      // delete the previous demuxer buffer
-      delete [] omx_buffer->pBuffer;
-      // setup a new omx_buffer.
-      omx_buffer->nFlags  = m_omx_input_eos ? OMX_BUFFERFLAG_EOS : 0;
-      omx_buffer->nOffset = 0;
-      omx_buffer->pBuffer = demux_packet.buff;
-      omx_buffer->nAllocLen  = demux_packet.size;
-      omx_buffer->nFilledLen = demux_packet.size;
-      omx_buffer->nTimeStamp = (demux_packet.pts == DVD_NOPTS_VALUE) ? 0 : demux_packet.pts * 1000.0; // in microseconds;
-      omx_buffer->pAppPrivate = omx_buffer;
-      omx_buffer->nInputPortIndex = m_omx_input_port;
-
-      #if defined(OMX_DEBUG_EMPTYBUFFERDONE)
-      CLog::Log(LOGDEBUG,
-        "%s::%s - feeding decoder, omx_buffer->pBuffer(0x%p), demuxer_bytes(%d)\n",
-        CLASSNAME, __func__, omx_buffer->pBuffer, demuxer_bytes);
-      #endif
-      // Give this omx_buffer to OpenMax to be decoded.
-      omx_err = OMX_EmptyThisBuffer(m_omx_decoder, omx_buffer);
-      if (omx_err)
+      assert(!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_DECODEONLY));
+      double dts = DVD_NOPTS_VALUE;
+      #ifdef DTS_QUEUE
+      pthread_mutex_lock(&m_omx_output_mutex);
+      if (!m_dts_queue.empty())
       {
-        CLog::Log(LOGDEBUG,
-          "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)\n",
-          CLASSNAME, __func__, omx_err);
-        return VC_ERROR;
+        dts = m_dts_queue.front();
+        m_dts_queue.pop();
       }
-      // only push if we are successful with feeding OMX_EmptyThisBuffer
-      m_dts_queue.push(demux_packet.dts);
+      else assert(0);
+      pthread_mutex_unlock(&m_omx_output_mutex);
+      #endif
 
-      // if m_omx_input_avaliable and/or demux_queue are now empty,
-      // wait up to 20ms for OpenMax to consume a demux packet
-      if (m_omx_input_avaliable.empty() || m_demux_queue.empty())
-        m_input_consumed_event.WaitMSec(1);
+      if (m_drop_state)
+      {
+        CLog::Log(LOGDEBUG, "%s::%s - dropping %p (drop:%d)", CLASSNAME, __func__, buffer, m_drop_state);
+      }
+      else
+      {
+        COpenMaxVideoBuffer *omvb = new COpenMaxVideoBuffer(this);
+        m_omx_output_busy++;
+#if defined(OMX_DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, "%s::%s - %p (%p) buffer_size(%u) dts:%.3f pts:%.3f flags:%x:%x frame:%d",
+        CLASSNAME, __func__, buffer, omvb, buffer->length, dts*1e-6, buffer->pts*1e-6, buffer->flags, buffer->type->video.flags, omvb->m_changed_count);
+#endif
+        omvb->mmal_buffer = buffer;
+        buffer->user_data = (void *)omvb;
+        omvb->m_changed_count = m_changed_count;
+        omvb->dts = dts;
+        omvb->width = m_decoded_width;
+        omvb->height = m_decoded_height;
+        omvb->m_aspect_ratio = m_aspect_ratio;
+        pthread_mutex_lock(&m_omx_output_mutex);
+        m_omx_output_ready.push(omvb);
+        pthread_mutex_unlock(&m_omx_output_mutex);
+        kept = true;
+      }
     }
-    if (m_omx_input_avaliable.empty() && !m_demux_queue.empty())
-      m_input_consumed_event.WaitMSec(1);
-
-    #if defined(OMX_DEBUG_VERBOSE)
-    if (m_omx_input_avaliable.empty())
-      CLog::Log(LOGDEBUG,
-        "%s::%s - buffering demux, m_demux_queue_size(%d), demuxer_bytes(%d)\n",
-        CLASSNAME, __func__, m_demux_queue.size(), demuxer_bytes);
-    #endif
   }
-
-  if (m_omx_output_ready.empty())
-    return VC_BUFFER;
-
-  return VC_PICTURE | VC_BUFFER;
-}
-
-void COpenMaxVideo::Reset(void)
-{
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
-  #endif
-/*
-  // only reset OpenMax decoder if it's running
-  if (m_omx_decoder_state == OMX_StateExecuting)
+  else if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED)
   {
-    OMX_ERRORTYPE omx_err;
-
-    omx_err = StopDecoder();
-    // Alloc OpenMax input buffers.
-    omx_err = AllocOMXInputBuffers();
-    // Alloc OpenMax output buffers.
-    omx_err = AllocOMXOutputBuffers();
-
-    omx_err = StartDecoder();
+    PortSettingsChanged(port, buffer);
   }
-*/
-  ::Sleep(100);
+  if (!kept)
+    mmal_buffer_header_release(buffer);
 }
 
-bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+static void dec_output_port_cb_static(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
-  while (m_omx_output_busy.size() > 1)
-  {
-    // fetch a output buffer and pop it off the busy list
-    pthread_mutex_lock(&m_omx_output_mutex);
-    OpenMaxVideoBuffer *buffer = m_omx_output_busy.front();
-    m_omx_output_busy.pop();
-    pthread_mutex_unlock(&m_omx_output_mutex);
+  COpenMaxVideo *omx = reinterpret_cast<COpenMaxVideo*>(port->userdata);
+  omx->dec_output_port_cb(port, buffer);
+}
 
-    bool done = buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_EOS;
-    if (!done)
-    {
-      // return the omx buffer back to OpenMax to fill.
-      OMX_ERRORTYPE omx_err = OMX_FillThisBuffer(m_omx_decoder, buffer->omx_buffer);
-      if (omx_err)
-        CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer, omx_err(0x%x)\n",
-          CLASSNAME, __func__, omx_err);
-    }
-  }
+bool COpenMaxVideo::change_dec_output_format()
+{
+  MMAL_STATUS_T status;
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
 
-  if (!m_omx_output_ready.empty())
+#if 0
   {
-    OpenMaxVideoBuffer *buffer;
-    // fetch a output buffer and pop it off the ready list
-    pthread_mutex_lock(&m_omx_output_mutex);
-    buffer = m_omx_output_ready.front();
-    m_omx_output_ready.pop();
-    m_omx_output_busy.push(buffer);
-    pthread_mutex_unlock(&m_omx_output_mutex);
+  MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T interlace_type = {{ MMAL_PARAMETER_VIDEO_INTERLACE_TYPE, sizeof( interlace_type )}};
+  status = mmal_port_parameter_get( m_dec_output, &interlace_type.hdr );
 
-    pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
-    pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
-    pDvdVideoPicture->format = RENDER_FMT_OMXEGL;
-    pDvdVideoPicture->openMax = this;
-    pDvdVideoPicture->openMaxBuffer = buffer;
-
-    if (!m_dts_queue.empty())
+  if (status == MMAL_SUCCESS)
+  {
+    if (m_interlace_mode != interlace_type.eMode)
     {
-      pDvdVideoPicture->dts = m_dts_queue.front();
-      m_dts_queue.pop();
+      CLog::Log(LOGDEBUG, "%s::%s Interlace mode %d->%d", CLASSNAME, __func__, m_interlace_mode, interlace_type.eMode);
+      m_interlace_mode = interlace_type.eMode;
     }
-    // nTimeStamp is in microseconds
-    pDvdVideoPicture->pts = (buffer->omx_buffer->nTimeStamp == 0) ? DVD_NOPTS_VALUE : (double)buffer->omx_buffer->nTimeStamp / 1000.0;
   }
-  #if defined(OMX_DEBUG_VERBOSE)
   else
+    CLog::Log(LOGERROR, "%s::%s Failed to query interlace type on %s (status=%x %s)", CLASSNAME, __func__, m_dec_output->name, status, mmal_status_to_string(status));
+  }
+#endif
+  // todo: if we don't disable/enable we can do this from callback
+  mmal_format_copy(m_dec_output->format, m_es_format);
+  status = mmal_port_format_commit(m_dec_output);
+  if (status != MMAL_SUCCESS)
   {
-    CLog::Log(LOGDEBUG, "%s::%s - called but m_omx_output_ready is empty\n",
-      CLASSNAME, __func__);
+    CLog::Log(LOGERROR, "%s::%s Failed to commit decoder output port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
   }
-  #endif
-
-  pDvdVideoPicture->iFlags  = DVP_FLAG_ALLOCATED;
-  pDvdVideoPicture->iFlags |= m_drop_state ? DVP_FLAG_DROPPED : 0;
-
   return true;
 }
 
-
-// DecoderEmptyBufferDone -- OpenMax input buffer has been emptied
-OMX_ERRORTYPE COpenMaxVideo::DecoderEmptyBufferDone(
-  OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
-  OMX_BUFFERHEADERTYPE* pBuffer)
-{
-  COpenMaxVideo *ctx = static_cast<COpenMaxVideo*>(pAppData);
-/*
-  #if defined(OMX_DEBUG_EMPTYBUFFERDONE)
-  CLog::Log(LOGDEBUG, "%s::%s - buffer_size(%lu), timestamp(%f)\n",
-    CLASSNAME, __func__, pBuffer->nFilledLen, (double)pBuffer->nTimeStamp / 1000.0);
-  #endif
-*/
-  // queue free input buffer to avaliable list.
-  pthread_mutex_lock(&ctx->m_omx_input_mutex);
-  ctx->m_omx_input_avaliable.push(pBuffer);
-  ctx->m_input_consumed_event.Set();
-  pthread_mutex_unlock(&ctx->m_omx_input_mutex);
-
-  return OMX_ErrorNone;
-}
-
-// DecoderFillBufferDone -- OpenMax output buffer has been filled
-OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
-  OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
-  OMX_BUFFERHEADERTYPE* pBuffer)
+bool COpenMaxVideo::CreateDeinterlace()
 {
-  COpenMaxVideo *ctx = static_cast<COpenMaxVideo*>(pAppData);
-  OpenMaxVideoBuffer *buffer = (OpenMaxVideoBuffer*)pBuffer->pAppPrivate;
+  MMAL_STATUS_T status;
 
-  #if defined(OMX_DEBUG_FILLBUFFERDONE)
-  CLog::Log(LOGDEBUG, "%s::%s - buffer_size(%lu), timestamp(%f)\n",
-    CLASSNAME, __func__, pBuffer->nFilledLen, (double)pBuffer->nTimeStamp / 1000.0);
-  #endif
+  assert(!m_deint);
+  assert(m_dec_output == m_dec->output[0]);
 
-  if (!ctx->m_portChanging)
+  status = mmal_port_disable(m_dec_output);
+  if (status != MMAL_SUCCESS)
   {
-    // queue output omx buffer to ready list.
-    pthread_mutex_lock(&ctx->m_omx_output_mutex);
-    ctx->m_omx_output_ready.push(buffer);
-    pthread_mutex_unlock(&ctx->m_omx_output_mutex);
+    CLog::Log(LOGERROR, "%s::%s Failed to disable decoder output port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
   }
 
-  return OMX_ErrorNone;
-}
+  /* Create deinterlace filter */
+  status = mmal_component_create("vc.ril.image_fx", &m_deint);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to create deinterlace component (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+  MMAL_PARAMETER_IMAGEFX_PARAMETERS_T imfx_param = {{MMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS, sizeof(imfx_param)}, MMAL_PARAM_IMAGEFX_DEINTERLACE_FAST, 1, {3}};
+  status = mmal_port_parameter_set(m_deint->output[0], &imfx_param.hdr);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to set deinterlace parameters (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
 
-void COpenMaxVideo::QueryCodec(void)
-{
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_VIDEO_PARAM_PROFILELEVELTYPE port_param;
-  OMX_INIT_STRUCTURE(port_param);
+  MMAL_PORT_T *m_deint_input = m_deint->input[0];
+  m_deint_input->userdata = (struct MMAL_PORT_USERDATA_T *)this;
 
-  port_param.nPortIndex = m_omx_input_port;
+  // Now connect the decoder output port to deinterlace input port
+  status =  mmal_connection_create(&m_deint_connection, m_dec->output[0], m_deint->input[0], MMAL_CONNECTION_FLAG_TUNNELLING | MMAL_CONNECTION_FLAG_ALLOCATION_ON_INPUT);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to connect deinterlacer component %s (status=%x %s)", CLASSNAME, __func__, m_deint->name, status, mmal_status_to_string(status));
+    return false;
+  }
 
-  for (port_param.nProfileIndex = 0;; port_param.nProfileIndex++)
+  status =  mmal_connection_enable(m_deint_connection);
+  if (status != MMAL_SUCCESS)
   {
-    omx_err = OMX_GetParameter(m_omx_decoder,
-      OMX_IndexParamVideoProfileLevelQuerySupported, &port_param);
-    if (omx_err)
-      break;
+    CLog::Log(LOGERROR, "%s::%s Failed to enable connection %s (status=%x %s)", CLASSNAME, __func__, m_deint->name, status, mmal_status_to_string(status));
+    return false;
+  }
 
-    omx_codec_capability omx_capability;
-    omx_capability.level = port_param.eLevel;
-    omx_capability.profile = port_param.eProfile;
-    m_omx_decoder_capabilities.push_back(omx_capability);
+  mmal_format_copy(m_deint->output[0]->format, m_es_format);
+  status = mmal_port_format_commit(m_deint->output[0]);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to commit deint output format (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
   }
-}
 
-OMX_ERRORTYPE COpenMaxVideo::PrimeFillBuffers(void)
-{
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OpenMaxVideoBuffer *buffer;
+  status = mmal_component_enable(m_deint);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to enable deinterlacer component %s (status=%x %s)", CLASSNAME, __func__, m_deint->name, status, mmal_status_to_string(status));
+    return false;
+  }
 
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
-  #endif
-  // tell OpenMax to start filling output buffers
-  for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
+  m_deint->output[0]->buffer_size = m_deint->output[0]->buffer_size_min;
+  m_deint->output[0]->buffer_num = m_deint->output[0]->buffer_num_recommended;
+  m_deint->output[0]->userdata = (struct MMAL_PORT_USERDATA_T *)this;
+  status = mmal_port_enable(m_deint->output[0], dec_output_port_cb_static);
+  if (status != MMAL_SUCCESS)
   {
-    buffer = m_omx_output_buffers[i];
-    // always set the port index.
-    buffer->omx_buffer->nOutputPortIndex = m_omx_output_port;
-    // Need to clear the EOS flag.
-    buffer->omx_buffer->nFlags &= ~OMX_BUFFERFLAG_EOS;
-    buffer->omx_buffer->pAppPrivate = buffer;
-
-    omx_err = OMX_FillThisBuffer(m_omx_decoder, buffer->omx_buffer);
-    if (omx_err)
-      CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer failed with omx_err(0x%x)\n",
-        CLASSNAME, __func__, omx_err);
+    CLog::Log(LOGERROR, "%s::%s Failed to enable decoder output port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
   }
 
-  return omx_err;
+  m_dec_output = m_deint->output[0];
+
+  return true;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::AllocOMXInputBuffers(void)
+bool COpenMaxVideo::DestroyDeinterlace()
 {
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+  MMAL_STATUS_T status;
 
-  // Obtain the information about the decoder input port.
-  OMX_PARAM_PORTDEFINITIONTYPE port_format;
-  OMX_INIT_STRUCTURE(port_format);
-  port_format.nPortIndex = m_omx_input_port;
-  OMX_GetParameter(m_omx_decoder, OMX_IndexParamPortDefinition, &port_format);
+  assert(m_deint);
+  assert(m_dec_output == m_deint->output[0]);
 
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "%s::%s - iport(%d), nBufferCountMin(%lu), nBufferSize(%lu)\n",
-    CLASSNAME, __func__, m_omx_input_port, port_format.nBufferCountMin, port_format.nBufferSize);
-  #endif
-  for (size_t i = 0; i < port_format.nBufferCountMin; i++)
+  status = mmal_port_disable(m_dec_output);
+  if (status != MMAL_SUCCESS)
   {
-    OMX_BUFFERHEADERTYPE *buffer = NULL;
-    // use an external buffer that's sized according to actual demux
-    // packet size, start at internal's buffer size, will get deleted when
-    // we start pulling demuxer packets and using demux packet sized buffers.
-    OMX_U8* data = new OMX_U8[port_format.nBufferSize];
-    omx_err = OMX_UseBuffer(m_omx_decoder, &buffer, m_omx_input_port, NULL, port_format.nBufferSize, data);
-    if (omx_err)
-    {
-      CLog::Log(LOGERROR, "%s::%s - OMX_UseBuffer failed with omx_err(0x%x)\n",
-        CLASSNAME, __func__, omx_err);
-      return(omx_err);
-    }
-    m_omx_input_buffers.push_back(buffer);
-    // don't have to lock/unlock here, we are not decoding
-    m_omx_input_avaliable.push(buffer);
+    CLog::Log(LOGERROR, "%s::%s Failed to disable decoder output port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
   }
-  m_omx_input_eos = false;
 
-  return(omx_err);
-}
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXInputBuffers(bool wait)
-{
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-
-  /*
-  omx_err = OMX_SendCommand(m_omx_decoder, OMX_CommandFlush, m_omx_input_port, 0);
-  if (omx_err)
-    CLog::Log(LOGERROR, "%s::%s - OMX_CommandFlush failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-  else if (wait)
-    sem_wait(m_omx_flush_input);
-  */
-
-  // free omx input port buffers.
-  for (size_t i = 0; i < m_omx_input_buffers.size(); i++)
+  status = mmal_connection_destroy(m_deint_connection);
+  if (status != MMAL_SUCCESS)
   {
-    // using external buffers (OMX_UseBuffer), free our external buffers
-    //  before calling OMX_FreeBuffer which frees the omx buffer.
-    delete [] m_omx_input_buffers[i]->pBuffer;
-    m_omx_input_buffers[i]->pBuffer = NULL;
-    omx_err = OMX_FreeBuffer(m_omx_decoder, m_omx_input_port, m_omx_input_buffers[i]);
+    CLog::Log(LOGERROR, "%s::%s Failed to destroy deinterlace connection (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
   }
-  m_omx_input_buffers.clear();
+  m_deint_connection = NULL;
 
-  // empty input buffer queue. not decoding so don't need lock/unlock.
-  while (!m_omx_input_avaliable.empty())
-    m_omx_input_avaliable.pop();
-  while (!m_demux_queue.empty())
-    m_demux_queue.pop();
-  while (!m_dts_queue.empty())
-    m_dts_queue.pop();
+  status = mmal_component_disable(m_deint);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to disable deinterlace component (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
 
-  return(omx_err);
-}
+  status = mmal_component_destroy(m_deint);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to destroy deinterlace component (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+  m_deint = NULL;
 
-void COpenMaxVideo::CallbackAllocOMXEGLTextures(void *userdata)
-{
-  COpenMaxVideo *omx = static_cast<COpenMaxVideo*>(userdata);
-  omx->AllocOMXOutputEGLTextures();
-}
+  m_dec->output[0]->buffer_size = m_dec->output[0]->buffer_size_min;
+  m_dec->output[0]->buffer_num = m_dec->output[0]->buffer_num_recommended;
+  m_dec->output[0]->userdata = (struct MMAL_PORT_USERDATA_T *)this;
+  status = mmal_port_enable(m_dec->output[0], dec_output_port_cb_static);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to enable decoder output port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
 
-void COpenMaxVideo::CallbackFreeOMXEGLTextures(void *userdata)
-{
-  COpenMaxVideo *omx = static_cast<COpenMaxVideo*>(userdata);
-  omx->FreeOMXOutputEGLTextures(true);
+  m_dec_output = m_dec->output[0];
+  return true;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputBuffers(void)
+bool COpenMaxVideo::SendCodecConfigData()
 {
-  OMX_ERRORTYPE omx_err;
-
-  if ( g_application.IsCurrentThread() )
+  MMAL_STATUS_T status;
+  // send code config data
+  MMAL_BUFFER_HEADER_T *buffer = mmal_queue_timedwait(m_dec_input_pool->queue, 500);
+  if (!buffer)
   {
-    omx_err = AllocOMXOutputEGLTextures();
+    CLog::Log(LOGERROR, "%s::%s - mmal_queue_get failed", CLASSNAME, __func__);
+    return false;
   }
-  else
+
+  mmal_buffer_header_reset(buffer);
+  buffer->cmd = 0;
+  buffer->length = std::min(m_hints.extrasize, buffer->alloc_size);
+  memcpy(buffer->data, m_hints.extradata, buffer->length);
+  buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END | MMAL_BUFFER_HEADER_FLAG_CONFIG;
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d flags:%x", CLASSNAME, __func__, buffer, buffer->length, buffer->flags);
+#endif
+  status = mmal_port_send_buffer(m_dec_input, buffer);
+  if (status != MMAL_SUCCESS)
   {
-    ThreadMessageCallback callbackData;
-    callbackData.callback = &CallbackAllocOMXEGLTextures;
-    callbackData.userptr = (void *)this;
+    CLog::Log(LOGERROR, "%s::%s Failed send buffer to decoder input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
+  return true;
+}
 
-    ThreadMessage tMsg;
-    tMsg.dwMessage = TMSG_CALLBACK;
-    tMsg.lpVoid = (void*)&callbackData;
+bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenMaxVideoPtr myself)
+{
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s useomx:%d software:%d %dx%d", CLASSNAME, __func__, CSettings::Get().GetBool("videoplayer.useomx"), hints.software, hints.width, hints.height);
+  #endif
 
-    g_application.getApplicationMessenger().SendMessage(tMsg, true);
+  // we always qualify even if DVDFactoryCodec does this too.
+  if (!CSettings::Get().GetBool("videoplayer.useomx") || hints.software)
+    return false;
 
-    omx_err = OMX_ErrorNone;
-  }
+  m_hints = hints;
+  MMAL_STATUS_T status;
+  MMAL_PARAMETER_BOOLEAN_T error_concealment;
 
-  return omx_err;
-}
+  m_myself = myself;
+  m_decoded_width  = hints.width;
+  m_decoded_height = hints.height;
+  m_forced_aspect_ratio = hints.forced_aspect;
+  m_aspect_ratio = hints.aspect;
 
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputBuffers(bool wait)
-{
-  OMX_ERRORTYPE omx_err = FreeOMXOutputEGLTextures(wait);
+  switch (hints.codec)
+  {
+    case AV_CODEC_ID_H264:
+      // H.264
+      m_codingType = MMAL_ENCODING_H264;
+      m_pFormatName = "mmal-h264";
+    break;
+    case AV_CODEC_ID_H263:
+    case AV_CODEC_ID_MPEG4:
+      // MPEG-4, DivX 4/5 and Xvid compatible
+      m_codingType = MMAL_ENCODING_MP4V;
+      m_pFormatName = "mmal-mpeg4";
+    break;
+    case AV_CODEC_ID_MPEG1VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
+      // MPEG-2
+      m_codingType = MMAL_ENCODING_MP2V;
+      m_pFormatName = "mmal-mpeg2";
+    break;
+    case AV_CODEC_ID_VP6:
+      // this form is encoded upside down
+      // fall through
+    case AV_CODEC_ID_VP6F:
+    case AV_CODEC_ID_VP6A:
+      // VP6
+      m_codingType = MMAL_ENCODING_VP6;
+      m_pFormatName = "mmal-vp6";
+    break;
+    case AV_CODEC_ID_VP8:
+      // VP8
+      m_codingType = MMAL_ENCODING_VP8;
+      m_pFormatName = "mmal-vp8";
+    break;
+    case AV_CODEC_ID_THEORA:
+      // theora
+      m_codingType = MMAL_ENCODING_THEORA;
+      m_pFormatName = "mmal-theora";
+    break;
+    case AV_CODEC_ID_MJPEG:
+    case AV_CODEC_ID_MJPEGB:
+      // mjpg
+      m_codingType = MMAL_ENCODING_MJPEG;
+      m_pFormatName = "mmal-mjpg";
+    break;
+    case AV_CODEC_ID_VC1:
+    case AV_CODEC_ID_WMV3:
+      // VC-1, WMV9
+      m_codingType = MMAL_ENCODING_WVC1;
+      m_pFormatName = "mmal-vc1";
+      break;
+    default:
+      CLog::Log(LOGERROR, "%s::%s : Video codec unknown: %x", CLASSNAME, __func__, hints.codec);
+      return false;
+    break;
+  }
 
-  return omx_err;
-}
+  if ( (m_codingType == MMAL_ENCODING_MP2V && !g_RBP.GetCodecMpg2() ) ||
+       (m_codingType == MMAL_ENCODING_WVC1   && !g_RBP.GetCodecWvc1() ) )
+  {
+    CLog::Log(LOGWARNING, "%s::%s Codec %s is not supported", CLASSNAME, __func__, m_pFormatName);
+    return false;
+  }
 
-OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
-{
-  OMX_ERRORTYPE omx_err;
+  // initialize mmal.
+  status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &m_dec);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to create MMAL decoder component %s (status=%x %s)", CLASSNAME, __func__, MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, status, mmal_status_to_string(status));
+    return false;
+  }
 
-  if (!eglCreateImageKHR)
+  m_dec->control->userdata = (struct MMAL_PORT_USERDATA_T *)this;
+  status = mmal_port_enable(m_dec->control, dec_control_port_cb_static);
+  if (status != MMAL_SUCCESS)
   {
-    GETEXTENSION(PFNEGLCREATEIMAGEKHRPROC,  eglCreateImageKHR);
+    CLog::Log(LOGERROR, "%s::%s Failed to enable decoder control port %s (status=%x %s)", CLASSNAME, __func__, MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, status, mmal_status_to_string(status));
+    return false;
   }
 
-  EGLint attrib = EGL_NONE;
-  OpenMaxVideoBuffer *egl_buffer;
+  m_dec_input = m_dec->input[0];
 
-  // Obtain the information about the output port.
-  OMX_PARAM_PORTDEFINITIONTYPE port_format;
-  OMX_INIT_STRUCTURE(port_format);
-  port_format.nPortIndex = m_omx_output_port;
-  omx_err = OMX_GetParameter(m_omx_decoder, OMX_IndexParamPortDefinition, &port_format);
+  m_dec_input->format->type = MMAL_ES_TYPE_VIDEO;
+  m_dec_input->format->encoding = m_codingType;
+  if (m_hints.width && m_hints.height)
+  {
+    m_dec_input->format->es->video.crop.width = m_hints.width;
+    m_dec_input->format->es->video.crop.height = m_hints.height;
 
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "%s::%s (1) - oport(%d), nFrameWidth(%lu), nFrameHeight(%lu), nStride(%lx), nBufferCountMin(%lu), nBufferSize(%lu)\n",
-    CLASSNAME, __func__, m_omx_output_port,
-    port_format.format.video.nFrameWidth, port_format.format.video.nFrameHeight,port_format.format.video.nStride,
-    port_format.nBufferCountMin, port_format.nBufferSize);
-  #endif
+    m_dec_input->format->es->video.width = ALIGN_UP(m_hints.width, 32);
+    m_dec_input->format->es->video.height = ALIGN_UP(m_hints.height, 16);
+  }
+  m_dec_input->format->flags |= MMAL_ES_FORMAT_FLAG_FRAMED;
+
+  error_concealment.hdr.id = MMAL_PARAMETER_VIDEO_DECODE_ERROR_CONCEALMENT;
+  error_concealment.hdr.size = sizeof(MMAL_PARAMETER_BOOLEAN_T);
+  error_concealment.enable = MMAL_FALSE;
+  status = mmal_port_parameter_set(m_dec_input, &error_concealment.hdr);
+  if (status != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "%s::%s Failed to disable error concealment on %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
 
-  glActiveTexture(GL_TEXTURE0);
+  status = mmal_port_parameter_set_uint32(m_dec_input, MMAL_PARAMETER_EXTRA_BUFFERS, 5);
+  if (status != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "%s::%s Failed to enable extra buffers on %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
 
-  for (size_t i = 0; i < port_format.nBufferCountMin; i++)
+  status = mmal_port_format_commit(m_dec_input);
+  if (status != MMAL_SUCCESS)
   {
-    egl_buffer = new OpenMaxVideoBuffer;
-    memset(egl_buffer, 0, sizeof(*egl_buffer));
-    egl_buffer->width  = m_decoded_width;
-    egl_buffer->height = m_decoded_height;
-
-    glGenTextures(1, &egl_buffer->texture_id);
-    glBindTexture(GL_TEXTURE_2D, egl_buffer->texture_id);
-
-    // create space for buffer with a texture
-    glTexImage2D(
-      GL_TEXTURE_2D,      // target
-      0,                  // level
-      GL_RGBA,            // internal format
-      m_decoded_width,    // width
-      m_decoded_height,   // height
-      0,                  // border
-      GL_RGBA,            // format
-      GL_UNSIGNED_BYTE,   // type
-      NULL);              // pixels -- will be provided later
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-
-    // create EGLImage from texture
-    egl_buffer->egl_image = eglCreateImageKHR(
-      m_egl_display,
-      m_egl_context,
-      EGL_GL_TEXTURE_2D_KHR,
-      (EGLClientBuffer)(egl_buffer->texture_id),
-      &attrib);
-    if (!egl_buffer->egl_image)
-    {
-      CLog::Log(LOGERROR, "%s::%s - ERROR creating EglImage\n", CLASSNAME, __func__);
-      return(OMX_ErrorUndefined);
-    }
-    egl_buffer->index = i;
+    CLog::Log(LOGERROR, "%s::%s Failed to commit format for decoder input port %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
+    return false;
+  }
+  m_dec_input->buffer_size = m_dec_input->buffer_size_recommended;
+  m_dec_input->buffer_num = m_dec_input->buffer_num_recommended;
 
-    // tell decoder output port that it will be using EGLImage
-    omx_err = OMX_UseEGLImage(
-      m_omx_decoder, &egl_buffer->omx_buffer, m_omx_output_port, egl_buffer, egl_buffer->egl_image);
-    if (omx_err)
-    {
-      CLog::Log(LOGERROR, "%s::%s - OMX_UseEGLImage failed with omx_err(0x%x)\n",
-        CLASSNAME, __func__, omx_err);
-      return(omx_err);
-    }
-    m_omx_output_buffers.push_back(egl_buffer);
+  m_dec_input->userdata = (struct MMAL_PORT_USERDATA_T *)this;
+  status = mmal_port_enable(m_dec_input, dec_input_port_cb);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to enable decoder input port %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
+    return false;
+  }
+
+  m_dec_output = m_dec->output[0];
+
+  // set up initial decoded frame format - will likely change from this
+  m_dec_output->format->encoding = MMAL_ENCODING_OPAQUE;
+  mmal_format_copy(m_es_format, m_dec_output->format);
 
-    CLog::Log(LOGDEBUG, "%s::%s - Texture %p Width %d Height %d\n",
-      CLASSNAME, __func__, egl_buffer->egl_image, egl_buffer->width, egl_buffer->height);
+  status = mmal_port_format_commit(m_dec_output);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to commit decoder output format (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
   }
-  m_omx_output_eos = false;
-  while (!m_omx_output_busy.empty())
-    m_omx_output_busy.pop();
-  while (!m_omx_output_ready.empty())
-    m_omx_output_ready.pop();
 
-  return omx_err;
-}
+  m_dec_output->buffer_size = m_dec_output->buffer_size_min;
+  m_dec_output->buffer_num = m_dec_output->buffer_num_recommended;
+  m_dec_output->userdata = (struct MMAL_PORT_USERDATA_T *)this;
+  status = mmal_port_enable(m_dec_output, dec_output_port_cb_static);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to enable decoder output port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
+  }
 
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(bool wait)
-{
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OpenMaxVideoBuffer *egl_buffer;
+  status = mmal_component_enable(m_dec);
+  if (status != MMAL_SUCCESS)
+  {
+    CLog::Log(LOGERROR, "%s::%s Failed to enable decoder component %s (status=%x %s)", CLASSNAME, __func__, m_dec->name, status, mmal_status_to_string(status));
+    return false;
+  }
 
-  if (!eglDestroyImageKHR)
+  m_dec_input_pool = mmal_pool_create(m_dec_input->buffer_num, m_dec_input->buffer_size);
+  if (!m_dec_input_pool)
   {
-    GETEXTENSION(PFNEGLDESTROYIMAGEKHRPROC, eglDestroyImageKHR);
+    CLog::Log(LOGERROR, "%s::%s Failed to create pool for decoder input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
   }
 
-  for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
+  m_dec_output_pool = mmal_pool_create(m_dec_output->buffer_num, m_dec_output->buffer_size);
+  if(!m_dec_output_pool)
   {
-    egl_buffer = m_omx_output_buffers[i];
-    // tell decoder output port to stop using the EGLImage
-    omx_err = OMX_FreeBuffer(m_omx_decoder, m_omx_output_port, egl_buffer->omx_buffer);
-    // destroy egl_image
-    eglDestroyImageKHR(m_egl_display, egl_buffer->egl_image);
-    // free texture
-    glDeleteTextures(1, &egl_buffer->texture_id);
-    delete egl_buffer;
+    CLog::Log(LOGERROR, "%s::%s Failed to create pool for decode output port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
   }
-  m_omx_output_buffers.clear();
 
-  return omx_err;
-}
+  if (!SendCodecConfigData())
+    return false;
 
+  m_drop_state = false;
+  m_startframe = false;
 
-////////////////////////////////////////////////////////////////////////////////////////////
-// DecoderEventHandler -- OMX event callback
-OMX_ERRORTYPE COpenMaxVideo::DecoderEventHandler(
-  OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
-  OMX_EVENTTYPE eEvent,
-  OMX_U32 nData1,
-  OMX_U32 nData2,
-  OMX_PTR pEventData)
-{
-  OMX_ERRORTYPE omx_err;
-  COpenMaxVideo *ctx = static_cast<COpenMaxVideo*>(pAppData);
+  return true;
+}
 
-/*
+void COpenMaxVideo::Dispose()
+{
+  // we are happy to exit, but let last shared pointer being deleted trigger the destructor
+  bool done = false;
+  Reset();
+  pthread_mutex_lock(&m_omx_output_mutex);
+  if (!m_omx_output_busy)
+    done = true;
+  m_finished = true;
+  pthread_mutex_unlock(&m_omx_output_mutex);
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "COpenMax::%s - hComponent(0x%p), eEvent(0x%x), nData1(0x%lx), nData2(0x%lx), pEventData(0x%p)\n",
-    __func__, hComponent, eEvent, nData1, nData2, pEventData);
+  CLog::Log(LOGDEBUG, "%s::%s dts_queue(%d) ready_queue(%d) busy_queue(%d) done:%d", CLASSNAME, __func__, m_dts_queue.size(), m_omx_output_ready.size(), m_omx_output_busy, done);
   #endif
-*/
+  if (done)
+  {
+    assert(m_dts_queue.empty());
+    m_myself.reset();
+  }
+}
 
-  switch (eEvent)
+void COpenMaxVideo::SetDropState(bool bDrop)
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  if (m_drop_state != bDrop)
+    CLog::Log(LOGDEBUG, "%s::%s - m_drop_state(%d)", CLASSNAME, __func__, bDrop);
+#endif
+  m_drop_state = bDrop;
+  if (m_drop_state)
   {
-    case OMX_EventCmdComplete:
-      switch(nData1)
-      {
-        case OMX_CommandStateSet:
-          ctx->m_omx_decoder_state = (int)nData2;
-          switch (ctx->m_omx_decoder_state)
-          {
-            case OMX_StateInvalid:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateInvalid\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateLoaded:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateLoaded\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateIdle:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateIdle\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateExecuting:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateExecuting\n", CLASSNAME, __func__);
-            break;
-            case OMX_StatePause:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StatePause\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateWaitForResources:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateWaitForResources\n", CLASSNAME, __func__);
-            break;
-            default:
-              CLog::Log(LOGDEBUG,
-                "%s::%s - Unknown OMX_Statexxxxx, state(%d)\n",
-                CLASSNAME, __func__, ctx->m_omx_decoder_state);
-            break;
-          }
-          sem_post(ctx->m_omx_decoder_state_change);
-        break;
-        case OMX_CommandFlush:
-          /*
-          if (OMX_ALL == (int)nData2)
-          {
-            sem_post(ctx->m_omx_flush_input);
-            sem_post(ctx->m_omx_flush_output);
-            CLog::Log(LOGDEBUG, "COpenMax::%s - OMX_CommandFlush input/output\n",__func__);
-          }
-          else if (ctx->m_omx_input_port == (int)nData2)
-          {
-            sem_post(ctx->m_omx_flush_input);
-            CLog::Log(LOGDEBUG, "COpenMax::%s - OMX_CommandFlush input\n",__func__);
-          }
-          else if (ctx->m_omx_output_port == (int)nData2)
-          {
-            sem_post(ctx->m_omx_flush_output);
-            CLog::Log(LOGDEBUG, "COpenMax::%s - OMX_CommandFlush ouput\n",__func__);
-          }
-          else
-          */
-          {
-            #if defined(OMX_DEBUG_EVENTHANDLER)
-            CLog::Log(LOGDEBUG,
-              "%s::%s - OMX_CommandFlush, nData2(0x%lx)\n",
-              CLASSNAME, __func__, nData2);
-            #endif
-          }
-        break;
-        case OMX_CommandPortDisable:
-          #if defined(OMX_DEBUG_EVENTHANDLER)
-          CLog::Log(LOGDEBUG,
-            "%s::%s - OMX_CommandPortDisable, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-          #endif
-          if (ctx->m_omx_output_port == (int)nData2)
-          {
-            // Got OMX_CommandPortDisable event, alloc new buffers for the output port.
-            ctx->AllocOMXOutputBuffers();
-            omx_err = OMX_SendCommand(ctx->m_omx_decoder, OMX_CommandPortEnable, ctx->m_omx_output_port, NULL);
-          }
-        break;
-        case OMX_CommandPortEnable:
-          #if defined(OMX_DEBUG_EVENTHANDLER)
-          CLog::Log(LOGDEBUG,
-            "%s::%s - OMX_CommandPortEnable, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-          #endif
-          if (ctx->m_omx_output_port == (int)nData2)
-          {
-            // Got OMX_CommandPortEnable event.
-            // OMX_CommandPortDisable will have re-alloced new ones so re-prime
-            ctx->PrimeFillBuffers();
-          }
-          ctx->m_portChanging = false;
-        break;
-        #if defined(OMX_DEBUG_EVENTHANDLER)
-        case OMX_CommandMarkBuffer:
-          CLog::Log(LOGDEBUG,
-            "%s::%s - OMX_CommandMarkBuffer, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-        break;
-        #endif
-      }
-    break;
-    case OMX_EventBufferFlag:
-      if (ctx->m_omx_decoder == hComponent && (nData2 & OMX_BUFFERFLAG_EOS)) {
-        #if defined(OMX_DEBUG_EVENTHANDLER)
-        if(ctx->m_omx_input_port  == (int)nData1)
-            CLog::Log(LOGDEBUG, "%s::%s - OMX_EventBufferFlag(input)\n",
-            CLASSNAME, __func__);
-        #endif
-        if(ctx->m_omx_output_port == (int)nData1)
-        {
-            ctx->m_videoplayback_done = true;
-            #if defined(OMX_DEBUG_EVENTHANDLER)
-            CLog::Log(LOGDEBUG, "%s::%s - OMX_EventBufferFlag(output)\n",
-            CLASSNAME, __func__);
-            #endif
-        }
-      }
-    break;
-    case OMX_EventPortSettingsChanged:
-      #if defined(OMX_DEBUG_EVENTHANDLER)
-      CLog::Log(LOGDEBUG,
-        "%s::%s - OMX_EventPortSettingsChanged(output)\n", CLASSNAME, __func__);
-      #endif
-      // not sure nData2 is the input/output ports in this call, docs don't say
-      if (ctx->m_omx_output_port == (int)nData2)
+    while (1)
+    {
+      COpenMaxVideoBuffer *buffer = NULL;
+      pthread_mutex_lock(&m_omx_output_mutex);
+      // fetch a output buffer and pop it off the ready list
+      if (!m_omx_output_ready.empty())
       {
-        // free the current OpenMax output buffers, you must do this before sending
-        // OMX_CommandPortDisable to component as it expects output buffers
-        // to be freed before it will issue a OMX_CommandPortDisable event.
-        ctx->m_portChanging = true;
-        OMX_SendCommand(ctx->m_omx_decoder, OMX_CommandPortDisable, ctx->m_omx_output_port, NULL);
-        omx_err = ctx->FreeOMXOutputBuffers(false);
+        buffer = m_omx_output_ready.front();
+        m_omx_output_ready.pop();
       }
-    break;
-    #if defined(OMX_DEBUG_EVENTHANDLER)
-    case OMX_EventMark:
-      CLog::Log(LOGDEBUG, "%s::%s - OMX_EventMark\n", CLASSNAME, __func__);
-    break;
-    case OMX_EventResourcesAcquired:
-      CLog::Log(LOGDEBUG, "%s::%s - OMX_EventResourcesAcquired\n", CLASSNAME, __func__);
-    break;
-    #endif
-    case OMX_EventError:
-      switch((OMX_S32)nData1)
-      {
-        case OMX_ErrorInsufficientResources:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError, insufficient resources\n",
-            CLASSNAME, __func__);
-          // we are so frack'ed
-          //exit(0);
-        break;
-        case OMX_ErrorFormatNotDetected:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError, cannot parse input stream\n",
-            CLASSNAME, __func__);
-        break;
-        case OMX_ErrorPortUnpopulated:
-          // silently ignore these. We can get them when setting OMX_CommandPortDisable
-          // on the output port and the component flushes the output buffers.
-        break;
-        case OMX_ErrorStreamCorrupt:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError, Bitstream corrupt\n",
-            CLASSNAME, __func__);
-          ctx->m_videoplayback_done = true;
+      pthread_mutex_unlock(&m_omx_output_mutex);
+      if (buffer)
+        ReleaseOpenMaxBuffer(buffer);
+      else
         break;
-        default:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError detected, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-        break;
-      }
-      // do this so we don't hang on errors
-      /*
-      sem_post(ctx->m_omx_flush_input);
-      sem_post(ctx->m_omx_flush_output);
-      */
-      sem_post(ctx->m_omx_decoder_state_change);
-    break;
-    default:
-      CLog::Log(LOGWARNING,
-        "%s::%s - Unknown eEvent(0x%x), nData1(0x%lx), nData2(0x%lx)\n",
-        CLASSNAME, __func__, eEvent, nData1, nData2);
-    break;
+    }
   }
-
-  return OMX_ErrorNone;
 }
 
-// StartPlayback -- Kick off video playback.
-OMX_ERRORTYPE COpenMaxVideo::StartDecoder(void)
+int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
-  OMX_ERRORTYPE omx_err;
-
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  //CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d dts:%.3f pts:%.3f dts_queue(%d) ready_queue(%d) busy_queue(%d)",
+  //   CLASSNAME, __func__, pData, iSize, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, m_dts_queue.size(), m_omx_output_ready.size(), m_omx_output_busy);
   #endif
 
-  // transition decoder component to IDLE state
-  omx_err = SetStateForComponent(OMX_StateIdle);
-  if (omx_err)
+  unsigned int demuxer_bytes = 0;
+  uint8_t *demuxer_content = NULL;
+  MMAL_BUFFER_HEADER_T *buffer;
+  MMAL_STATUS_T status;
+
+  while (buffer = mmal_queue_get(m_dec_output_pool->queue), buffer)
+    Recycle(buffer);
+  // we need to queue then de-queue the demux packet, seems silly but
+  // omx might not have a omx input buffer available when we are called
+  // and we must store the demuxer packet and try again later.
+  // try to send any/all demux packets to omx decoder.
+  unsigned space = mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size;
+  if (pData && m_demux_queue.empty() && space >= (unsigned int)iSize)
   {
-    CLog::Log(LOGERROR, "%s::%s - setting OMX_StateIdle failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-    return omx_err;
+    demuxer_bytes = iSize;
+    demuxer_content = pData;
+  }
+  else if (pData && iSize)
+  {
+    omx_demux_packet demux_packet;
+    demux_packet.dts = dts;
+    demux_packet.pts = pts;
+    demux_packet.size = iSize;
+    demux_packet.buff = new uint8_t[iSize];
+    memcpy(demux_packet.buff, pData, iSize);
+    m_demux_queue.push(demux_packet);
   }
 
-  // transition decoder component to executing state
-  omx_err = SetStateForComponent(OMX_StateExecuting);
-  if (omx_err)
+  uint8_t *buffer_to_free = NULL;
+
+  while (1)
+  {
+     while (buffer = mmal_queue_get(m_dec_output_pool->queue), buffer)
+       Recycle(buffer);
+
+     space = mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size;
+     if (!demuxer_bytes && !m_demux_queue.empty())
+     {
+       omx_demux_packet &demux_packet = m_demux_queue.front();
+       if (space >= (unsigned int)demux_packet.size)
+       {
+         // need to lock here to retrieve an input buffer and pop the queue
+         m_demux_queue.pop();
+         demuxer_bytes = (unsigned int)demux_packet.size;
+         demuxer_content = demux_packet.buff;
+         buffer_to_free = demux_packet.buff;
+         dts = demux_packet.dts;
+         pts = demux_packet.pts;
+       }
+     }
+     if (demuxer_content)
+     {
+       // 500ms timeout
+       buffer = mmal_queue_timedwait(m_dec_input_pool->queue, 500);
+       if (!buffer)
+       {
+         CLog::Log(LOGERROR, "%s::%s - mmal_queue_get failed", CLASSNAME, __func__);
+         return VC_ERROR;
+       }
+
+       mmal_buffer_header_reset(buffer);
+       buffer->cmd = 0;
+       if (m_startframe && pts == DVD_NOPTS_VALUE)
+         pts = 0;
+       buffer->pts = pts == DVD_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : pts;
+       buffer->dts = dts == DVD_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : dts;
+       buffer->length = demuxer_bytes > buffer->alloc_size ? buffer->alloc_size : demuxer_bytes;
+       buffer->user_data = (void *)m_decode_frame_number;
+
+       // Request decode only (maintain ref frames, but don't return a picture)
+       if (m_drop_state)
+         buffer->flags |= MMAL_BUFFER_HEADER_FLAG_DECODEONLY;
+
+       memcpy(buffer->data, demuxer_content, buffer->length);
+       demuxer_bytes   -= buffer->length;
+       demuxer_content += buffer->length;
+
+       if (demuxer_bytes == 0)
+         buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
+
+       #if defined(OMX_DEBUG_VERBOSE)
+       CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d/%-6d dts:%.3f pts:%.3f flags:%x dts_queue(%d) ready_queue(%d) busy_queue(%d)",
+          CLASSNAME, __func__, buffer, iSize-demuxer_bytes, iSize, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, buffer->flags, m_dts_queue.size(), m_omx_output_ready.size(), m_omx_output_busy);
+       #endif
+       status = mmal_port_send_buffer(m_dec_input, buffer);
+       if (status != MMAL_SUCCESS)
+       {
+         CLog::Log(LOGERROR, "%s::%s Failed send buffer to decoder input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+         return VC_ERROR;
+       }
+
+       if (demuxer_bytes == 0)
+       {
+         m_decode_frame_number++;
+         m_startframe = true;
+  #ifdef DTS_QUEUE
+         if (m_drop_state)
+         {
+           m_droppedPics += m_deint ? 2:1;
+         }
+         else
+         {
+           // only push if we are successful with feeding OMX_EmptyThisBuffer
+           pthread_mutex_lock(&m_omx_output_mutex);
+           m_dts_queue.push(dts);
+           if (m_deint)
+             m_dts_queue.push(DVD_NOPTS_VALUE);
+           //assert(m_dts_queue.size() < 5000);
+           pthread_mutex_unlock(&m_omx_output_mutex);
+         }
+  #endif
+         if (m_changed_count_dec != m_changed_count)
+         {
+           CLog::Log(LOGDEBUG, "%s::%s format changed frame:%d(%d)", CLASSNAME, __func__, m_changed_count_dec, m_changed_count);
+           m_changed_count_dec = m_changed_count;
+           if (!change_dec_output_format())
+           {
+             CLog::Log(LOGERROR, "%s::%s - change_dec_output_format() failed", CLASSNAME, __func__);
+             return VC_ERROR;
+           }
+         }
+         EDEINTERLACEMODE deinterlace_request = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+#if 0
+         {
+           bool deinterlace = m_interlace_mode != MMAL_InterlaceProgressive;
+
+           if (deinterlace_request == VS_DEINTERLACEMODE_OFF)
+             deinterlace = false;
+           else if (deinterlace_request == VS_DEINTERLACEMODE_FORCE)
+             deinterlace = true;
+
+           if (!deinterlace && m_deint)
+             DestroyDeinterlace();
+           else if (deinterlace && !m_deint)
+             CreateDeinterlace();
+         }
+#endif
+         if (buffer_to_free)
+         {
+           delete [] buffer_to_free;
+           buffer_to_free = NULL;
+           demuxer_content = NULL;
+           continue;
+         }
+         while (buffer = mmal_queue_get(m_dec_output_pool->queue), buffer)
+           Recycle(buffer);
+       }
+    }
+    if (!demuxer_bytes)
+      break;
+  }
+  int ret = 0;
+  if (!m_omx_output_ready.empty())
+  {
+    #if defined(OMX_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s -  got output picture:%d", CLASSNAME, __func__, m_omx_output_ready.size());
+    #endif
+    ret |= VC_PICTURE;
+  }
+  if (mmal_queue_length(m_dec_input_pool->queue) > 0)
   {
-    CLog::Log(LOGERROR, "%s::%s - setting OMX_StateExecuting failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-    return omx_err;
+    #if defined(OMX_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s - got space for output:%d", CLASSNAME, __func__, mmal_queue_length(m_dec_input_pool->queue));
+    #endif
+    ret |= VC_BUFFER;
   }
+  return ret;
+}
+
+void COpenMaxVideo::Reset(void)
+{
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  #endif
+
+  if (m_dec_input)
+    mmal_port_disable(m_dec_input);
+  if (m_deint_connection)
+    mmal_connection_disable(m_deint_connection);
+  if (m_dec_output)
+    mmal_port_disable(m_dec_output);
+  if (m_dec_input)
+    mmal_port_enable(m_dec_input, dec_input_port_cb);
+  if (m_deint_connection)
+    mmal_connection_enable(m_deint_connection);
+  if (m_dec_output)
+    mmal_port_enable(m_dec_output, dec_output_port_cb_static);
+
+  // blow all ready video frames
+  bool old_drop_state = m_drop_state;
+  SetDropState(true);
+#ifdef DTS_QUEUE
+  pthread_mutex_lock(&m_omx_output_mutex);
+  while(!m_dts_queue.empty())
+    m_dts_queue.pop();
+  while (!m_demux_queue.empty())
+    m_demux_queue.pop();
+  pthread_mutex_unlock(&m_omx_output_mutex);
+#endif
+  if (!old_drop_state)
+    SetDropState(false);
+
+  SendCodecConfigData();
+
+  m_startframe = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
+  m_droppedPics = 0;
+  m_decode_frame_number = 1;
+}
 
-  //prime the omx output buffers.
-  PrimeFillBuffers();
 
-  return omx_err;
+void COpenMaxVideo::ReturnOpenMaxBuffer(COpenMaxVideoBuffer *buffer)
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p (%d)", CLASSNAME, __func__, buffer, m_omx_output_busy);
+#endif
+
+  mmal_buffer_header_release(buffer->mmal_buffer);
 }
 
-// StopPlayback -- Stop video playback
-OMX_ERRORTYPE COpenMaxVideo::StopDecoder(void)
+void COpenMaxVideo::Recycle(MMAL_BUFFER_HEADER_T *buffer)
 {
-  OMX_ERRORTYPE omx_err;
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, buffer);
+#endif
 
+  MMAL_STATUS_T status;
+  mmal_buffer_header_reset(buffer);
+  buffer->cmd = 0;
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s Send buffer %p from pool to decoder output port %p dts_queue(%d) ready_queue(%d) busy_queue(%d)", CLASSNAME, __func__, buffer, m_dec_output,
+    m_dts_queue.size(), m_omx_output_ready.size(), m_omx_output_busy);
   #endif
-  // transition decoder component from executing to idle
-  omx_err = SetStateForComponent(OMX_StateIdle);
-  if (omx_err)
+  status = mmal_port_send_buffer(m_dec_output, buffer);
+  if (status != MMAL_SUCCESS)
   {
-    CLog::Log(LOGERROR, "%s::%s - setting OMX_StateIdle failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-    return omx_err;
+    CLog::Log(LOGERROR, "%s::%s - Failed send buffer to decoder output port (status=0%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return;
   }
+}
 
-  // we can free our allocated port buffers in OMX_StateIdle state.
-  // free OpenMax input buffers.
-  FreeOMXInputBuffers(true);
-  // free OpenMax output buffers.
-  FreeOMXOutputBuffers(true);
+void COpenMaxVideo::ReleaseOpenMaxBuffer(COpenMaxVideoBuffer *buffer)
+{
+  // remove from busy list
+  pthread_mutex_lock(&m_omx_output_mutex);
+  assert(m_omx_output_busy > 0);
+  m_omx_output_busy--;
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  ReturnOpenMaxBuffer(buffer);
+  bool done = false;
+  pthread_mutex_lock(&m_omx_output_mutex);
+  if (m_finished && !m_omx_output_busy)
+    done = true;
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  if (done)
+    m_myself.reset();
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p (%p) dts_queue(%d) ready_queue(%d) busy_queue(%d) done:%d", CLASSNAME, __func__, buffer, buffer->mmal_buffer, m_dts_queue.size(), m_omx_output_ready.size(), m_omx_output_busy, done);
+  #endif
+  delete buffer;
+}
 
-  // transition decoder component from idle to loaded
-  omx_err = SetStateForComponent(OMX_StateLoaded);
-  if (omx_err)
-    CLog::Log(LOGERROR,
-      "%s::%s - setting OMX_StateLoaded failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
+bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  //CLog::Log(LOGDEBUG, "%s::%s - m_omx_output_busy=%d m_omx_output_ready.size()=%d", CLASSNAME, __func__, m_omx_output_busy, m_omx_output_ready.size());
+  //CLog::Log(LOGDEBUG, "%s::%s -  full: buffers:%d", CLASSNAME, __func__, m_omx_output_ready.size());
 
-  return omx_err;
+  if (!m_omx_output_ready.empty())
+  {
+    COpenMaxVideoBuffer *buffer;
+    // fetch a output buffer and pop it off the ready list
+    pthread_mutex_lock(&m_omx_output_mutex);
+    buffer = m_omx_output_ready.front();
+    m_omx_output_ready.pop();
+    pthread_mutex_unlock(&m_omx_output_mutex);
+
+    assert(buffer->mmal_buffer);
+    memset(pDvdVideoPicture, 0, sizeof *pDvdVideoPicture);
+    pDvdVideoPicture->format = RENDER_FMT_OMXEGL;
+    pDvdVideoPicture->openMaxBuffer = buffer;
+    pDvdVideoPicture->color_range  = 0;
+    pDvdVideoPicture->color_matrix = 4;
+    pDvdVideoPicture->iWidth  = buffer->width ? buffer->width : m_decoded_width;
+    pDvdVideoPicture->iHeight = buffer->height ? buffer->height : m_decoded_height;
+    pDvdVideoPicture->iDisplayWidth  = pDvdVideoPicture->iWidth;
+    pDvdVideoPicture->iDisplayHeight = pDvdVideoPicture->iHeight;
+    //CLog::Log(LOGDEBUG, "%s::%s -  %dx%d %dx%d %dx%d %dx%d %d,%d %f,%f", CLASSNAME, __func__, pDvdVideoPicture->iWidth, pDvdVideoPicture->iHeight, pDvdVideoPicture->iDisplayWidth, pDvdVideoPicture->iDisplayHeight, m_decoded_width, m_decoded_height, buffer->width, buffer->height, m_forced_aspect_ratio, m_hints.forced_aspect, buffer->m_aspect_ratio, m_hints.aspect);
+
+    if (buffer->m_aspect_ratio > 0.0 && !m_forced_aspect_ratio)
+    {
+      pDvdVideoPicture->iDisplayWidth  = ((int)lrint(pDvdVideoPicture->iHeight * buffer->m_aspect_ratio)) & -3;
+      if (pDvdVideoPicture->iDisplayWidth > pDvdVideoPicture->iWidth)
+      {
+        pDvdVideoPicture->iDisplayWidth  = pDvdVideoPicture->iWidth;
+        pDvdVideoPicture->iDisplayHeight = ((int)lrint(pDvdVideoPicture->iWidth / buffer->m_aspect_ratio)) & -3;
+      }
+    }
+
+    // timestamp is in microseconds
+    pDvdVideoPicture->dts = buffer->dts;
+    pDvdVideoPicture->pts = buffer->mmal_buffer->pts == MMAL_TIME_UNKNOWN || buffer->mmal_buffer->pts == 0 ? DVD_NOPTS_VALUE : buffer->mmal_buffer->pts;
+
+    pDvdVideoPicture->openMaxBuffer->Acquire();
+    pDvdVideoPicture->iFlags  = DVP_FLAG_ALLOCATED;
+#if defined(OMX_DEBUG_VERBOSE)
+    CLog::Log(LOGINFO, "%s::%s dts:%.3f pts:%.3f flags:%x:%x openMaxBuffer:%p mmal_buffer:%p", CLASSNAME, __func__,
+        pDvdVideoPicture->dts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->dts*1e-6, pDvdVideoPicture->pts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->pts*1e-6,
+        pDvdVideoPicture->iFlags, buffer->mmal_buffer->flags, pDvdVideoPicture->openMaxBuffer, pDvdVideoPicture->openMaxBuffer->mmal_buffer);
+#endif
+    assert(!(buffer->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_DECODEONLY));
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "%s::%s - called but m_omx_output_ready is empty", CLASSNAME, __func__);
+    return false;
+  }
+
+  if (pDvdVideoPicture->pts != DVD_NOPTS_VALUE)
+    m_decoderPts = pDvdVideoPicture->pts;
+  else
+    m_decoderPts = pDvdVideoPicture->dts; // xxx is DVD_NOPTS_VALUE better?
+
+  return true;
+}
+
+bool COpenMaxVideo::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %p (%p)", CLASSNAME, __func__, pDvdVideoPicture->openMaxBuffer, pDvdVideoPicture->openMaxBuffer ? pDvdVideoPicture->openMaxBuffer->mmal_buffer : 0);
+#endif
+  if (pDvdVideoPicture->format == RENDER_FMT_OMXEGL)
+  {
+    pDvdVideoPicture->openMaxBuffer->Release();
+  }
+  memset(pDvdVideoPicture, 0, sizeof *pDvdVideoPicture);
+  return true;
+}
+
+bool COpenMaxVideo::GetCodecStats(double &pts, int &droppedPics)
+{
+  pts = m_decoderPts;
+  droppedPics = m_droppedPics;
+  m_droppedPics = 0;
+#if defined(OMX_DEBUG_VERBOSE)
+  //CLog::Log(LOGDEBUG, "%s::%s - pts:%.0f droppedPics:%d", CLASSNAME, __func__, pts, droppedPics);
+#endif
+  return true;
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index e06c41d..f931419 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -21,93 +21,136 @@
 
 #if defined(HAVE_LIBOPENMAX)
 
-#include "OpenMax.h"
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
+#include <interface/mmal/mmal.h>
+#include <interface/mmal/util/mmal_util.h>
+#include <interface/mmal/util/mmal_default_components.h>
+#include <interface/mmal/util/mmal_util_params.h>
+#include <interface/mmal/util/mmal_connection.h>
+#include <interface/mmal/mmal_parameters.h>
+
+#include "cores/dvdplayer/DVDStreamInfo.h"
+#include "DVDVideoCodec.h"
+#include "threads/Event.h"
+#include "xbmc/settings/VideoSettings.h"
+
+#include <queue>
+#include <semaphore.h>
+#include <boost/shared_ptr.hpp>
+#include "utils/StdString.h"
+#include "guilib/Geometry.h"
+#include "rendering/RenderSystem.h"
+
+class COpenMaxVideo;
+typedef boost::shared_ptr<COpenMaxVideo> OpenMaxVideoPtr;
 
 // an omx egl video frame
-typedef struct OpenMaxVideoBuffer {
-  OMX_BUFFERHEADERTYPE *omx_buffer;
+class COpenMaxVideoBuffer
+{
+public:
+  COpenMaxVideoBuffer(COpenMaxVideo *omv);
+  virtual ~COpenMaxVideoBuffer();
+
+  MMAL_BUFFER_HEADER_T *mmal_buffer;
   int width;
   int height;
+  float m_aspect_ratio;
   int index;
+  double dts;
+  uint32_t m_changed_count;
+  // reference counting
+  COpenMaxVideoBuffer* Acquire();
+  long                 Release();
+  COpenMaxVideo *m_omv;
+  long m_refs;
+private:
+};
 
-  // used for egl based rendering if active
-  EGLImageKHR egl_image;
-  GLuint texture_id;
-} OpenMaxVideoBuffer;
-
-class COpenMaxVideo : public COpenMax
+class COpenMaxVideo
 {
+  typedef struct omx_demux_packet {
+    uint8_t *buff;
+    int size;
+    double dts;
+    double pts;
+  } omx_demux_packet;
+
 public:
   COpenMaxVideo();
   virtual ~COpenMaxVideo();
 
   // Required overrides
-  bool Open(CDVDStreamInfo &hints);
-  void Close(void);
-  int  Decode(uint8_t *pData, int iSize, double dts, double pts);
-  void Reset(void);
-  bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
-  void SetDropState(bool bDrop);
-protected:
-  void QueryCodec(void);
-  OMX_ERRORTYPE PrimeFillBuffers(void);
-  OMX_ERRORTYPE AllocOMXInputBuffers(void);
-  OMX_ERRORTYPE FreeOMXInputBuffers(bool wait);
-  OMX_ERRORTYPE AllocOMXOutputBuffers(void);
-  OMX_ERRORTYPE FreeOMXOutputBuffers(bool wait);
-  static void CallbackAllocOMXEGLTextures(void*);
-  OMX_ERRORTYPE AllocOMXOutputEGLTextures(void);
-  static void CallbackFreeOMXEGLTextures(void*);
-  OMX_ERRORTYPE FreeOMXOutputEGLTextures(bool wait);
-
-  // TODO Those should move into the base class. After start actions can be executed by callbacks.
-  OMX_ERRORTYPE StartDecoder(void);
-  OMX_ERRORTYPE StopDecoder(void);
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenMaxVideoPtr myself);
+  virtual void Dispose(void);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual unsigned GetAllowedReferences() { return 2; }
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+  virtual bool GetCodecStats(double &pts, int &droppedPics);
 
   // OpenMax decoder callback routines.
-  virtual OMX_ERRORTYPE DecoderEventHandler(OMX_HANDLETYPE hComponent, OMX_PTR pAppData,
-    OMX_EVENTTYPE eEvent, OMX_U32 nData1, OMX_U32 nData2, OMX_PTR pEventData);
-  virtual OMX_ERRORTYPE DecoderEmptyBufferDone(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBuffer);
-  virtual OMX_ERRORTYPE DecoderFillBufferDone(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBufferHeader);
+  void ReleaseOpenMaxBuffer(COpenMaxVideoBuffer *buffer);
+  void Recycle(MMAL_BUFFER_HEADER_T *buffer);
+
+  // MMAL decoder callback routines.
+  void dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
+  void dec_control_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
+  uint32_t          m_changed_count;
+  uint32_t          m_changed_count_dec;
 
-  // EGL Resources
-  EGLDisplay        m_egl_display;
-  EGLContext        m_egl_context;
+protected:
+  void QueryCodec(void);
+  void ReturnOpenMaxBuffer(COpenMaxVideoBuffer *buffer);
+  bool CreateDeinterlace();
+  bool DestroyDeinterlace();
 
   // Video format
-  DVDVideoPicture   m_videobuffer;
   bool              m_drop_state;
   int               m_decoded_width;
   int               m_decoded_height;
+  unsigned int      m_egl_buffer_count;
+  bool              m_finished;
+  float             m_aspect_ratio;
+  bool              m_forced_aspect_ratio;
+  const char        *m_pFormatName;
+  OpenMaxVideoPtr   m_myself;
 
   std::queue<double> m_dts_queue;
   std::queue<omx_demux_packet> m_demux_queue;
 
-  // OpenMax input buffers (demuxer packets)
-  pthread_mutex_t   m_omx_input_mutex;
-  std::queue<OMX_BUFFERHEADERTYPE*> m_omx_input_avaliable;
-  std::vector<OMX_BUFFERHEADERTYPE*> m_omx_input_buffers;
-  bool              m_omx_input_eos;
-  int               m_omx_input_port;
-  //sem_t             *m_omx_flush_input;
-  CEvent            m_input_consumed_event;
-
   // OpenMax output buffers (video frames)
   pthread_mutex_t   m_omx_output_mutex;
-  std::queue<OpenMaxVideoBuffer*> m_omx_output_busy;
-  std::queue<OpenMaxVideoBuffer*> m_omx_output_ready;
-  std::vector<OpenMaxVideoBuffer*> m_omx_output_buffers;
-  bool              m_omx_output_eos;
-  int               m_omx_output_port;
-  //sem_t             *m_omx_flush_output;
-
-  bool              m_portChanging;
-
-  volatile bool     m_videoplayback_done;
+  int m_omx_output_busy;
+  std::queue<COpenMaxVideoBuffer*> m_omx_output_ready;
+  std::vector<COpenMaxVideoBuffer*> m_omx_output_buffers;
+
+  // initialize OpenMax and get decoder component
+  bool Initialize( const CStdString &decoder_name);
+  void PortSettingsChanged(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
+  bool SendCodecConfigData();
+
+  CDVDStreamInfo    m_hints;
+  // Components
+  //MMAL_INTERLACETYPE_T m_interlace_mode;
+  bool              m_startframe;
+  unsigned int      m_decode_frame_number;
+  double            m_decoderPts;
+  unsigned int      m_droppedPics;
+
+  MMAL_COMPONENT_T *m_dec;
+  MMAL_PORT_T *m_dec_input;
+  MMAL_PORT_T *m_dec_output;
+  MMAL_POOL_T *m_dec_input_pool;
+  MMAL_POOL_T *m_dec_output_pool;
+
+  MMAL_ES_FORMAT_T *m_es_format;
+  MMAL_COMPONENT_T *m_deint;
+  MMAL_CONNECTION_T *m_deint_connection;
+
+  MMAL_FOURCC_T m_codingType;
+  bool change_dec_output_format();
 };
 
 // defined(HAVE_LIBOPENMAX)
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 3bfa7f1..8b60288 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -194,7 +194,7 @@ bool CDVDPlayerVideo::OpenStream( CDVDStreamInfo &hint )
   if(hint.flags & AV_DISPOSITION_ATTACHED_PIC)
     return false;
 
-  CLog::Log(LOGNOTICE, "Creating video codec with codec id: %i", hint.codec);
+  CLog::Log(LOGNOTICE, "Creating video codec with codec id: %i %dx%d", hint.codec, hint.width, hint.height);
   CDVDVideoCodec* codec = CDVDFactoryCodec::CreateVideoCodec(hint, surfaces, formats);
   if(!codec)
   {

From 4bbd1790c53efb19d551d13e366cdd00242d06e1 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 12 Aug 2014 00:31:36 +0100
Subject: [PATCH 33/77] [omxcodec] Fix for stills with hardware codec


From 3e0e029ac15454d5a662f37ef875e8fc33a518cc Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 2 Aug 2014 17:47:38 +0100
Subject: [PATCH 34/77] [VideoReferenceClock] Add OMX support

---
 xbmc/linux/RBP.cpp                 | 34 ++++++++++++++++++++++++
 xbmc/linux/RBP.h                   |  3 +++
 xbmc/video/VideoReferenceClock.cpp | 53 ++++++++++++++++++++++++++++++++++++++
 xbmc/video/VideoReferenceClock.h   |  6 +++++
 4 files changed, 96 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 73a42c4..11376fc 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -32,6 +32,7 @@ CRBP::CRBP()
   m_omx_initialized = false;
   m_DllBcmHost      = new DllBcmHost();
   m_OMX             = new COMXCore();
+  m_element = 0;
 }
 
 CRBP::~CRBP()
@@ -53,6 +54,9 @@ bool CRBP::Initialize()
 
   m_DllBcmHost->bcm_host_init();
 
+  uint32_t                    vc_image_ptr;
+  m_resource = vc_dispmanx_resource_create( VC_IMAGE_RGB565, 1, 1, &vc_image_ptr );
+
   m_omx_initialized = m_OMX->Initialize();
   if(!m_omx_initialized)
     return false;
@@ -156,6 +160,36 @@ unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool sw
   return image;
 }
 
+void CRBP::WaitVsync(void)
+{
+  DISPMANX_DISPLAY_HANDLE_T display = vc_dispmanx_display_open( 0 /*screen*/ );
+  DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(0);
+
+  VC_DISPMANX_ALPHA_T alpha = { (DISPMANX_FLAGS_ALPHA_T)(DISPMANX_FLAGS_ALPHA_FROM_SOURCE | DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS), 120, /*alpha 0->255*/ 0 };
+  VC_RECT_T       src_rect;
+  VC_RECT_T       dst_rect;
+  vc_dispmanx_rect_set( &src_rect, 0, 0, 1 << 16, 1 << 16 );
+  vc_dispmanx_rect_set( &dst_rect, 0, 0, 1, 1 );
+
+  if (m_element)
+    vc_dispmanx_element_remove( update, m_element );
+
+  m_element = vc_dispmanx_element_add( update,
+                                            display,
+                                            2000,               // layer
+                                            &dst_rect,
+                                            m_resource,
+                                            &src_rect,
+                                            DISPMANX_PROTECTION_NONE,
+                                            &alpha,
+                                            NULL,             // clamp
+                                            (DISPMANX_TRANSFORM_T)0 );
+
+  vc_dispmanx_update_submit_sync(update);
+  vc_dispmanx_display_close( display );
+}
+
+
 void CRBP::Deinitialize()
 {
   if (m_omx_image_init)
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index e9a2d5a..4fd18f3 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -57,6 +57,7 @@ class CRBP
   // stride can be null for packed output
   unsigned char *CaptureDisplay(int width, int height, int *stride, bool swap_red_blue, bool video_only = true);
   DllOMX *GetDllOMX() { return m_OMX ? m_OMX->GetDll() : NULL; }
+  void WaitVsync();
 
 private:
   DllBcmHost *m_DllBcmHost;
@@ -69,6 +70,8 @@ class CRBP
   bool       m_codec_mpg2_enabled;
   bool       m_codec_wvc1_enabled;
   COMXCore   *m_OMX;
+  DISPMANX_RESOURCE_HANDLE_T m_resource;
+  DISPMANX_ELEMENT_HANDLE_T m_element;
   class DllLibOMXCore;
   CCriticalSection m_critSection;
 };
diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index 6d84b60..916a15c 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -50,6 +50,9 @@
   #endif
   #include "windowing/WindowingFactory.h"
   #include "settings/AdvancedSettings.h"
+#elif defined(TARGET_RASPBERRY_PI)
+  #include "guilib/GraphicContext.h"
+  #include "linux/RBP.h"
 #endif
 
 using namespace std;
@@ -177,6 +180,8 @@ void CVideoReferenceClock::Process()
     CLog::Log(LOGDEBUG, "CVideoReferenceClock: compiled without RandR support");
 #elif defined(TARGET_WINDOWS)
     CLog::Log(LOGDEBUG, "CVideoReferenceClock: only available on directx build");
+#elif defined(TARGET_RASPBERRY_PI)
+    SetupSuccess = SetupOMX();
 #else
     CLog::Log(LOGDEBUG, "CVideoReferenceClock: no implementation available");
 #endif
@@ -205,6 +210,8 @@ void CVideoReferenceClock::Process()
       RunD3D();
 #elif defined(TARGET_DARWIN)
       RunCocoa();
+#elif defined(TARGET_RASPBERRY_PI)
+      RunOMX();
 #endif
 
     }
@@ -237,6 +244,8 @@ void CVideoReferenceClock::Process()
     CleanupD3D();
 #elif defined(TARGET_DARWIN)
     CleanupCocoa();
+#elif defined(TARGET_RASPBERRY_PI)
+    CleanupOMX();
 #endif
     if (!SetupSuccess) break;
   }
@@ -863,6 +872,50 @@ void CVideoReferenceClock::VblankHandler(int64_t nowtime, double fps)
   SendVblankSignal();
   UpdateRefreshrate();
 }
+#elif defined(TARGET_RASPBERRY_PI)
+bool CVideoReferenceClock::SetupOMX()
+{
+  CLog::Log(LOGDEBUG, "CVideoReferenceClock: setting up OMX");
+
+  //init the vblank timestamp
+  m_MissedVblanks = 0;
+  m_RefreshRate = g_graphicsContext.GetFPS();
+
+  UpdateRefreshrate(true);
+  return true;
+}
+
+void CVideoReferenceClock::RunOMX()
+{
+  CSingleLock SingleLock(m_CritSection);
+  SingleLock.Leave();
+
+  while(!m_bStop)
+  {
+    g_RBP.WaitVsync();
+
+    m_RefreshRate = g_graphicsContext.GetFPS();
+    CLog::Log(LOGDEBUG, "CVideoReferenceClock:%s fps:%.2f missed:%d Time:%.3f", __func__, m_RefreshRate, m_TotalMissedVblanks, m_CurrTime * 1e-6);
+    //update the vblank timestamp, update the clock and send a signal that we got a vblank
+    SingleLock.Enter();
+    m_VblankTime = CurrentHostCounter();
+    UpdateClock(1, true);
+    SingleLock.Leave();
+    SendVblankSignal();
+
+    if (UpdateRefreshrate())
+    {
+      //we have to measure the refreshrate again
+      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Displaymode changed");
+      return;
+    }
+  }
+}
+
+void CVideoReferenceClock::CleanupOMX()
+{
+  CLog::Log(LOGDEBUG, "CVideoReferenceClock: cleaning up OMX");
+}
 #endif
 
 //this is called from the vblank run function and from CVideoReferenceClock::Wait in case of a late update
diff --git a/xbmc/video/VideoReferenceClock.h b/xbmc/video/VideoReferenceClock.h
index 6027031..2dabac1 100644
--- a/xbmc/video/VideoReferenceClock.h
+++ b/xbmc/video/VideoReferenceClock.h
@@ -150,6 +150,12 @@ class CVideoReferenceClock : public CThread
 
     int64_t m_LastVBlankTime;  //timestamp of the last vblank, used for calculating how many vblanks happened
                                //not the same as m_VblankTime
+#elif defined(TARGET_RASPBERRY_PI)
+    bool SetupOMX();
+    void RunOMX();
+    void CleanupOMX();
+    int64_t m_LastVBlankTime;  //timestamp of the last vblank, used for calculating how many vblanks happened
+                               //not the same as m_VblankTime
 #endif
 };
 

From 368010b61ed9b84fd9ad667cbae70f1f418ca016 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 12 Aug 2014 00:03:18 +0100
Subject: [PATCH 35/77] videoreferenceclock: Boost priority

---
 xbmc/video/VideoReferenceClock.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index 916a15c..c491d29 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -157,6 +157,9 @@ void CVideoReferenceClock::Process()
   bool SetupSuccess = false;
   int64_t Now;
 
+  /* This shouldn't be very busy and timing is important so increase priority */
+  SetPriority(GetPriority()+1);
+
 #if defined(TARGET_WINDOWS) && defined(HAS_DX)
   //register callback
   m_D3dCallback.Reset();

From 28cd39d1b3695fdd464e7a5b200817115be4e5b1 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 5 Feb 2014 11:46:33 +0000
Subject: [PATCH 36/77] [rbp/settings] Allow av sync type to be enabled

It works for dvdplayer
---
 system/settings/rbp.xml | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 28e68eb..60086d8 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -1,13 +1,6 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <settings>
   <section id="videos">
-    <category id="videoplayer">
-      <group id="2">
-        <setting id="videoplayer.synctype">
-          <visible>false</visible>
-        </setting>
-      </group>
-    </category>
     <category id="videoacceleration">
       <group id="1">
         <visible>false</visible>


From 162a1d6ee9b5603e6df798289d6843380e3a5cf0 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 16 Apr 2014 21:18:06 +0100
Subject: [PATCH 41/77] [omxplayer] Don't propagate 3d flags based on supported
 3d modes

---
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp | 29 ++++-------------------------
 1 file changed, 4 insertions(+), 25 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index 2c25fd9..c2bd788 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -759,36 +759,15 @@ void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height, f
   unsigned flags = 0;
   ERenderFormat format = RENDER_FMT_BYPASS;
 
+  /* figure out steremode expected based on user settings and hints */
+  unsigned int stereo_flags = GetStereoModeFlags(GetStereoMode());
+
   if(m_bAllowFullscreen)
   {
     flags |= CONF_FLAGS_FULLSCREEN;
     m_bAllowFullscreen = false; // only allow on first configure
   }
-
-  flags |= GetStereoModeFlags(GetStereoMode());
-
-  if(flags & CONF_FLAGS_STEREO_MODE_SBS)
-  {
-    if(g_Windowing.Support3D(video_width, video_height, D3DPRESENTFLAG_MODE3DSBS))
-      CLog::Log(LOGNOTICE, "3DSBS movie found");
-    else
-    {
-      flags &= ~CONF_FLAGS_STEREO_MODE_MASK(~0);
-      CLog::Log(LOGNOTICE, "3DSBS movie found but not supported");
-    }
-  }
-  else if(flags & CONF_FLAGS_STEREO_MODE_TAB)
-  {
-    if(g_Windowing.Support3D(video_width, video_height, D3DPRESENTFLAG_MODE3DTB))
-      CLog::Log(LOGNOTICE, "3DTB movie found");
-    else
-    {
-      flags &= ~CONF_FLAGS_STEREO_MODE_MASK(~0);
-      CLog::Log(LOGNOTICE, "3DTB movie found but not supported");
-    }
-  }
-  else
-    CLog::Log(LOGNOTICE, "not a 3D movie");
+  flags |= stereo_flags;
 
   unsigned int iDisplayWidth  = width;
   unsigned int iDisplayHeight = height;

From b4b030a3c528926f1a66c22e4a03a5a69aac5f94 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:00:52 +0100
Subject: [PATCH 42/77] [graphics] Don't set stereo mode based on resolution

The resolution change should follow stereo mode
---
 xbmc/guilib/GraphicContext.cpp | 35 +++++++++++++++++++----------------
 1 file changed, 19 insertions(+), 16 deletions(-)

diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 5bffdf5..4be1c8b 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -420,26 +420,29 @@ void CGraphicContext::SetVideoResolution(RESOLUTION res, bool forceUpdate)
   RESOLUTION_INFO info_org  = CDisplaySettings::Get().GetResolutionInfo(res);
   RESOLUTION_INFO info_last = CDisplaySettings::Get().GetResolutionInfo(lastRes);
 
-  RENDER_STEREO_MODE stereo_mode = m_stereoMode;
-
   // if the new mode is an actual stereo mode, switch to that
   // if the old mode was an actual stereo mode, switch to no 3d mode
-  if (info_org.dwFlags & D3DPRESENTFLAG_MODE3DTB)
-    stereo_mode = RENDER_STEREO_MODE_SPLIT_HORIZONTAL;
-  else if (info_org.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
-    stereo_mode = RENDER_STEREO_MODE_SPLIT_VERTICAL;
-  else if ((info_last.dwFlags & D3DPRESENTFLAG_MODE3DSBS) != 0
-        || (info_last.dwFlags & D3DPRESENTFLAG_MODE3DTB)  != 0)
-    stereo_mode = RENDER_STEREO_MODE_OFF;
-
-  if(stereo_mode != m_stereoMode)
+  // only do this if 3D flags have changed
+  if ((info_org.dwFlags ^ info_last.dwFlags) & (D3DPRESENTFLAG_MODE3DTB | D3DPRESENTFLAG_MODE3DSBS))
   {
-    m_stereoView     = RENDER_STEREO_VIEW_OFF;
-    m_stereoMode     = stereo_mode;
-    m_nextStereoMode = stereo_mode;
-    CSettings::Get().SetInt("videoscreen.stereoscopicmode", (int)m_stereoMode);
-  }
+    RENDER_STEREO_MODE stereo_mode = m_stereoMode;
+
+    if (info_org.dwFlags & D3DPRESENTFLAG_MODE3DTB)
+      stereo_mode = RENDER_STEREO_MODE_SPLIT_HORIZONTAL;
+    else if (info_org.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+      stereo_mode = RENDER_STEREO_MODE_SPLIT_VERTICAL;
+    else if ((info_last.dwFlags & D3DPRESENTFLAG_MODE3DSBS) != 0
+          || (info_last.dwFlags & D3DPRESENTFLAG_MODE3DTB)  != 0)
+      stereo_mode = RENDER_STEREO_MODE_OFF;
 
+    if(stereo_mode != m_stereoMode)
+    {
+      m_stereoView     = RENDER_STEREO_VIEW_OFF;
+      m_stereoMode     = stereo_mode;
+      m_nextStereoMode = stereo_mode;
+      CSettings::Get().SetInt("videoscreen.stereoscopicmode", (int)m_stereoMode);
+    }
+  }
   RESOLUTION_INFO info_mod = GetResInfo(res);
 
   m_iScreenWidth  = info_mod.iWidth;

From b0d51a841696f2a2ecc303ef5bd233f21d6d0f42 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:01:51 +0100
Subject: [PATCH 43/77] [graphics] Allow switching to a more suitable 3D
 resolution

---
 xbmc/guilib/GraphicContext.cpp | 40 +++++++++++++++++++++++++++++++++++++++-
 xbmc/guilib/GraphicContext.h   |  1 +
 2 files changed, 40 insertions(+), 1 deletion(-)

diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 4be1c8b..792a77d 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -35,6 +35,7 @@
 #include "utils/JobManager.h"
 #include "video/VideoReferenceClock.h"
 #include "cores/IPlayer.h"
+#include <float.h>
 
 using namespace std;
 
@@ -484,6 +485,43 @@ RESOLUTION CGraphicContext::GetVideoResolution() const
   return m_Resolution;
 }
 
+RESOLUTION CGraphicContext::Get3DVideoResolution(RESOLUTION resolution, RENDER_STEREO_MODE mode) const
+{
+  RESOLUTION best = resolution;
+  RESOLUTION_INFO curr = CDisplaySettings::Get().GetResolutionInfo(best);
+  // Find closest refresh rate
+  for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
+  {
+    const RESOLUTION_INFO info = CDisplaySettings::Get().GetResolutionInfo((RESOLUTION)i);
+
+    //discard resolutions that are not the same width and height (and interlaced/3D flags)
+    //or have a too low refreshrate
+    if (info.iScreenWidth  != curr.iScreenWidth
+    ||  info.iScreenHeight != curr.iScreenHeight
+    ||  info.iScreen       != curr.iScreen
+    ||  (info.dwFlags & D3DPRESENTFLAG_INTERLACED) != (curr.dwFlags & D3DPRESENTFLAG_INTERLACED)
+    ||  fabs(info.fRefreshRate - curr.fRefreshRate) >= FLT_EPSILON)
+      continue;
+
+    if (mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && info.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+    else if (mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && info.dwFlags & D3DPRESENTFLAG_MODE3DTB)
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+    else if ((mode == RENDER_STEREO_MODE_OFF || mode == RENDER_STEREO_MODE_MONO) && !(info.dwFlags & (D3DPRESENTFLAG_MODE3DSBS|D3DPRESENTFLAG_MODE3DTB)))
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+  }
+  return best;
+}
+
 void CGraphicContext::ResetOverscan(RESOLUTION_INFO &res)
 {
   res.Overscan.left = 0;
@@ -1021,7 +1059,7 @@ void CGraphicContext::Flip(const CDirtyRegionList& dirty)
   if(m_stereoMode != m_nextStereoMode)
   {
     m_stereoMode = m_nextStereoMode;
-    SetVideoResolution(GetVideoResolution(), true);
+    SetVideoResolution(Get3DVideoResolution(m_Resolution, m_stereoMode), true);
     g_windowManager.SendMessage(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_RENDERER_RESET);
   }
 }
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index 0a27643..ef5bc74 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -108,6 +108,7 @@ class CGraphicContext : public CCriticalSection,
   bool IsValidResolution(RESOLUTION res);
   void SetVideoResolution(RESOLUTION res, bool forceUpdate = false);
   RESOLUTION GetVideoResolution() const;
+  RESOLUTION Get3DVideoResolution(RESOLUTION resolution, RENDER_STEREO_MODE mode) const;
   void ResetOverscan(RESOLUTION res, OVERSCAN &overscan);
   void ResetOverscan(RESOLUTION_INFO &resinfo);
   void ResetScreenParameters(RESOLUTION res);

From 7278fb51a95d2f6d07cd4bca238d0a148887c5c3 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:38:55 +0100
Subject: [PATCH 44/77] [3D] Support switching to 3D resolutions

Include matching 3D flags (SBS/TAB) in the score of a resolution to switch to, to enable switching to 3d modes.
Also remove the old code that treated 3D modes differently when assigning a score.
---
 xbmc/cores/VideoRenderers/BaseRenderer.cpp | 47 +++++++++++-------------------
 1 file changed, 17 insertions(+), 30 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
index 83c3adb..8076e76 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
@@ -222,10 +222,14 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
 RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RESOLUTION current, float& weight)
 {
   RESOLUTION_INFO curr = g_graphicsContext.GetResInfo(current);
+  RENDER_STEREO_MODE stereo_mode = g_graphicsContext.GetStereoMode();
 
   float fRefreshRate = fps;
 
-  float last_diff = fRefreshRate;
+  int c_weight = MathUtils::round_int(RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
+  if (!(stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL) != !(curr.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ||
+      !(stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL) != !(curr.dwFlags & D3DPRESENTFLAG_MODE3DTB))
+    c_weight += 1000;
 
   // Find closest refresh rate
   for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
@@ -241,40 +245,23 @@ RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RES
     ||  info.fRefreshRate < (fRefreshRate * multiplier / 1.001) - 0.001)
       continue;
 
-    // For 3D choose the closest refresh rate 
-    if(CONF_FLAGS_STEREO_MODE_MASK(m_iFlags))
-    {
-      float diff = (info.fRefreshRate - fRefreshRate);
-      if(diff < 0)
-        diff *= -1.0f;
+    int i_weight = MathUtils::round_int(RefreshWeight(info.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
 
-      if(diff < last_diff)
-      {
-        last_diff = diff;
-        current = (RESOLUTION)i;
-        curr = info;
-      }
-    }
-    else
-    {
-      int c_weight = MathUtils::round_int(RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
-      int i_weight = MathUtils::round_int(RefreshWeight(info.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
+    if (!(stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL) != !(info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ||
+        !(stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL) != !(info.dwFlags & D3DPRESENTFLAG_MODE3DTB))
+      i_weight += 1000;
 
-      // Closer the better, prefer higher refresh rate if the same
-      if ((i_weight <  c_weight)
-      ||  (i_weight == c_weight && info.fRefreshRate > curr.fRefreshRate))
-      {
-        current = (RESOLUTION)i;
-        curr    = info;
-      }
+    // Closer the better, prefer higher refresh rate if the same
+    if ((i_weight <  c_weight)
+    ||  (i_weight == c_weight && info.fRefreshRate > curr.fRefreshRate))
+    {
+      current  = (RESOLUTION)i;
+      curr     = info;
+      c_weight = i_weight;
     }
   }
 
-  // For 3D overwrite weight
-  if(CONF_FLAGS_STEREO_MODE_MASK(m_iFlags))
-    weight = 0;
-  else
-    weight = RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier);
+  weight = RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier);
 
   return current;
 }

From d9820ca27cef34a9dc0025487290e36768f0fbd4 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 23 Apr 2014 00:05:07 +0100
Subject: [PATCH 45/77] [graphics] Make pixel ratio for 3d modes consistent

Note: Use the stored stereo flags from lists of resolutions.
Use current stereo mode for current resolution.
---
 xbmc/cores/VideoRenderers/BaseRenderer.cpp      | 10 +++----
 xbmc/guilib/GraphicContext.cpp                  | 37 ++++++++++++-------------
 xbmc/guilib/GraphicContext.h                    | 12 ++++++--
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  8 ------
 4 files changed, 32 insertions(+), 35 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
index 8076e76..9118cb0 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
@@ -119,7 +119,7 @@ bool CBaseRenderer::FindResolutionFromOverride(float fps, float& weight, bool fa
 
     for (size_t j = (int)RES_DESKTOP; j < CDisplaySettings::Get().ResolutionInfoSize(); j++)
     {
-      RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)j);
+      RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)j, g_graphicsContext.GetStereoMode((RESOLUTION)j));
 
       if (info.iScreenWidth  == curr.iScreenWidth
        && info.iScreenHeight == curr.iScreenHeight
@@ -179,7 +179,7 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
       //get the resolution with the refreshrate closest to 60 hertz
       for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
       {
-        RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+        RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, g_graphicsContext.GetStereoMode((RESOLUTION)i));
 
         if (MathUtils::round_int(info.fRefreshRate) == 60
          && info.iScreenWidth  == curr.iScreenWidth
@@ -200,7 +200,7 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
         CLog::Log(LOGDEBUG, "60 hertz refreshrate not available, choosing highest");
         for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
         {
-          RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+          RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, g_graphicsContext.GetStereoMode((RESOLUTION)i));
 
           if (info.fRefreshRate  >  curr.fRefreshRate
            && info.iScreenWidth  == curr.iScreenWidth
@@ -234,14 +234,14 @@ RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RES
   // Find closest refresh rate
   for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
   {
-    const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+    const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, g_graphicsContext.GetStereoMode((RESOLUTION)i));
 
     //discard resolutions that are not the same width and height (and interlaced/3D flags)
     //or have a too low refreshrate
     if (info.iScreenWidth  != curr.iScreenWidth
     ||  info.iScreenHeight != curr.iScreenHeight
     ||  info.iScreen       != curr.iScreen
-    ||  (info.dwFlags & D3DPRESENTFLAG_MODEMASK) != (curr.dwFlags & D3DPRESENTFLAG_MODEMASK)
+    ||  (info.dwFlags & D3DPRESENTFLAG_INTERLACED) != (curr.dwFlags & D3DPRESENTFLAG_INTERLACED)
     ||  info.fRefreshRate < (fRefreshRate * multiplier / 1.001) - 0.001)
       continue;
 
diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 792a77d..4890711 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -731,32 +731,33 @@ void CGraphicContext::ApplyStateBlock()
   g_Windowing.ApplyStateBlock();
 }
 
-const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res) const
+RENDER_STEREO_MODE CGraphicContext::GetStereoMode(RESOLUTION res) const
 {
   RESOLUTION_INFO info = CDisplaySettings::Get().GetResolutionInfo(res);
+  return (info.dwFlags & D3DPRESENTFLAG_MODE3DTB)  ? RENDER_STEREO_MODE_SPLIT_HORIZONTAL :
+         (info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ? RENDER_STEREO_MODE_SPLIT_VERTICAL : RENDER_STEREO_MODE_OFF;
+}
 
-  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res, RENDER_STEREO_MODE stereoMode) const
+{
+  RESOLUTION_INFO info = CDisplaySettings::Get().GetResolutionInfo(res);
+
+  if(stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
   {
-    if((info.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
-    {
-      info.fPixelRatio     /= 2;
-      info.iBlanking        = 0;
-      info.dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
-    }
+    info.fPixelRatio     /= 2;
+    info.iBlanking        = 0;
+    info.dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
     info.iHeight          = (info.iHeight         - info.iBlanking) / 2;
     info.Overscan.top    /= 2;
     info.Overscan.bottom  = (info.Overscan.bottom - info.iBlanking) / 2;
     info.iSubtitles       = (info.iSubtitles      - info.iBlanking) / 2;
   }
 
-  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+  if(stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
   {
-    if((info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
-    {
-      info.fPixelRatio     *= 2;
-      info.iBlanking        = 0;
-      info.dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
-    }
+    info.fPixelRatio     *= 2;
+    info.iBlanking        = 0;
+    info.dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
     info.iWidth           = (info.iWidth         - info.iBlanking) / 2;
     info.Overscan.left   /= 2;
     info.Overscan.right   = (info.Overscan.right - info.iBlanking) / 2;
@@ -774,16 +775,14 @@ void CGraphicContext::SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info)
   if(info.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
   {
     curr.Overscan.right  = info.Overscan.right  * 2 + info.iBlanking;
-    if((curr.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
-      curr.fPixelRatio  /= 2.0;
+    curr.fPixelRatio  /= 2.0;
   }
 
   if(info.dwFlags & D3DPRESENTFLAG_MODE3DTB)
   {
     curr.Overscan.bottom = info.Overscan.bottom * 2 + info.iBlanking;
     curr.iSubtitles      = info.iSubtitles      * 2 + info.iBlanking;
-    if((curr.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
-      curr.fPixelRatio  *= 2.0;
+    curr.fPixelRatio  *= 2.0;
   }
 }
 
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index ef5bc74..c665031 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -120,11 +120,15 @@ class CGraphicContext : public CCriticalSection,
   void GetAllowedResolutions(std::vector<RESOLUTION> &res);
 
   // output scaling
+  const RESOLUTION_INFO GetResInfo(RESOLUTION res) const
+  {
+    return GetResInfo(res, GetStereoMode());
+  }
   const RESOLUTION_INFO GetResInfo() const
   {
     return GetResInfo(m_Resolution);
   }
-  const RESOLUTION_INFO GetResInfo(RESOLUTION res) const;
+  const RESOLUTION_INFO GetResInfo(RESOLUTION res, RENDER_STEREO_MODE stereo_mode) const;
   void SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info);
 
   /* \brief Get UI scaling information from a given resolution to the screen resolution.
@@ -161,9 +165,11 @@ class CGraphicContext : public CCriticalSection,
   void RestoreOrigin();
   void SetCameraPosition(const CPoint &camera);
   void SetStereoView(RENDER_STEREO_VIEW view);
-  RENDER_STEREO_VIEW GetStereoView()  { return m_stereoView; }
+  RENDER_STEREO_VIEW GetStereoView() const { return m_stereoView; }
   void SetStereoMode(RENDER_STEREO_MODE mode) { m_nextStereoMode = mode; }
-  RENDER_STEREO_MODE GetStereoMode()  { return m_stereoMode; }
+  RENDER_STEREO_MODE GetStereoMode() const { return m_stereoMode; }
+  RENDER_STEREO_MODE GetStereoMode(RESOLUTION res) const;
+
   void RestoreCameraPosition();
   /*! \brief Set a region in which to clip all rendering
    Anything that is rendered after setting a clip region will be clipped so that no part renders
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index c58c28a..bf1e589 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -449,15 +449,9 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
       m_desktopRes.fPixelRatio  = get_display_aspect_ratio((HDMI_ASPECT_T)tv_state.display.hdmi.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
       // Also add 3D flags
       if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_SBS_HALF)
-      {
         m_desktopRes.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
-        m_desktopRes.fPixelRatio *= 2.0;
-      }
       else if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_TB_HALF)
-      {
         m_desktopRes.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
-        m_desktopRes.fPixelRatio *= 0.5;
-      }
       HDMI_PROPERTY_PARAM_T property;
       property.property = HDMI_PROPERTY_PIXEL_CLOCK_TYPE;
       vc_tv_hdmi_get_property(&property);
@@ -600,7 +594,6 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        res2.fPixelRatio   *= 2.0f;
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
 
         AddUniqueResolution(res2, resolutions);
@@ -616,7 +609,6 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        res2.fPixelRatio   *= 0.5f;
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
 
         AddUniqueResolution(res2, resolutions);

From 19cb0dcb9e872daf649154166104d0ee6c857e75 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 10 Aug 2014 16:45:16 +0100
Subject: [PATCH 46/77] filesystem: Make support of browsing into archives
 optional

The ability to browse, scan and play content in archives can cause problems on low powered/low memory devices.
It's quite common to see reports of a large rar file that causes xbmc to crash with an out-of-memory error when browsing or scanning.
It also can be slow as any archive in the directory is opened and extracted.

Add a settings option to enable this feature and default to disabled on Pi
---
 language/English/strings.po              | 10 ++++++++++
 system/settings/rbp.xml                  | 10 ++++++++++
 system/settings/settings.xml             |  5 +++++
 xbmc/filesystem/FileDirectoryFactory.cpp |  4 ++++
 4 files changed, 29 insertions(+)

diff --git a/language/English/strings.po b/language/English/strings.po
index ade855e..325ed2d 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -15874,3 +15874,13 @@ msgstr ""
 msgctxt "#37030"
 msgid "Unlimited"
 msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#37031"
+msgid "Support browsing into archives"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#37032"
+msgid "Allow viewing and playing files in archives (e.g. zip, rar)"
+msgstr ""
diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 60086d8..b65136a 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -1,5 +1,15 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <settings>
+  <section id="appearance">
+    <category id="filelists">
+      <group id="1">
+        <setting id="filelists.browsearchives" type="boolean" label="37031" help="37032">
+          <default>false</default>
+        </setting>
+      </group>
+    </category>
+  </section>
+
   <section id="videos">
     <category id="videoacceleration">
       <group id="1">
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index af05fb7..f87373a 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -226,6 +226,11 @@
           <default>false</default>
           <control type="toggle" />
         </setting>
+        <setting id="filelists.browsearchives" type="boolean" label="37031" help="37032">
+          <level>1</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
       </group>
     </category>
     <category id="screensaver" label="360" help="36128">
diff --git a/xbmc/filesystem/FileDirectoryFactory.cpp b/xbmc/filesystem/FileDirectoryFactory.cpp
index 2fd8777..3b294cd 100644
--- a/xbmc/filesystem/FileDirectoryFactory.cpp
+++ b/xbmc/filesystem/FileDirectoryFactory.cpp
@@ -46,6 +46,7 @@
 #include "Directory.h"
 #include "File.h"
 #include "ZipManager.h"
+#include "settings/Settings.h"
 #include "settings/AdvancedSettings.h"
 #include "FileItem.h"
 #include "utils/StringUtils.h"
@@ -142,6 +143,8 @@ IFileDirectory* CFileDirectoryFactory::Create(const CURL& url, CFileItem* pItem,
     return NULL;
   }
 #endif
+  if (CSettings::Get().GetBool("filelists.browsearchives"))
+  {
   if (url.IsFileType("zip"))
   {
     CURL zipURL = URIUtils::CreateArchivePath("zip", url);
@@ -215,6 +218,7 @@ IFileDirectory* CFileDirectoryFactory::Create(const CURL& url, CFileItem* pItem,
     }
     return NULL;
   }
+  }
   if (url.IsFileType("xsp"))
   { // XBMC Smart playlist - just XML renamed to XSP
     // read the name of the playlist in


From 860ade05ad1104e01a1266cd5cf0231e9332fc4a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 11 Aug 2014 22:56:13 +0100
Subject: [PATCH 48/77] [omxplayer] Add acceleration option to choose
 omxplayer/dvdplayer automatically

---
 language/English/strings.po        | 10 +++++++
 system/settings/settings.xml       |  9 ++++++
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 58 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 77 insertions(+)

diff --git a/language/English/strings.po b/language/English/strings.po
index 325ed2d..1b13a9b 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -15884,3 +15884,13 @@ msgstr ""
 msgctxt "#37032"
 msgid "Allow viewing and playing files in archives (e.g. zip, rar)"
 msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#37033"
+msgid "Select omxplayer or dvdplayer automatically"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#37034"
+msgid "Uses codec information and audio setting to choose dvdplayer or omxplayer as appropriate"
+msgstr ""
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index f87373a..bd7858e 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -757,6 +757,15 @@
           <default>true</default>
           <control type="toggle" />
         </setting>
+        <setting id="videoplayer.autoomxplayer" type="boolean" label="37033" help="37033">
+          <requirement>HAS_OMXPLAYER</requirement>
+          <dependencies>
+            <dependency type="enable" setting="videoplayer.decodingmethod" operator="is">1</dependency>
+          </dependencies>
+          <level>2</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
         <setting id="videoplayer.useomxplayer" type="boolean" label="13458" help="13459">
           <requirement>HAS_OMXPLAYER</requirement>
           <dependencies>
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index de49617..b274756 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -490,6 +490,62 @@ void CSelectionStreams::Update(CDVDInputStream* input, CDVDDemux* demuxer)
 
 void CDVDPlayer::CreatePlayers()
 {
+#ifdef HAS_OMXPLAYER
+  bool omxplayer_mode = m_omxplayer_mode;
+  bool autoomx = CSettings::Get().GetBool("videoplayer.autoomxplayer");
+  // omxplayer only handles Pi sink
+  if (autoomx && m_omxplayer_mode &&
+      CSettings::Get().GetString("audiooutput.audiodevice") != "PI:Analogue" &&
+      CSettings::Get().GetString("audiooutput.audiodevice") != "PI:HDMI")
+  {
+    CLog::Log(LOGNOTICE, "COMXPlayer::%s OMXPlayer unsuitable due to audio sink", __func__);
+    m_omxplayer_mode = false;
+  }
+  if (autoomx && m_pDemuxer && m_omxplayer_mode)
+  {
+    // find video stream
+    int num_supported = 0, num_unsupported = 0;
+    AVCodecID codec = AV_CODEC_ID_NONE;
+    SelectionStreams streams = m_SelectionStreams.Get(STREAM_VIDEO, PredicateVideoPriority);
+    for(SelectionStreams::iterator it = streams.begin(); it != streams.end(); ++it)
+    {
+      int iStream = it->id;
+      CDemuxStream *stream = m_pDemuxer->GetStream(iStream);
+      if(!stream || stream->disabled)
+        continue;
+      CDVDStreamInfo hint(*stream, true);
+
+      bool supported = false;
+      if ((hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO) && g_RBP.GetCodecMpg2())
+        supported = true;
+      else if ((hint.codec == AV_CODEC_ID_VC1 || hint.codec == AV_CODEC_ID_WMV3) && g_RBP.GetCodecWvc1())
+        supported = true;
+      else if (hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_MPEG4 || hint.codec == AV_CODEC_ID_H263 ||
+          hint.codec == AV_CODEC_ID_VP6 || hint.codec == AV_CODEC_ID_VP6F || hint.codec == AV_CODEC_ID_VP6A || hint.codec == AV_CODEC_ID_VP8 ||
+          hint.codec == AV_CODEC_ID_THEORA || hint.codec == AV_CODEC_ID_MJPEG || hint.codec == AV_CODEC_ID_MJPEGB)
+        supported = true;
+      codec = hint.codec;
+      if (supported)
+        num_supported++;
+      else
+        num_unsupported++;
+    }
+    if (num_unsupported > 0 && num_supported == 0)
+    {
+      CLog::Log(LOGNOTICE, "COMXPlayer::%s OMXPlayer unsuitable due to video codec (%x:%d/%d)", __func__, codec, num_supported, num_unsupported);
+      m_omxplayer_mode = false;
+    }
+  }
+  if (autoomx && m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD))
+  {
+    CLog::Log(LOGNOTICE, "COMXPlayer::%s OMXPlayer unsuitable due to dvd menus", __func__);
+    m_omxplayer_mode = false;
+  }
+
+  if (m_omxplayer_mode != omxplayer_mode)
+    DestroyPlayers();
+#endif
+
   if (m_players_created)
     return;
 
@@ -1187,6 +1243,8 @@ void CDVDPlayer::Process()
     m_bAbortRequest = true;
     return;
   }
+  // give players a chance to reconsider now codecs are known
+  CreatePlayers();
 
   // allow renderer to switch to fullscreen if requested
   m_dvdPlayerVideo->EnableFullscreen(m_PlayerOptions.fullscreen);

From 03adf05c7efb63bd728dd31dbe7eeac7da0e247a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 12 Aug 2014 16:51:18 +0100
Subject: [PATCH 49/77] AE: Add some logging for suspend/resume

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 5 +++++
 xbmc/cores/omxplayer/OMXAudio.cpp                    | 2 ++
 2 files changed, 7 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index fe5e893..3e89523 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -345,6 +345,7 @@ void CActiveAE::StateMachine(int signal, Protocol *port, Message *msg)
         switch (signal)
         {
         case CActiveAEControlProtocol::INIT:
+          CLog::Log(LOGNOTICE, "CActiveAE::%s - AE_TOP_UNCONFIGURED/CActiveAEControlProtocol::INIT", __func__);
           m_extError = false;
           m_sink.EnumerateSinkList(false);
           LoadSettings();
@@ -430,6 +431,7 @@ void CActiveAE::StateMachine(int signal, Protocol *port, Message *msg)
           m_extDeferData = true;
           return;
         case CActiveAEControlProtocol::SUSPEND:
+          CLog::Log(LOGNOTICE, "CActiveAE::%s - AE_TOP_CONFIGURED/CActiveAEControlProtocol::SUSPEND", __func__);
           UnconfigureSink();
           m_stats.SetSuspended(true);
           m_state = AE_TOP_CONFIGURED_SUSPEND;
@@ -655,6 +657,7 @@ void CActiveAE::StateMachine(int signal, Protocol *port, Message *msg)
           CLog::Log(LOGDEBUG,"CActiveAE - display reset event");
           displayReset = true;
         case CActiveAEControlProtocol::INIT:
+          CLog::Log(LOGNOTICE, "CActiveAE::%s - AE_TOP_CONFIGURED_SUSPEND/CActiveAEControlProtocol::INIT", __func__);
           m_extError = false;
           if (!displayReset)
           {
@@ -2332,12 +2335,14 @@ void CActiveAE::Shutdown()
 
 bool CActiveAE::Suspend()
 {
+  CLog::Log(LOGNOTICE, "ActiveAE::%s", __FUNCTION__);
   return m_controlPort.SendOutMessage(CActiveAEControlProtocol::SUSPEND);
 }
 
 bool CActiveAE::Resume()
 {
   Message *reply;
+  CLog::Log(LOGNOTICE, "ActiveAE::%s", __FUNCTION__);
   if (m_controlPort.SendOutMessageSync(CActiveAEControlProtocol::INIT,
                                                  &reply,
                                                  5000))
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 7e85441..a73dd0a 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -932,6 +932,7 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
 //***********************************************************************************************
 bool COMXAudio::Deinitialize()
 {
+  CLog::Log(LOGNOTICE, "COMXAudio::%s start", __func__);
   CSingleLock lock (m_critSection);
 
   if ( m_omx_tunnel_clock_analog.IsInitialized() )
@@ -992,6 +993,7 @@ bool COMXAudio::Deinitialize()
   m_submitted     = 0.0f;
   m_maxLevel      = 0.0f;
 
+  CLog::Log(LOGNOTICE, "COMXAudio::%s end", __func__);
   return true;
 }
 

From 7c39ab7b84943aeace23e0488b6f21b73ffc1653 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 9 Jul 2014 22:45:43 +0100
Subject: [PATCH 50/77] [rbp] Make cachemembuffersize default depend on memory
 size

---
 xbmc/linux/RBP.cpp                 | 5 +++++
 xbmc/settings/AdvancedSettings.cpp | 5 +++++
 2 files changed, 10 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 11376fc..b67fbb1 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -22,6 +22,7 @@
 #if defined(TARGET_RASPBERRY_PI)
 
 #include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
 #include "utils/log.h"
 
 #include "cores/omxplayer/OMXImage.h"
@@ -84,6 +85,9 @@ bool CRBP::Initialize()
   if (!m_gui_resolution_limit)
     m_gui_resolution_limit = m_gpu_mem < 128 ? 720:1080;
 
+  if (g_advancedSettings.m_cacheMemBufferSize == ~0)
+    g_advancedSettings.m_cacheMemBufferSize = m_arm_mem < 256 ? 1024 * 1024 * 2 : 1024 * 1024 * 20;
+
   g_OMXImage.Initialize();
   m_omx_image_init = true;
   return true;
@@ -96,6 +100,7 @@ void CRBP::LogFirmwareVerison()
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Raspberry PI firmware version: %s", response);
   CLog::Log(LOGNOTICE, "ARM mem: %dMB GPU mem: %dMB MPG2:%d WVC1:%d", m_arm_mem, m_gpu_mem, m_codec_mpg2_enabled, m_codec_wvc1_enabled);
+  CLog::Log(LOGNOTICE, "cacheMemBufferSize: %dMB",  g_advancedSettings.m_cacheMemBufferSize >> 20);
   m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config int");
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Config:\n%s", response);
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 4af3c7a..c003c5a 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -364,7 +364,12 @@ void CAdvancedSettings::Initialize()
 
   m_measureRefreshrate = false;
 
+#ifdef TARGET_RASPBERRY_PI
+  // want default to be memory dependent, but interface to gpu not available yet, so set in RBP.cpp
+  m_cacheMemBufferSize = ~0;
+#else
   m_cacheMemBufferSize = 1024 * 1024 * 20;
+#endif
   m_networkBufferMode = 0; // Default (buffer all internet streams/filesystems)
   // the following setting determines the readRate of a player data
   // as multiply of the default data read rate

From 8f2f06af909adfada148cca51e9195b9461a037c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 16 Jun 2014 19:06:00 +0100
Subject: [PATCH 53/77] [experimental] Disable quiet-noise generation

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index 488a0df..d9f4a43 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -870,6 +870,7 @@ void CActiveAESink::SwapInit(CSampleBuffer* samples)
 
 void CActiveAESink::GenerateNoise()
 {
+#ifndef TARGET_RASPBERRY_PI
   int nb_floats = m_sampleOfSilence.pkt->max_nb_samples;
   nb_floats *= m_sampleOfSilence.pkt->config.channels;
 
@@ -907,6 +908,7 @@ void CActiveAESink::GenerateNoise()
                      (uint8_t**)&noise, m_sampleOfSilence.pkt->max_nb_samples, 1.0);
 
   _aligned_free(noise);
+#endif
 }
 
 void CActiveAESink::SetSilenceTimer()

From 0a2b78734e0e04fbc18edbfd7efc0813c98715ae Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 30 May 2014 14:58:43 +0100
Subject: [PATCH 54/77] [settings] Experiment: Report DESKTOP resolution in
 video settings

---
 xbmc/settings/DisplaySettings.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index bb31f15..eae549b 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -650,6 +650,9 @@ void CDisplaySettings::SettingOptionsResolutionsFiller(const CSetting *setting,
     vector<RESOLUTION_WHR> resolutions = g_Windowing.ScreenResolutions(info.iScreen, info.fRefreshRate);
     for (vector<RESOLUTION_WHR>::const_iterator resolution = resolutions.begin(); resolution != resolutions.end(); ++resolution)
     {
+if (resolution->ResInfo_Index == RES_DESKTOP)
+      list.push_back(make_pair(StringUtils::Format("DESKTOP"), resolution->ResInfo_Index));
+else
       list.push_back(make_pair(
         StringUtils::Format("%dx%d%s", resolution->width, resolution->height,
                             ModeFlagsToString(resolution->flags, false).c_str()),

From 069d3bbd3f6fb99311923b22001faa2e1d53b106 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 18:24:42 +0200
Subject: [PATCH 55/77] Added some vc_tv_* functions that were missing in
 DllBCM.

---
 xbmc/linux/DllBCM.h | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/xbmc/linux/DllBCM.h b/xbmc/linux/DllBCM.h
index b92fdb8..9c7e293 100644
--- a/xbmc/linux/DllBCM.h
+++ b/xbmc/linux/DllBCM.h
@@ -48,6 +48,9 @@ class DllBcmHostInterface
   virtual void bcm_host_init() = 0;
   virtual void bcm_host_deinit() = 0;
   virtual int32_t graphics_get_display_size( const uint16_t display_number, uint32_t *width, uint32_t *height) = 0;
+  virtual int vc_tv_power_off() = 0;
+  virtual int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options) = 0;
+  virtual int vc_tv_hdmi_power_on_preferred() = 0;
   virtual int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                        HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags) = 0;
   virtual int vc_tv_hdmi_power_on_best_3d(uint32_t width, uint32_t height, uint32_t frame_rate,
@@ -92,6 +95,12 @@ class DllBcmHost : public DllDynamic, DllBcmHostInterface
     { return ::bcm_host_deinit(); };
   virtual int32_t graphics_get_display_size( const uint16_t display_number, uint32_t *width, uint32_t *height)
     { return ::graphics_get_display_size(display_number, width, height); };
+  virtual int vc_tv_power_off()
+    { return ::vc_tv_power_off(); }
+  virtual int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options)
+    { return ::vc_tv_sdtv_power_on(mode, options); }
+  virtual int vc_tv_hdmi_power_on_preferred()
+    { return ::vc_tv_hdmi_power_on_preferred(); }
   virtual int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                        HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags)
     { return ::vc_tv_hdmi_power_on_best(width, height, frame_rate, scan_mode, match_flags); };

From f0c6be3fc275077081157e3bece35c6718c57559 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 18:29:03 +0200
Subject: [PATCH 56/77] Added private utility function to map a float display
 aspect, to the respective SDTV_ASPECT_* enum value.

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index bf1e589..518a87d 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -411,6 +411,25 @@ static void SetResolutionString(RESOLUTION_INFO &res)
     res.dwFlags & D3DPRESENTFLAG_MODE3DTB   ? " 3DTB" : "",
     res.dwFlags & D3DPRESENTFLAG_MODE3DSBS  ? " 3DSBS" : "");
 }
+
+static SDTV_ASPECT_T get_sdtv_aspect_from_display_aspect(float display_aspect)
+{
+  SDTV_ASPECT_T aspect;
+  const float delta = 1e-3;
+  if(fabs(get_display_aspect_ratio(SDTV_ASPECT_16_9) - display_aspect) < delta)
+  {
+    aspect = SDTV_ASPECT_16_9;
+  }
+  else if(fabs(get_display_aspect_ratio(SDTV_ASPECT_14_9) - display_aspect) < delta)
+  {
+    aspect = SDTV_ASPECT_14_9;
+  }
+  else
+  {
+    aspect = SDTV_ASPECT_4_3;
+  }
+  return aspect;
+}
 #endif
 
 bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)

From 24cd5274f8465c64f3f984fa5a1ada139f1d762a Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 19:50:58 +0200
Subject: [PATCH 57/77] Changed SDTV resolutions to be treated similarly to
 HDMI resolutions in SetNativeResolution. This means that the SDTV interface
 is powered up and set to the right mode.

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 36 ++++++++++++++++++++-----
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h   |  1 -
 2 files changed, 29 insertions(+), 8 deletions(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 518a87d..9dc39d5 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -221,7 +221,7 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 
   DestroyDispmaxWindow();
 
-  if(!m_fixedMode && GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
+  if(GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
   {
     sem_init(&m_tv_synced, 0, 0);
     m_DllBcmHost->vc_tv_register_callback(CallbackTvServiceCallback, this);
@@ -275,6 +275,33 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 
     m_desktopRes = res;
   }
+  else if(!GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
+  {
+    sem_init(&m_tv_synced, 0, 0);
+    m_DllBcmHost->vc_tv_register_callback(CallbackTvServiceCallback, this);
+
+    SDTV_OPTIONS_T options;
+    options.aspect = get_sdtv_aspect_from_display_aspect((float)res.iScreenWidth / (float)res.iScreenHeight);
+
+    int success = m_DllBcmHost->vc_tv_sdtv_power_on((SDTV_MODE_T)GETFLAGS_MODE(res.dwFlags), &options);
+
+    if (success == 0)
+    {
+      CLog::Log(LOGDEBUG, "EGL set SDTV mode (%d,%d)=%d\n",
+                          GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success);
+
+      sem_wait(&m_tv_synced);
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "EGL failed to set SDTV mode (%d,%d)=%d\n",
+                          GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success);
+    }
+    m_DllBcmHost->vc_tv_unregister_callback(CallbackTvServiceCallback);
+    sem_destroy(&m_tv_synced);
+
+    m_desktopRes = res;
+  }
 
   m_dispman_display = m_DllBcmHost->vc_dispmanx_display_open(0);
 
@@ -440,8 +467,6 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
   if(!m_DllBcmHost)
     return false;
 
-  m_fixedMode               = false;
-
   /* read initial desktop resolution before probe resolutions.
    * probing will replace the desktop resolution when it finds the same one.
    * we raplace it because probing will generate more detailed 
@@ -484,7 +509,7 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
       m_desktopRes.iHeight      = tv_state.display.sdtv.height;
       m_desktopRes.iScreenWidth = tv_state.display.sdtv.width;
       m_desktopRes.iScreenHeight= tv_state.display.sdtv.height;
-      m_desktopRes.dwFlags      = D3DPRESENTFLAG_INTERLACED;
+      m_desktopRes.dwFlags      = MAKEFLAGS(HDMI_RES_GROUP_INVALID, tv_state.display.sdtv.mode, 1);
       m_desktopRes.fRefreshRate = (float)tv_state.display.sdtv.frame_rate;
       m_desktopRes.fPixelRatio  = get_display_aspect_ratio((SDTV_ASPECT_T)tv_state.display.sdtv.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
     }
@@ -507,9 +532,6 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
     CLog::Log(LOGDEBUG, "EGL probe resolution %s:%x\n", m_desktopRes.strMode.c_str(), m_desktopRes.dwFlags);
   }
 
-  if(resolutions.size() < 2)
-    m_fixedMode = true;
-
   DLOG("CEGLNativeTypeRaspberryPI::ProbeResolutions\n");
   return true;
 #else
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
index 59401f5..a0acb1a 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
@@ -59,7 +59,6 @@ class CEGLNativeTypeRaspberryPI : public CEGLNativeType
   DISPMANX_ELEMENT_HANDLE_T     m_dispman_element;
   TV_GET_STATE_RESP_T           m_tv_state;
   sem_t                         m_tv_synced;
-  bool                          m_fixedMode;
   RESOLUTION_INFO               m_desktopRes;
   int                           m_width;
   int                           m_height;

From f068e06b096f1d09070abe714dcb9da4aeb41130 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 19:54:59 +0200
Subject: [PATCH 58/77] Added methods SuspendVideoOutput() and
 ResumeVideoOutput() to CRBP class, which can be used to power down the
 Raspberry PI's video interface, and restore it at a later point.

---
 xbmc/linux/RBP.cpp                              | 15 +++++++++++++++
 xbmc/linux/RBP.h                                |  3 +++
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  3 +++
 3 files changed, 21 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index b67fbb1..2ff6078 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -212,4 +212,19 @@ void CRBP::Deinitialize()
   m_initialized     = false;
   m_omx_initialized = false;
 }
+
+void CRBP::SuspendVideoOutput()
+{
+  CLog::Log(LOGDEBUG, "Raspberry PI suspending video output\n");
+  char response[80];
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "display_power 0");
+}
+
+void CRBP::ResumeVideoOutput()
+{
+  char response[80];
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "display_power 1");
+  CLog::Log(LOGDEBUG, "Raspberry PI resuming video output\n");
+}
+
 #endif
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index 4fd18f3..f947acc 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -59,6 +59,9 @@ class CRBP
   DllOMX *GetDllOMX() { return m_OMX ? m_OMX->GetDll() : NULL; }
   void WaitVsync();
 
+  void SuspendVideoOutput();
+  void ResumeVideoOutput();
+
 private:
   DllBcmHost *m_DllBcmHost;
   bool       m_initialized;
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 9dc39d5..ca36082 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -59,7 +59,10 @@
 # define DLOG(fmt, args...)
 #endif
 
+#if defined(TARGET_RASPBERRY_PI)
 static void SetResolutionString(RESOLUTION_INFO &res);
+static SDTV_ASPECT_T get_sdtv_aspect_from_display_aspect(float display_aspect);
+#endif
 
 CEGLNativeTypeRaspberryPI::CEGLNativeTypeRaspberryPI()
 {

From 35cc5ae9e5e5914c0084a79cc6bd41853a59e086 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 11 Aug 2013 15:03:36 +0100
Subject: [PATCH 59/77] PowerManager (and its IPowerSyscall instance) now gets
 called from CApplication::OnKey() and can process and suppress key presses.
 This is a requirement to implement a virtual sleep state.

---
 xbmc/Application.cpp                  | 7 +++++++
 xbmc/powermanagement/IPowerSyscall.h  | 7 +++++++
 xbmc/powermanagement/PowerManager.cpp | 6 ++++++
 xbmc/powermanagement/PowerManager.h   | 3 +++
 4 files changed, 23 insertions(+)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 94ee013..e68c80f 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2358,6 +2358,13 @@ bool CApplication::OnKey(const CKey& key)
   // special handling if the screensaver is active
   CAction action = CButtonTranslator::GetInstance().GetAction(iWin, key);
 
+  // give the PowerManager a chance to process a keypress, and
+  // suppress further processing. we need this for virtual sleep.
+  if (g_powerManager.ProcessAction(action))
+  {
+    return true;
+  }
+
   // a key has been pressed.
   // reset Idle Timer
   m_idleTimer.StartZero();
diff --git a/xbmc/powermanagement/IPowerSyscall.h b/xbmc/powermanagement/IPowerSyscall.h
index 7f9e7ed..711abea 100644
--- a/xbmc/powermanagement/IPowerSyscall.h
+++ b/xbmc/powermanagement/IPowerSyscall.h
@@ -20,6 +20,9 @@
  *
  */
 
+// forward declaration
+class CAction;
+
 class IPowerEventsCallback
 {
 public:
@@ -60,6 +63,10 @@ class IPowerSyscall
    \param callback the callback to signal to
    */
   virtual bool PumpPowerEvents(IPowerEventsCallback *callback) = 0;
+
+  // this is an optional part of the interface, so we provide a no-op implementation here.
+  // return true to suppress further processing of the CAction.
+  virtual bool ProcessAction(const CAction& action) { return false; }
 };
 
 class CPowerSyscallWithoutEvents : public IPowerSyscall
diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 5900f98..6e819d9 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -225,6 +225,12 @@ void CPowerManager::ProcessEvents()
   nesting--;
 }
 
+bool CPowerManager::ProcessAction(const CAction& action)
+{
+  return m_instance->ProcessAction(action);
+}
+
+
 void CPowerManager::OnSleep()
 {
   CAnnouncementManager::Get().Announce(System, "xbmc", "OnSleep");
diff --git a/xbmc/powermanagement/PowerManager.h b/xbmc/powermanagement/PowerManager.h
index 0b1f10a..e42b143 100644
--- a/xbmc/powermanagement/PowerManager.h
+++ b/xbmc/powermanagement/PowerManager.h
@@ -58,6 +58,8 @@ class CNullPowerSyscall : public IPowerSyscall
 
 
   virtual bool PumpPowerEvents(IPowerEventsCallback *callback) { return false; }
+
+  virtual bool ProcessAction(const CAction& action) { return false; }
 };
 
 // This class will wrap and handle PowerSyscalls.
@@ -87,6 +89,7 @@ class CPowerManager : public IPowerEventsCallback
 
   static void SettingOptionsShutdownStatesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current, void *data);
 
+  bool ProcessAction(const CAction& action);
 private:
   void OnSleep();
   void OnWake();

From 4ba5eadbae5505f85254ad58f3abb0a8a6d7ff62 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Wed, 17 Apr 2013 13:23:01 +0200
Subject: [PATCH 60/77] Added CPowerSyscallVirtualSleep class, which acts as a
 base class for devices that have no native standby mode, and need to fake it
 in some way.

---
 xbmc/powermanagement/Makefile                     |  1 +
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 84 +++++++++++++++++++++++
 xbmc/powermanagement/PowerSyscallVirtualSleep.h   | 56 +++++++++++++++
 3 files changed, 141 insertions(+)
 create mode 100644 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
 create mode 100644 xbmc/powermanagement/PowerSyscallVirtualSleep.h

diff --git a/xbmc/powermanagement/Makefile b/xbmc/powermanagement/Makefile
index 0b4c029..16056af 100644
--- a/xbmc/powermanagement/Makefile
+++ b/xbmc/powermanagement/Makefile
@@ -1,5 +1,6 @@
 SRCS=DPMSSupport.cpp \
      PowerManager.cpp \
+     PowerSyscallVirtualSleep.cpp \
 
 LIB=powermanagement.a
 
diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
new file mode 100644
index 0000000..6a1e47b
--- /dev/null
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -0,0 +1,84 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "PowerSyscallVirtualSleep.h"
+#include "guilib/Key.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+
+bool CPowerSyscallVirtualSleep::Suspend()
+{
+  if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_AWAKE)
+  {
+    if (VirtualSleep())
+    {
+      m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_SLEEP;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CPowerSyscallVirtualSleep::PumpPowerEvents(IPowerEventsCallback *callback)
+{
+  if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_WILL_WAKE)
+  {
+    callback->OnWake();
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_AWAKE;
+    return true;
+  }
+  else if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_WILL_SLEEP)
+  {
+    callback->OnSleep();
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_ASLEEP;
+    return true;
+  }
+
+  return false;
+}
+
+bool CPowerSyscallVirtualSleep::ProcessAction(const CAction& action)
+{
+  if (m_virtualSleepState != VIRTUAL_SLEEP_STATE_ASLEEP)
+    return false;
+
+  // device is in virtual sleep, only one of the power keys will
+  // wake it up again.
+  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+  {
+    CStdString name = action.GetName();
+    StringUtils::ToLower(name);
+    if(name.Equals("xbmc.suspend()") ||
+       name.Equals("shutdown") ||
+       name.Equals("suspend")  ||
+       name.Equals("hibernate"))
+    {
+      if(VirtualWake())
+      {
+        m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_WAKE;
+        return false;
+      }
+    }
+  }
+
+  // wasn't a power key, suppress this and stay asleep
+  return true;
+}
diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.h b/xbmc/powermanagement/PowerSyscallVirtualSleep.h
new file mode 100644
index 0000000..ef6e682
--- /dev/null
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.h
@@ -0,0 +1,56 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _POWER_SYSCALL_VIRTUAL_SLEEP_H_
+#define _POWER_SYSCALL_VIRTUAL_SLEEP_H_
+#include "IPowerSyscall.h"
+
+// Systems that have no native standby mode, can base their
+// IPowerSyscall implementation on this class, and need only
+// implement VirtualSleep()/VirtualWake().
+class CPowerSyscallVirtualSleep : public IPowerSyscall
+{
+public:
+  CPowerSyscallVirtualSleep() : m_virtualSleepState(VIRTUAL_SLEEP_STATE_AWAKE) {}
+  virtual ~CPowerSyscallVirtualSleep() {}
+
+  virtual bool CanSuspend() { return true; }
+  virtual bool Suspend();
+
+  virtual bool PumpPowerEvents(IPowerEventsCallback *callback);
+
+  virtual bool ProcessAction(const CAction& action);
+
+  virtual bool VirtualSleep() = 0;
+  virtual bool VirtualWake()  = 0;
+
+protected:
+  // keep track of virtual sleep state for devices that support it
+  typedef enum {
+    VIRTUAL_SLEEP_STATE_AWAKE = 0,
+    VIRTUAL_SLEEP_STATE_ASLEEP,
+    VIRTUAL_SLEEP_STATE_WILL_WAKE,
+    VIRTUAL_SLEEP_STATE_WILL_SLEEP,
+  } VirtualSleepState;
+
+  VirtualSleepState m_virtualSleepState;
+};
+
+#endif // _POWER_SYSCALL_VIRTUAL_SLEEP_H_

From 53a5805f8e8e2d24b35a50c8a6733898d4a5a375 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Wed, 17 Apr 2013 13:24:22 +0200
Subject: [PATCH 61/77] Added power management support for the Raspberry Pi.
 Since it doesn't support true standby, we fake it by turning video on or off,
 and ignoring remote inputs during the standby phase.

---
 xbmc/powermanagement/PowerManager.cpp              |  4 ++
 xbmc/powermanagement/linux/Makefile                |  1 +
 .../linux/RaspberryPIPowerSyscall.cpp              | 38 +++++++++++++++++
 .../linux/RaspberryPIPowerSyscall.h                | 49 ++++++++++++++++++++++
 4 files changed, 92 insertions(+)
 create mode 100644 xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
 create mode 100644 xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h

diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 6e819d9..2d8c750 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -38,6 +38,8 @@
 
 #if defined(TARGET_DARWIN)
 #include "osx/CocoaPowerSyscall.h"
+#elif defined(TARGET_RASPBERRY_PI)
+#include "linux/RaspberryPIPowerSyscall.h"
 #elif defined(TARGET_ANDROID)
 #include "android/AndroidPowerSyscall.h"
 #elif defined(TARGET_POSIX)
@@ -71,6 +73,8 @@ void CPowerManager::Initialize()
 {
 #if defined(TARGET_DARWIN)
   m_instance = new CCocoaPowerSyscall();
+#elif defined(TARGET_RASPBERRY_PI)
+  m_instance = new CRaspberryPIPowerSyscall();
 #elif defined(TARGET_ANDROID)
   m_instance = new CAndroidPowerSyscall();
 #elif defined(TARGET_POSIX)
diff --git a/xbmc/powermanagement/linux/Makefile b/xbmc/powermanagement/linux/Makefile
index e9d95fb..b130812 100644
--- a/xbmc/powermanagement/linux/Makefile
+++ b/xbmc/powermanagement/linux/Makefile
@@ -1,5 +1,6 @@
 SRCS=ConsoleDeviceKitPowerSyscall.cpp \
      ConsoleUPowerSyscall.cpp \
+     RaspberryPIPowerSyscall.cpp \
      UPowerSyscall.cpp \
      LogindUPowerSyscall.cpp
 
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
new file mode 100644
index 0000000..10deeb8
--- /dev/null
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
@@ -0,0 +1,38 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(TARGET_RASPBERRY_PI)
+
+#include "RaspberryPIPowerSyscall.h"
+#include "RBP.h"
+
+bool CRaspberryPIPowerSyscall::VirtualSleep()
+{
+  g_RBP.SuspendVideoOutput();
+  return true;
+}
+
+bool CRaspberryPIPowerSyscall::VirtualWake()
+{
+  g_RBP.ResumeVideoOutput();
+  return true;
+}
+
+#endif
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
new file mode 100644
index 0000000..fd1d67c
--- /dev/null
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
@@ -0,0 +1,49 @@
+#pragma once
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _RASPBERRY_PI_POWER_SYSCALL_H_
+#define _RASPBERRY_PI_POWER_SYSCALL_H_
+
+#if defined(TARGET_RASPBERRY_PI)
+#include "powermanagement/PowerSyscallVirtualSleep.h"
+
+class CRaspberryPIPowerSyscall : public CPowerSyscallVirtualSleep
+{
+public:
+  CRaspberryPIPowerSyscall() : CPowerSyscallVirtualSleep() {}
+  virtual ~CRaspberryPIPowerSyscall() {}
+
+  virtual bool Powerdown()    { return false; }
+  virtual bool Hibernate()    { return false; }
+  virtual bool Reboot()       { return false; }
+
+  virtual bool CanPowerdown() { return false; }
+  virtual bool CanHibernate() { return false; }
+  virtual bool CanReboot()    { return true; }
+
+  virtual int  BatteryLevel() { return 0; }
+
+  virtual bool VirtualSleep();
+  virtual bool VirtualWake();
+};
+#endif // TARGET_RASPBERRY_PI
+
+#endif // _RASPBERRY_PI_POWER_SYSCALL_H_

From 514c8d47d50d43d065ec77ef3f7fa34e3d465a9b Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 16:16:29 +0000
Subject: [PATCH 62/77] [power] hack - don't kill lirc or cec

---
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 37 +++++++++++++++++++++++
 xbmc/powermanagement/PowerManager.cpp             |  4 +--
 2 files changed, 39 insertions(+), 2 deletions(-)

diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 6950f0c..4c8416f 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -183,12 +183,49 @@ void CPeripheralCecAdapter::Announce(AnnouncementFlag flag, const char *sender,
   }
   else if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnSleep"))
   {
+#if 1
+  bool bSendStandbyCommands(false);
+  {
+    CSingleLock lock(m_critSection);
+    bSendStandbyCommands = m_iExitCode != EXITCODE_REBOOT &&
+                           m_iExitCode != EXITCODE_RESTARTAPP &&
+                           !m_bDeviceRemoved &&
+                           (!m_bGoingToStandby || GetSettingBool("standby_tv_on_pc_standby")) &&
+                           GetSettingBool("enabled");
+
+    if (m_bGoingToStandby)
+      m_bActiveSourceBeforeStandby = m_cecAdapter->IsLibCECActiveSource();
+  }
+
+  if (bSendStandbyCommands)
+  {
+    if (m_cecAdapter->IsLibCECActiveSource())
+    {
+      if (!m_configuration.powerOffDevices.IsEmpty())
+      {
+        CLog::Log(LOGDEBUG, "%s - sending standby commands", __FUNCTION__);
+        m_standbySent = CDateTime::GetCurrentDateTime();
+        m_cecAdapter->StandbyDevices();
+      }
+      else if (m_configuration.bSendInactiveSource == 1)
+      {
+        CLog::Log(LOGDEBUG, "%s - sending inactive source commands", __FUNCTION__);
+        m_cecAdapter->SetInactiveView();
+      }
+    }
+    else
+    {
+      CLog::Log(LOGDEBUG, "%s - XBMC is not the active source, not sending any standby commands", __FUNCTION__);
+    }
+  }
+#else
     // this will also power off devices when we're the active source
     {
       CSingleLock lock(m_critSection);
       m_bGoingToStandby = true;
     }
     StopThread();
+#endif
   }
   else if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnWake"))
   {
diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 2d8c750..901f449 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -241,7 +241,7 @@ void CPowerManager::OnSleep()
   CLog::Log(LOGNOTICE, "%s: Running sleep jobs", __FUNCTION__);
 
   // stop lirc
-#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+#if 0 //defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
   CLog::Log(LOGNOTICE, "%s: Stopping lirc", __FUNCTION__);
   CBuiltins::Execute("LIRC.Stop");
 #endif
@@ -277,7 +277,7 @@ void CPowerManager::OnWake()
 #endif
 
   // restart lirc
-#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+#if 0 // defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
   CLog::Log(LOGNOTICE, "%s: Restarting lirc", __FUNCTION__);
   CBuiltins::Execute("LIRC.Start");
 #endif

From 3e41f1b5cd582be0b60a630cc00418cdbed3825a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 16:47:54 +0000
Subject: [PATCH 63/77] [power] hack - wake on any action

---
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
index 6a1e47b..a717a09 100644
--- a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -62,14 +62,14 @@ bool CPowerSyscallVirtualSleep::ProcessAction(const CAction& action)
 
   // device is in virtual sleep, only one of the power keys will
   // wake it up again.
-  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+  //if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
   {
     CStdString name = action.GetName();
     StringUtils::ToLower(name);
-    if(name.Equals("xbmc.suspend()") ||
+    /*if(name.Equals("system.suspend") ||
        name.Equals("shutdown") ||
        name.Equals("suspend")  ||
-       name.Equals("hibernate"))
+       name.Equals("hibernate"))*/
     {
       if(VirtualWake())
       {

From 02a91126f1e132933a7e51e6d667a6824f81379f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 17:30:07 +0000
Subject: [PATCH 64/77] [power] hack - Make suspend toggle suspend state

---
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
index a717a09..d39c3ed 100644
--- a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -33,6 +33,11 @@ bool CPowerSyscallVirtualSleep::Suspend()
       return true;
     }
   }
+  else if (VirtualWake())
+  {
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_WAKE;
+    return false;
+  }
 
   return false;
 }

From 3c3d10199293eaf3cba04ca241c9dfb77a9c5475 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 4 Mar 2014 19:33:44 +0000
Subject: [PATCH 65/77] [power] Add back in powerdown and reboot

---
 .../linux/RaspberryPIPowerSyscall.cpp              | 34 ++++++++++++++++++++++
 .../linux/RaspberryPIPowerSyscall.h                |  6 ++--
 2 files changed, 37 insertions(+), 3 deletions(-)

diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
index 10deeb8..220bca9 100644
--- a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
@@ -20,7 +20,11 @@
 
 #if defined(TARGET_RASPBERRY_PI)
 
+#include "system.h"
 #include "RaspberryPIPowerSyscall.h"
+#if defined(HAS_DBUS)
+#include "LogindUPowerSyscall.h"
+#endif
 #include "RBP.h"
 
 bool CRaspberryPIPowerSyscall::VirtualSleep()
@@ -35,4 +39,34 @@ bool CRaspberryPIPowerSyscall::VirtualWake()
   return true;
 }
 
+bool CRaspberryPIPowerSyscall::Powerdown()
+{
+  int s = false;
+#if defined(HAS_DBUS)
+  if (CLogindUPowerSyscall::HasLogind())
+  {
+    IPowerSyscall *m_instance = new CLogindUPowerSyscall;
+    if (m_instance->CanPowerdown())
+      s = m_instance->Powerdown();
+    delete m_instance;
+  }
+#endif
+  return s;
+}
+
+bool CRaspberryPIPowerSyscall::Reboot()
+{
+  int s = false;
+#if defined(HAS_DBUS)
+  if (CLogindUPowerSyscall::HasLogind())
+  {
+    IPowerSyscall *m_instance = new CLogindUPowerSyscall;
+    if (m_instance->CanReboot())
+      s = m_instance->Reboot();
+    delete m_instance;
+  }
+#endif
+  return s;
+}
+
 #endif
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
index fd1d67c..062132e 100644
--- a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
@@ -31,11 +31,11 @@ class CRaspberryPIPowerSyscall : public CPowerSyscallVirtualSleep
   CRaspberryPIPowerSyscall() : CPowerSyscallVirtualSleep() {}
   virtual ~CRaspberryPIPowerSyscall() {}
 
-  virtual bool Powerdown()    { return false; }
+  virtual bool Powerdown();
   virtual bool Hibernate()    { return false; }
-  virtual bool Reboot()       { return false; }
+  virtual bool Reboot();
 
-  virtual bool CanPowerdown() { return false; }
+  virtual bool CanPowerdown() { return true; }
   virtual bool CanHibernate() { return false; }
   virtual bool CanReboot()    { return true; }
 

From 5187a8e86050670abd3669590383f2f9958eef5d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 26 Apr 2014 17:27:52 +0100
Subject: [PATCH 70/77] [cec] Don't suspend pi on tv switch off - it can't wake
 up

---
 system/peripherals.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/system/peripherals.xml b/system/peripherals.xml
index a906628..9b5271a 100644
--- a/system/peripherals.xml
+++ b/system/peripherals.xml
@@ -16,7 +16,7 @@
     <setting key="send_inactive_source" type="bool" value="1" label="36025" order="5" />
     <setting key="cec_standby_screensaver" type="bool" value="0" label="36009" order="6" />
     <setting key="cec_wake_screensaver" type="bool" value="1" label="36010" order="7" />
-    <setting key="standby_pc_on_tv_standby" type="enum" value="13011" label="36029" order="8" lvalues="36028|13005|13011" />
+    <setting key="standby_pc_on_tv_standby" type="enum" value="36028" label="36029" order="8" lvalues="36028|13005|13011" />
     <setting key="standby_tv_on_pc_standby" type="bool" value="1" label="36026" order="9" />
     <setting key="use_tv_menu_language" type="bool" value="1" label="36018" order="10" />
     <setting key="pause_playback_on_deactivate" type="bool" value="1" label="36033" order="11" />

From 63179060ddac85446753a50f4b8a92e899cbc944 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 18 Aug 2014 19:09:32 +0100
Subject: [PATCH 71/77] rbp: Use new dispmanx function for vsync callbacks

---
 xbmc/linux/RBP.cpp                              | 85 ++++++++++++++-----------
 xbmc/linux/RBP.h                                |  5 +-
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  4 +-
 3 files changed, 52 insertions(+), 42 deletions(-)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 2ff6078..360fc39 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -33,7 +33,7 @@ CRBP::CRBP()
   m_omx_initialized = false;
   m_DllBcmHost      = new DllBcmHost();
   m_OMX             = new COMXCore();
-  m_element = 0;
+  m_display = DISPMANX_NO_HANDLE;
 }
 
 CRBP::~CRBP()
@@ -55,8 +55,7 @@ bool CRBP::Initialize()
 
   m_DllBcmHost->bcm_host_init();
 
-  uint32_t                    vc_image_ptr;
-  m_resource = vc_dispmanx_resource_create( VC_IMAGE_RGB565, 1, 1, &vc_image_ptr );
+  //OpenDisplay(0 /*screen*/);
 
   m_omx_initialized = m_OMX->Initialize();
   if(!m_omx_initialized)
@@ -109,13 +108,24 @@ void CRBP::LogFirmwareVerison()
   CLog::Log(LOGNOTICE, "Config:\n%s", response);
 }
 
+DISPMANX_DISPLAY_HANDLE_T CRBP::OpenDisplay(uint32_t device)
+{
+  if (m_display == DISPMANX_NO_HANDLE)
+    m_display = vc_dispmanx_display_open( 0 /*screen*/ );
+  return m_display;
+}
+
+void CRBP::CloseDisplay(DISPMANX_DISPLAY_HANDLE_T display)
+{
+  assert(display == m_display);
+  vc_dispmanx_display_close(m_display);
+  m_display = DISPMANX_NO_HANDLE;
+}
+
 void CRBP::GetDisplaySize(int &width, int &height)
 {
-  DISPMANX_DISPLAY_HANDLE_T display;
   DISPMANX_MODEINFO_T info;
-
-  display = vc_dispmanx_display_open( 0 /*screen*/ );
-  if (vc_dispmanx_display_get_info(display, &info) == 0)
+  if (vc_dispmanx_display_get_info(m_display, &info) == 0)
   {
     width = info.width;
     height = info.height;
@@ -125,12 +135,10 @@ void CRBP::GetDisplaySize(int &width, int &height)
     width = 0;
     height = 0;
   }
-  vc_dispmanx_display_close(display );
 }
 
 unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool swap_red_blue, bool video_only)
 {
-  DISPMANX_DISPLAY_HANDLE_T display;
   DISPMANX_RESOURCE_HANDLE_T resource;
   VC_RECT_T rect;
   unsigned char *image = NULL;
@@ -145,7 +153,6 @@ unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool sw
   if (!pstride)
     flags |= DISPMANX_SNAPSHOT_PACK;
 
-  display = vc_dispmanx_display_open( 0 /*screen*/ );
   stride = ((width + 15) & ~15) * 4;
   image = new unsigned char [height * stride];
 
@@ -153,45 +160,44 @@ unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool sw
   {
     resource = vc_dispmanx_resource_create( VC_IMAGE_RGBA32, width, height, &vc_image_ptr );
 
-    vc_dispmanx_snapshot(display, resource, (DISPMANX_TRANSFORM_T)flags);
+    assert(m_display != DISPMANX_NO_HANDLE);
+    vc_dispmanx_snapshot(m_display, resource, (DISPMANX_TRANSFORM_T)flags);
 
     vc_dispmanx_rect_set(&rect, 0, 0, width, height);
     vc_dispmanx_resource_read_data(resource, &rect, image, stride);
     vc_dispmanx_resource_delete( resource );
-    vc_dispmanx_display_close(display );
   }
   if (pstride)
     *pstride = stride;
   return image;
 }
 
-void CRBP::WaitVsync(void)
+
+static void vsync_callback(DISPMANX_UPDATE_HANDLE_T u, void *arg)
+{
+  CEvent *sync = (CEvent *)arg;
+  sync->Set();
+}
+
+void CRBP::WaitVsync()
 {
-  DISPMANX_DISPLAY_HANDLE_T display = vc_dispmanx_display_open( 0 /*screen*/ );
-  DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(0);
-
-  VC_DISPMANX_ALPHA_T alpha = { (DISPMANX_FLAGS_ALPHA_T)(DISPMANX_FLAGS_ALPHA_FROM_SOURCE | DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS), 120, /*alpha 0->255*/ 0 };
-  VC_RECT_T       src_rect;
-  VC_RECT_T       dst_rect;
-  vc_dispmanx_rect_set( &src_rect, 0, 0, 1 << 16, 1 << 16 );
-  vc_dispmanx_rect_set( &dst_rect, 0, 0, 1, 1 );
-
-  if (m_element)
-    vc_dispmanx_element_remove( update, m_element );
-
-  m_element = vc_dispmanx_element_add( update,
-                                            display,
-                                            2000,               // layer
-                                            &dst_rect,
-                                            m_resource,
-                                            &src_rect,
-                                            DISPMANX_PROTECTION_NONE,
-                                            &alpha,
-                                            NULL,             // clamp
-                                            (DISPMANX_TRANSFORM_T)0 );
-
-  vc_dispmanx_update_submit_sync(update);
-  vc_dispmanx_display_close( display );
+  int s;
+  CEvent sync;
+  DISPMANX_DISPLAY_HANDLE_T m_display = vc_dispmanx_display_open( 0 /*screen*/ );
+  if (m_display == DISPMANX_NO_HANDLE)
+  {
+    CLog::Log(LOGDEBUG, "CRBP::%s skipping while display closed", __func__);
+    return;
+  }
+  s = vc_dispmanx_vsync_callback(m_display, vsync_callback, (void *)&sync);
+  if (s == 0)
+  {
+    sync.Wait();
+  }
+  else assert(0);
+  s = vc_dispmanx_vsync_callback(m_display, NULL, NULL);
+  assert(s == 0);
+  vc_dispmanx_display_close( m_display );
 }
 
 
@@ -203,6 +209,9 @@ void CRBP::Deinitialize()
   if(m_omx_initialized)
     m_OMX->Deinitialize();
 
+  if (m_display)
+    CloseDisplay(m_display);
+
   m_DllBcmHost->bcm_host_deinit();
 
   if(m_initialized)
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index f947acc..ca80045 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -53,6 +53,8 @@ class CRBP
   bool GetCodecMpg2() { return m_codec_mpg2_enabled; }
   bool GetCodecWvc1() { return m_codec_wvc1_enabled; }
   void GetDisplaySize(int &width, int &height);
+  DISPMANX_DISPLAY_HANDLE_T OpenDisplay(uint32_t device);
+  void CloseDisplay(DISPMANX_DISPLAY_HANDLE_T display);
   int GetGUIResolutionLimit() { return m_gui_resolution_limit; }
   // stride can be null for packed output
   unsigned char *CaptureDisplay(int width, int height, int *stride, bool swap_red_blue, bool video_only = true);
@@ -73,10 +75,9 @@ class CRBP
   bool       m_codec_mpg2_enabled;
   bool       m_codec_wvc1_enabled;
   COMXCore   *m_OMX;
-  DISPMANX_RESOURCE_HANDLE_T m_resource;
-  DISPMANX_ELEMENT_HANDLE_T m_element;
   class DllLibOMXCore;
   CCriticalSection m_critSection;
+  DISPMANX_DISPLAY_HANDLE_T m_display;
 };
 
 extern CRBP g_RBP;
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index ca36082..4b74ea0 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -306,7 +306,7 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
     m_desktopRes = res;
   }
 
-  m_dispman_display = m_DllBcmHost->vc_dispmanx_display_open(0);
+  m_dispman_display = g_RBP.OpenDisplay(0);
 
   m_width   = res.iWidth;
   m_height  = res.iHeight;
@@ -571,7 +571,7 @@ void CEGLNativeTypeRaspberryPI::DestroyDispmaxWindow()
 
   if (m_dispman_display != DISPMANX_NO_HANDLE)
   {
-    m_DllBcmHost->vc_dispmanx_display_close(m_dispman_display);
+    g_RBP.CloseDisplay(m_dispman_display);
     m_dispman_display = DISPMANX_NO_HANDLE;
   }
   DLOG("CEGLNativeTypeRaspberryPI::DestroyDispmaxWindow\n");

From d929ed74688c7b51f0281f9d9641581c4c687180 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 19 Aug 2014 17:56:45 +0100
Subject: [PATCH 72/77] Revert "rbp: Use new dispmanx function for vsync
 callbacks"

This reverts commit afbf8fbceaa6649fb4a6bbd9a1cee6087590412b.
---
 xbmc/linux/RBP.cpp                              | 85 +++++++++++--------------
 xbmc/linux/RBP.h                                |  5 +-
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  4 +-
 3 files changed, 42 insertions(+), 52 deletions(-)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 360fc39..2ff6078 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -33,7 +33,7 @@ CRBP::CRBP()
   m_omx_initialized = false;
   m_DllBcmHost      = new DllBcmHost();
   m_OMX             = new COMXCore();
-  m_display = DISPMANX_NO_HANDLE;
+  m_element = 0;
 }
 
 CRBP::~CRBP()
@@ -55,7 +55,8 @@ bool CRBP::Initialize()
 
   m_DllBcmHost->bcm_host_init();
 
-  //OpenDisplay(0 /*screen*/);
+  uint32_t                    vc_image_ptr;
+  m_resource = vc_dispmanx_resource_create( VC_IMAGE_RGB565, 1, 1, &vc_image_ptr );
 
   m_omx_initialized = m_OMX->Initialize();
   if(!m_omx_initialized)
@@ -108,24 +109,13 @@ void CRBP::LogFirmwareVerison()
   CLog::Log(LOGNOTICE, "Config:\n%s", response);
 }
 
-DISPMANX_DISPLAY_HANDLE_T CRBP::OpenDisplay(uint32_t device)
-{
-  if (m_display == DISPMANX_NO_HANDLE)
-    m_display = vc_dispmanx_display_open( 0 /*screen*/ );
-  return m_display;
-}
-
-void CRBP::CloseDisplay(DISPMANX_DISPLAY_HANDLE_T display)
-{
-  assert(display == m_display);
-  vc_dispmanx_display_close(m_display);
-  m_display = DISPMANX_NO_HANDLE;
-}
-
 void CRBP::GetDisplaySize(int &width, int &height)
 {
+  DISPMANX_DISPLAY_HANDLE_T display;
   DISPMANX_MODEINFO_T info;
-  if (vc_dispmanx_display_get_info(m_display, &info) == 0)
+
+  display = vc_dispmanx_display_open( 0 /*screen*/ );
+  if (vc_dispmanx_display_get_info(display, &info) == 0)
   {
     width = info.width;
     height = info.height;
@@ -135,10 +125,12 @@ void CRBP::GetDisplaySize(int &width, int &height)
     width = 0;
     height = 0;
   }
+  vc_dispmanx_display_close(display );
 }
 
 unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool swap_red_blue, bool video_only)
 {
+  DISPMANX_DISPLAY_HANDLE_T display;
   DISPMANX_RESOURCE_HANDLE_T resource;
   VC_RECT_T rect;
   unsigned char *image = NULL;
@@ -153,6 +145,7 @@ unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool sw
   if (!pstride)
     flags |= DISPMANX_SNAPSHOT_PACK;
 
+  display = vc_dispmanx_display_open( 0 /*screen*/ );
   stride = ((width + 15) & ~15) * 4;
   image = new unsigned char [height * stride];
 
@@ -160,44 +153,45 @@ unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool sw
   {
     resource = vc_dispmanx_resource_create( VC_IMAGE_RGBA32, width, height, &vc_image_ptr );
 
-    assert(m_display != DISPMANX_NO_HANDLE);
-    vc_dispmanx_snapshot(m_display, resource, (DISPMANX_TRANSFORM_T)flags);
+    vc_dispmanx_snapshot(display, resource, (DISPMANX_TRANSFORM_T)flags);
 
     vc_dispmanx_rect_set(&rect, 0, 0, width, height);
     vc_dispmanx_resource_read_data(resource, &rect, image, stride);
     vc_dispmanx_resource_delete( resource );
+    vc_dispmanx_display_close(display );
   }
   if (pstride)
     *pstride = stride;
   return image;
 }
 
-
-static void vsync_callback(DISPMANX_UPDATE_HANDLE_T u, void *arg)
-{
-  CEvent *sync = (CEvent *)arg;
-  sync->Set();
-}
-
-void CRBP::WaitVsync()
+void CRBP::WaitVsync(void)
 {
-  int s;
-  CEvent sync;
-  DISPMANX_DISPLAY_HANDLE_T m_display = vc_dispmanx_display_open( 0 /*screen*/ );
-  if (m_display == DISPMANX_NO_HANDLE)
-  {
-    CLog::Log(LOGDEBUG, "CRBP::%s skipping while display closed", __func__);
-    return;
-  }
-  s = vc_dispmanx_vsync_callback(m_display, vsync_callback, (void *)&sync);
-  if (s == 0)
-  {
-    sync.Wait();
-  }
-  else assert(0);
-  s = vc_dispmanx_vsync_callback(m_display, NULL, NULL);
-  assert(s == 0);
-  vc_dispmanx_display_close( m_display );
+  DISPMANX_DISPLAY_HANDLE_T display = vc_dispmanx_display_open( 0 /*screen*/ );
+  DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(0);
+
+  VC_DISPMANX_ALPHA_T alpha = { (DISPMANX_FLAGS_ALPHA_T)(DISPMANX_FLAGS_ALPHA_FROM_SOURCE | DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS), 120, /*alpha 0->255*/ 0 };
+  VC_RECT_T       src_rect;
+  VC_RECT_T       dst_rect;
+  vc_dispmanx_rect_set( &src_rect, 0, 0, 1 << 16, 1 << 16 );
+  vc_dispmanx_rect_set( &dst_rect, 0, 0, 1, 1 );
+
+  if (m_element)
+    vc_dispmanx_element_remove( update, m_element );
+
+  m_element = vc_dispmanx_element_add( update,
+                                            display,
+                                            2000,               // layer
+                                            &dst_rect,
+                                            m_resource,
+                                            &src_rect,
+                                            DISPMANX_PROTECTION_NONE,
+                                            &alpha,
+                                            NULL,             // clamp
+                                            (DISPMANX_TRANSFORM_T)0 );
+
+  vc_dispmanx_update_submit_sync(update);
+  vc_dispmanx_display_close( display );
 }
 
 
@@ -209,9 +203,6 @@ void CRBP::Deinitialize()
   if(m_omx_initialized)
     m_OMX->Deinitialize();
 
-  if (m_display)
-    CloseDisplay(m_display);
-
   m_DllBcmHost->bcm_host_deinit();
 
   if(m_initialized)
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index ca80045..f947acc 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -53,8 +53,6 @@ class CRBP
   bool GetCodecMpg2() { return m_codec_mpg2_enabled; }
   bool GetCodecWvc1() { return m_codec_wvc1_enabled; }
   void GetDisplaySize(int &width, int &height);
-  DISPMANX_DISPLAY_HANDLE_T OpenDisplay(uint32_t device);
-  void CloseDisplay(DISPMANX_DISPLAY_HANDLE_T display);
   int GetGUIResolutionLimit() { return m_gui_resolution_limit; }
   // stride can be null for packed output
   unsigned char *CaptureDisplay(int width, int height, int *stride, bool swap_red_blue, bool video_only = true);
@@ -75,9 +73,10 @@ class CRBP
   bool       m_codec_mpg2_enabled;
   bool       m_codec_wvc1_enabled;
   COMXCore   *m_OMX;
+  DISPMANX_RESOURCE_HANDLE_T m_resource;
+  DISPMANX_ELEMENT_HANDLE_T m_element;
   class DllLibOMXCore;
   CCriticalSection m_critSection;
-  DISPMANX_DISPLAY_HANDLE_T m_display;
 };
 
 extern CRBP g_RBP;
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 4b74ea0..ca36082 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -306,7 +306,7 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
     m_desktopRes = res;
   }
 
-  m_dispman_display = g_RBP.OpenDisplay(0);
+  m_dispman_display = m_DllBcmHost->vc_dispmanx_display_open(0);
 
   m_width   = res.iWidth;
   m_height  = res.iHeight;
@@ -571,7 +571,7 @@ void CEGLNativeTypeRaspberryPI::DestroyDispmaxWindow()
 
   if (m_dispman_display != DISPMANX_NO_HANDLE)
   {
-    g_RBP.CloseDisplay(m_dispman_display);
+    m_DllBcmHost->vc_dispmanx_display_close(m_dispman_display);
     m_dispman_display = DISPMANX_NO_HANDLE;
   }
   DLOG("CEGLNativeTypeRaspberryPI::DestroyDispmaxWindow\n");

From 587a18598ba8d407646394b8afa8e0aa66602cc8 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 20 Aug 2014 21:05:05 +0100
Subject: [PATCH 73/77] [omxplayer] Use 0 for video timestamps when using
 trickplay

---
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index c2bd788..2c0a86f 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -506,7 +506,10 @@ void OMXPlayerVideo::Process()
         if (pts != DVD_NOPTS_VALUE)
           pts += m_iVideoDelay;
 
-        m_omxVideo.Decode(pPacket->pData, pPacket->iSize, pts);
+        if (m_speed != DVD_PLAYSPEED_NORMAL && m_speed != DVD_PLAYSPEED_PAUSE)
+          m_omxVideo.Decode(pPacket->pData, pPacket->iSize, 0.0);
+        else
+          m_omxVideo.Decode(pPacket->pData, pPacket->iSize, pts);
         Output(pts, bRequestDrop);
         if(pts != DVD_NOPTS_VALUE)
           m_iCurrentPts = pts;

From e2ed2cb0b3745661b74a1fdb8facaa9eaecd07b0 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 27 Jun 2014 00:01:05 +0100
Subject: [PATCH 74/77] [rbp] Resume video output on startup

---
 xbmc/linux/RBP.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 2ff6078..34e0108 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -88,6 +88,9 @@ bool CRBP::Initialize()
   if (g_advancedSettings.m_cacheMemBufferSize == ~0)
     g_advancedSettings.m_cacheMemBufferSize = m_arm_mem < 256 ? 1024 * 1024 * 2 : 1024 * 1024 * 20;
 
+  // in case xbcm was restarted when suspended
+  ResumeVideoOutput();
+
   g_OMXImage.Initialize();
   m_omx_image_init = true;
   return true;

From 1873caef5f16969652483140ce5b2365f3cc9887 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 16 Aug 2014 21:01:42 +0100
Subject: [PATCH 75/77] omxrender: Hacks to reduce GUI rendering rate when
 playing video

---
 language/English/strings.po | 27 +++++++++++++++++++++++++++
 system/settings/rbp.xml     | 16 ++++++++++++++++
 xbmc/Application.cpp        | 17 +++++++++++++++++
 3 files changed, 60 insertions(+)

diff --git a/language/English/strings.po b/language/English/strings.po
index 1b13a9b..06d425d 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -15894,3 +15894,30 @@ msgstr ""
 msgctxt "#37034"
 msgid "Uses codec information and audio setting to choose dvdplayer or omxplayer as appropriate"
 msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38000"
+msgid "Limit GUI updates when playing video"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38001"
+msgid "This can reduce CPU when playing video by updating the overlays less often"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38002"
+msgid "Off"
+msgstr ""
+
+msgctxt "#38003"
+msgid "5 fps"
+msgstr ""
+
+msgctxt "#38004"
+msgid "10 fps"
+msgstr ""
+
+msgctxt "#38005"
+msgid "24 fps"
+msgstr ""
diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index b65136a..9269dec 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -20,6 +20,22 @@
           <visible>false</visible>
         </setting>
       </group>
+      <group id="3">
+        <setting id="videoplayer.limitguiupdate" type="integer" label="38000" help="38001">
+          <level>2</level>
+          <default>10</default>
+          <constraints>
+            <options>
+              <option label="38002">0</option>   <!-- off -->
+              <option label="38003">5</option>   <!-- 5 fps -->
+              <option label="38004">10</option>  <!-- 10 fps -->
+              <option label="38005">24</option>  <!-- 24 fps -->
+            </options>
+          </constraints>
+          <control type="spinner" format="string" />
+          <control type="edit" format="integer" />
+        </setting>
+      </group>
     </category>
   </section>
 
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index e68c80f..6a280d5 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2206,6 +2206,23 @@ void CApplication::Render()
   if (m_bStop)
     return;
 
+#ifdef TARGET_RASPBERRY_PI
+  if (g_graphicsContext.IsFullScreenVideo() && !m_pPlayer->IsPausedPlayback())
+  {
+    int fps = CSettings::Get().GetInt("videoplayer.limitguiupdate");
+    unsigned int now = XbmcThreads::SystemClockMillis();
+    unsigned int frameTime = now - m_lastFrameTime;
+    if (fps > 0 && frameTime * fps < 1000)
+    {
+      g_renderManager.FrameWait(100);
+      g_infoManager.UpdateFPS();
+      g_renderManager.FrameMove();
+      g_renderManager.FrameFinish();
+      return;
+    }
+  }
+#endif
+
   MEASURE_FUNCTION;
 
   int vsync_mode = CSettings::Get().GetInt("videoscreen.vsync");

From eab1aae1889ddc167e7fb5702a750a3f9c492f77 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 29 Aug 2014 18:11:14 +0100
Subject: [PATCH 76/77] omxcodec: experimental: enable deinterlace

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp | 11 ++++-------
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h   |  2 +-
 2 files changed, 5 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 3218b63..84799e2 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -115,7 +115,7 @@ COpenMaxVideo::COpenMaxVideo()
   m_finished = false;
   m_pFormatName = "mmal-xxxx";
 
-  //m_interlace_mode = MMAL_InterlaceProgressive;
+  m_interlace_mode = MMAL_InterlaceProgressive;
   m_startframe = false;
   m_decoderPts = DVD_NOPTS_VALUE;
   m_droppedPics = 0;
@@ -315,8 +315,6 @@ bool COpenMaxVideo::change_dec_output_format()
   MMAL_STATUS_T status;
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
 
-#if 0
-  {
   MMAL_PARAMETER_VIDEO_INTERLACE_TYPE_T interlace_type = {{ MMAL_PARAMETER_VIDEO_INTERLACE_TYPE, sizeof( interlace_type )}};
   status = mmal_port_parameter_get( m_dec_output, &interlace_type.hdr );
 
@@ -330,8 +328,7 @@ bool COpenMaxVideo::change_dec_output_format()
   }
   else
     CLog::Log(LOGERROR, "%s::%s Failed to query interlace type on %s (status=%x %s)", CLASSNAME, __func__, m_dec_output->name, status, mmal_status_to_string(status));
-  }
-#endif
+
   // todo: if we don't disable/enable we can do this from callback
   mmal_format_copy(m_dec_output->format, m_es_format);
   status = mmal_port_format_commit(m_dec_output);
@@ -870,7 +867,7 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
            }
          }
          EDEINTERLACEMODE deinterlace_request = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
-#if 0
+         if (1)
          {
            bool deinterlace = m_interlace_mode != MMAL_InterlaceProgressive;
 
@@ -884,7 +881,7 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
            else if (deinterlace && !m_deint)
              CreateDeinterlace();
          }
-#endif
+
          if (buffer_to_free)
          {
            delete [] buffer_to_free;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index f931419..3c9b8a1 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -133,7 +133,7 @@ class COpenMaxVideo
 
   CDVDStreamInfo    m_hints;
   // Components
-  //MMAL_INTERLACETYPE_T m_interlace_mode;
+  MMAL_INTERLACETYPE_T m_interlace_mode;
   bool              m_startframe;
   unsigned int      m_decode_frame_number;
   double            m_decoderPts;

From 2d19a382695fbc6c222f99a4870bfb003e321413 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 18 Aug 2014 19:09:32 +0100
Subject: [PATCH 77/77] rbp: Use new dispmanx function for vsync callbacks

---
 xbmc/linux/RBP.cpp                              | 85 ++++++++++++++-----------
 xbmc/linux/RBP.h                                |  5 +-
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  4 +-
 3 files changed, 52 insertions(+), 42 deletions(-)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 34e0108..462bfa2 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -33,7 +33,7 @@ CRBP::CRBP()
   m_omx_initialized = false;
   m_DllBcmHost      = new DllBcmHost();
   m_OMX             = new COMXCore();
-  m_element = 0;
+  m_display = DISPMANX_NO_HANDLE;
 }
 
 CRBP::~CRBP()
@@ -55,8 +55,7 @@ bool CRBP::Initialize()
 
   m_DllBcmHost->bcm_host_init();
 
-  uint32_t                    vc_image_ptr;
-  m_resource = vc_dispmanx_resource_create( VC_IMAGE_RGB565, 1, 1, &vc_image_ptr );
+  //OpenDisplay(0 /*screen*/);
 
   m_omx_initialized = m_OMX->Initialize();
   if(!m_omx_initialized)
@@ -112,13 +111,24 @@ void CRBP::LogFirmwareVerison()
   CLog::Log(LOGNOTICE, "Config:\n%s", response);
 }
 
+DISPMANX_DISPLAY_HANDLE_T CRBP::OpenDisplay(uint32_t device)
+{
+  if (m_display == DISPMANX_NO_HANDLE)
+    m_display = vc_dispmanx_display_open( 0 /*screen*/ );
+  return m_display;
+}
+
+void CRBP::CloseDisplay(DISPMANX_DISPLAY_HANDLE_T display)
+{
+  assert(display == m_display);
+  vc_dispmanx_display_close(m_display);
+  m_display = DISPMANX_NO_HANDLE;
+}
+
 void CRBP::GetDisplaySize(int &width, int &height)
 {
-  DISPMANX_DISPLAY_HANDLE_T display;
   DISPMANX_MODEINFO_T info;
-
-  display = vc_dispmanx_display_open( 0 /*screen*/ );
-  if (vc_dispmanx_display_get_info(display, &info) == 0)
+  if (vc_dispmanx_display_get_info(m_display, &info) == 0)
   {
     width = info.width;
     height = info.height;
@@ -128,12 +138,10 @@ void CRBP::GetDisplaySize(int &width, int &height)
     width = 0;
     height = 0;
   }
-  vc_dispmanx_display_close(display );
 }
 
 unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool swap_red_blue, bool video_only)
 {
-  DISPMANX_DISPLAY_HANDLE_T display;
   DISPMANX_RESOURCE_HANDLE_T resource;
   VC_RECT_T rect;
   unsigned char *image = NULL;
@@ -148,7 +156,6 @@ unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool sw
   if (!pstride)
     flags |= DISPMANX_SNAPSHOT_PACK;
 
-  display = vc_dispmanx_display_open( 0 /*screen*/ );
   stride = ((width + 15) & ~15) * 4;
   image = new unsigned char [height * stride];
 
@@ -156,45 +163,44 @@ unsigned char *CRBP::CaptureDisplay(int width, int height, int *pstride, bool sw
   {
     resource = vc_dispmanx_resource_create( VC_IMAGE_RGBA32, width, height, &vc_image_ptr );
 
-    vc_dispmanx_snapshot(display, resource, (DISPMANX_TRANSFORM_T)flags);
+    assert(m_display != DISPMANX_NO_HANDLE);
+    vc_dispmanx_snapshot(m_display, resource, (DISPMANX_TRANSFORM_T)flags);
 
     vc_dispmanx_rect_set(&rect, 0, 0, width, height);
     vc_dispmanx_resource_read_data(resource, &rect, image, stride);
     vc_dispmanx_resource_delete( resource );
-    vc_dispmanx_display_close(display );
   }
   if (pstride)
     *pstride = stride;
   return image;
 }
 
-void CRBP::WaitVsync(void)
+
+static void vsync_callback(DISPMANX_UPDATE_HANDLE_T u, void *arg)
+{
+  CEvent *sync = (CEvent *)arg;
+  sync->Set();
+}
+
+void CRBP::WaitVsync()
 {
-  DISPMANX_DISPLAY_HANDLE_T display = vc_dispmanx_display_open( 0 /*screen*/ );
-  DISPMANX_UPDATE_HANDLE_T update = vc_dispmanx_update_start(0);
-
-  VC_DISPMANX_ALPHA_T alpha = { (DISPMANX_FLAGS_ALPHA_T)(DISPMANX_FLAGS_ALPHA_FROM_SOURCE | DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS), 120, /*alpha 0->255*/ 0 };
-  VC_RECT_T       src_rect;
-  VC_RECT_T       dst_rect;
-  vc_dispmanx_rect_set( &src_rect, 0, 0, 1 << 16, 1 << 16 );
-  vc_dispmanx_rect_set( &dst_rect, 0, 0, 1, 1 );
-
-  if (m_element)
-    vc_dispmanx_element_remove( update, m_element );
-
-  m_element = vc_dispmanx_element_add( update,
-                                            display,
-                                            2000,               // layer
-                                            &dst_rect,
-                                            m_resource,
-                                            &src_rect,
-                                            DISPMANX_PROTECTION_NONE,
-                                            &alpha,
-                                            NULL,             // clamp
-                                            (DISPMANX_TRANSFORM_T)0 );
-
-  vc_dispmanx_update_submit_sync(update);
-  vc_dispmanx_display_close( display );
+  int s;
+  CEvent sync;
+  DISPMANX_DISPLAY_HANDLE_T m_display = vc_dispmanx_display_open( 0 /*screen*/ );
+  if (m_display == DISPMANX_NO_HANDLE)
+  {
+    CLog::Log(LOGDEBUG, "CRBP::%s skipping while display closed", __func__);
+    return;
+  }
+  s = vc_dispmanx_vsync_callback(m_display, vsync_callback, (void *)&sync);
+  if (s == 0)
+  {
+    sync.Wait();
+  }
+  else assert(0);
+  s = vc_dispmanx_vsync_callback(m_display, NULL, NULL);
+  assert(s == 0);
+  vc_dispmanx_display_close( m_display );
 }
 
 
@@ -206,6 +212,9 @@ void CRBP::Deinitialize()
   if(m_omx_initialized)
     m_OMX->Deinitialize();
 
+  if (m_display)
+    CloseDisplay(m_display);
+
   m_DllBcmHost->bcm_host_deinit();
 
   if(m_initialized)
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index f947acc..ca80045 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -53,6 +53,8 @@ class CRBP
   bool GetCodecMpg2() { return m_codec_mpg2_enabled; }
   bool GetCodecWvc1() { return m_codec_wvc1_enabled; }
   void GetDisplaySize(int &width, int &height);
+  DISPMANX_DISPLAY_HANDLE_T OpenDisplay(uint32_t device);
+  void CloseDisplay(DISPMANX_DISPLAY_HANDLE_T display);
   int GetGUIResolutionLimit() { return m_gui_resolution_limit; }
   // stride can be null for packed output
   unsigned char *CaptureDisplay(int width, int height, int *stride, bool swap_red_blue, bool video_only = true);
@@ -73,10 +75,9 @@ class CRBP
   bool       m_codec_mpg2_enabled;
   bool       m_codec_wvc1_enabled;
   COMXCore   *m_OMX;
-  DISPMANX_RESOURCE_HANDLE_T m_resource;
-  DISPMANX_ELEMENT_HANDLE_T m_element;
   class DllLibOMXCore;
   CCriticalSection m_critSection;
+  DISPMANX_DISPLAY_HANDLE_T m_display;
 };
 
 extern CRBP g_RBP;
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index ca36082..4b74ea0 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -306,7 +306,7 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
     m_desktopRes = res;
   }
 
-  m_dispman_display = m_DllBcmHost->vc_dispmanx_display_open(0);
+  m_dispman_display = g_RBP.OpenDisplay(0);
 
   m_width   = res.iWidth;
   m_height  = res.iHeight;
@@ -571,7 +571,7 @@ void CEGLNativeTypeRaspberryPI::DestroyDispmaxWindow()
 
   if (m_dispman_display != DISPMANX_NO_HANDLE)
   {
-    m_DllBcmHost->vc_dispmanx_display_close(m_dispman_display);
+    g_RBP.CloseDisplay(m_dispman_display);
     m_dispman_display = DISPMANX_NO_HANDLE;
   }
   DLOG("CEGLNativeTypeRaspberryPI::DestroyDispmaxWindow\n");
